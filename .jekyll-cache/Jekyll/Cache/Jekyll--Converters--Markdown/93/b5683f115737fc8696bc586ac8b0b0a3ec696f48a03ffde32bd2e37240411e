I"~á<h3 id="the-blog-post-has-been-created-for-completing-the-requirements-of-the-securitytube-linux-assembly-expert-certification">The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</h3>
<p><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a><br />
Student ID: SLAE-990</p>

<p>Assignment #5</p>

<hr />

<h2 id="description">Description</h2>
<ul>
  <li>Take up at least 3 shellcode samples created using msfpayload/msfvenom for linux/x86</li>
  <li>Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode</li>
  <li>Present your analysis</li>
</ul>

<p><strong>The following three msfvenom payloads were analyzed:</strong><br />
<a href="#sample1">Sample1: linux/x86/exec</a><br />
<a href="#sample2">Sample2: linux/x86/read_file</a><br />
<a href="#sample3">Sample3: linux/x86/chmod</a><br /></p>

<p><a name="sample1"></a></p>
<h2 id="sample1-linuxx86exec">Sample1: linux/x86/exec</h2>
<p>To generate a payload with the linux/x86/exec payload I executed the following command to generate shellcode that could be placed into my test C program.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample1]<span class="nv">$ </span>msfvenom <span class="nt">-p</span> linux/x86/exec <span class="nv">cmd</span><span class="o">=</span><span class="s2">"pwd"</span> <span class="nt">-e</span> x86/shikata_ga_nai <span class="nt">-b</span> <span class="s1">'\x00'</span> <span class="nt">-f</span> c
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 66 <span class="o">(</span><span class="nv">iteration</span><span class="o">=</span>0<span class="o">)</span>
x86/shikata_ga_nai chosen with final size 66
Payload size: 66 bytes
Final size of c file: 303 bytes
unsigned char buf[] <span class="o">=</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">da</span><span class="se">\x</span><span class="s2">c3</span><span class="se">\x</span><span class="s2">ba</span><span class="se">\x</span><span class="s2">35</span><span class="se">\x</span><span class="s2">b7</span><span class="se">\x</span><span class="s2">98</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">d9</span><span class="se">\x</span><span class="s2">74</span><span class="se">\x</span><span class="s2">24</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">58</span><span class="se">\x</span><span class="s2">29</span><span class="se">\x</span><span class="s2">c9</span><span class="se">\x</span><span class="s2">b1"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">0a</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">16</span><span class="se">\x</span><span class="s2">03</span><span class="se">\x</span><span class="s2">50</span><span class="se">\x</span><span class="s2">16</span><span class="se">\x</span><span class="s2">e2</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">dd</span><span class="se">\x</span><span class="s2">93</span><span class="se">\x</span><span class="s2">bb"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">b3</span><span class="se">\x</span><span class="s2">70</span><span class="se">\x</span><span class="s2">c2</span><span class="se">\x</span><span class="s2">53</span><span class="se">\x</span><span class="s2">ee</span><span class="se">\x</span><span class="s2">17</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">43</span><span class="se">\x</span><span class="s2">98</span><span class="se">\x</span><span class="s2">f8</span><span class="se">\x</span><span class="s2">e0</span><span class="se">\x</span><span class="s2">e3</span><span class="se">\x</span><span class="s2">58</span><span class="se">\x</span><span class="s2">6f</span><span class="se">\x</span><span class="s2">28"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">96</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">01</span><span class="se">\x</span><span class="s2">bf</span><span class="se">\x</span><span class="s2">b5</span><span class="se">\x</span><span class="s2">93</span><span class="se">\x</span><span class="s2">35</span><span class="se">\x</span><span class="s2">bb</span><span class="se">\x</span><span class="s2">39</span><span class="se">\x</span><span class="s2">13</span><span class="se">\x</span><span class="s2">c6</span><span class="se">\x</span><span class="s2">b4</span><span class="se">\x</span><span class="s2">4e</span><span class="se">\x</span><span class="s2">77</span><span class="se">\x</span><span class="s2">c6"</span>
<span class="s2">"</span><span class="se">\x</span><span class="s2">63</span><span class="se">\x</span><span class="s2">e2</span><span class="se">\x</span><span class="s2">fe</span><span class="se">\x</span><span class="s2">27</span><span class="se">\x</span><span class="s2">46</span><span class="se">\x</span><span class="s2">84"</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>I then copied this into a test C program and made sure that it executed.  If working properly it should print the current working directory (pwd).</p>

<p>NOTE: One thing to note here is that I have excluded null bytes as they don‚Äôt play well in shellcode.  Due to this, the x86/shikata_ga_nai encoded has been used there will be additional assembly we need to work through before getting the the target assembly that will do our work.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> \
<span class="s">"</span><span class="se">\xda\xc3\xba\x35\xb7\x98\xe3\xd9\x74\x24\xf4\x58\x29\xc9\xb1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x0a\x83\xc0\x04\x31\x50\x16\x03\x50\x16\xe2\xc0\xdd\x93\xbb</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xb3\x70\xc2\x53\xee\x17\x83\x43\x98\xf8\xe0\xe3\x58\x6f\x28</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x96\x31\x01\xbf\xb5\x93\x35\xbb\x39\x13\xc6\xb4\x4e\x77\xc6</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x63\xe2\xfe\x27\x46\x84</span><span class="s">"</span><span class="p">;</span>

<span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Shellcode Length:  %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">code</span><span class="p">;</span>
    <span class="n">ret</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample1]<span class="nv">$ </span>gcc pwd_payload.c <span class="nt">-o</span> pwd_payload
<span class="o">[</span>sengen@manjaro-x86 sample1]<span class="nv">$ </span>./pwd_payload
Shellcode Length:  66
/home/sengen/work/slae32/assignment5/sample1
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="getting-a-general-idea-of-the-flow-via-libemu-sctest">Getting a general idea of the flow via LibEmu (sctest)</h3>
<p>Running this gives us two things: Some sudo code that shows system calls that have occurred along with the parameters, second we are generating a graph file to visually represent what would be executing.</p>

<p>In this particular example it appears we are getting one call to execve that is executing ‚Äú/bin/sh -c pwd‚Äù.  We‚Äôll walk through the assembly to observe how it got to this point.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample1]<span class="nv">$ </span>msfvenom <span class="nt">-p</span> linux/x86/exec <span class="nv">cmd</span><span class="o">=</span><span class="s2">"pwd"</span> <span class="nt">-e</span> x86/shikata_ga_nai <span class="nt">-b</span> <span class="s1">'\x00'</span> <span class="nt">-f</span> raw | sctest <span class="nt">-v</span> <span class="nt">-Ss</span> 10000 <span class="nt">-G</span> pwd_payload.dot
...
int execve <span class="o">(</span>
     const char <span class="k">*</span> dateiname <span class="o">=</span> 0x00416fc4 <span class="o">=&gt;</span>
           <span class="o">=</span> <span class="s2">"/bin/sh"</span><span class="p">;</span>
     const char <span class="k">*</span> argv[] <span class="o">=</span> <span class="o">[</span>
           <span class="o">=</span> 0x00416fb4 <span class="o">=&gt;</span>
               <span class="o">=</span> 0x00416fc4 <span class="o">=&gt;</span>
                   <span class="o">=</span> <span class="s2">"/bin/sh"</span><span class="p">;</span>
           <span class="o">=</span> 0x00416fb8 <span class="o">=&gt;</span>
               <span class="o">=</span> 0x00416fcc <span class="o">=&gt;</span>
                   <span class="o">=</span> <span class="s2">"-c"</span><span class="p">;</span>
           <span class="o">=</span> 0x00416fbc <span class="o">=&gt;</span>
               <span class="o">=</span> 0x00417038 <span class="o">=&gt;</span>
                   <span class="o">=</span> <span class="s2">"pwd"</span><span class="p">;</span>
           <span class="o">=</span> 0x00000000 <span class="o">=&gt;</span>
             none<span class="p">;</span>
     <span class="o">]</span><span class="p">;</span>
     const char <span class="k">*</span> envp[] <span class="o">=</span> 0x00000000 <span class="o">=&gt;</span>
         none<span class="p">;</span>
<span class="o">)</span> <span class="o">=</span>  0<span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Generated graph from LibEmu</strong><br />
Generated via the command <code class="language-plaintext highlighter-rouge">dot pwd_payload.dot -Tpng -o pwd_payload.png</code>.  The graph here shows a loop that occurs prior to the instructions that actually do our execve.  This loop is the decoder routine as a result of x86/shikata_ga_nai.</p>

<p><img src="http://localhost:4000/images/slae32/05-01.png" /></p>

<h3 id="stepping-through-shellcode-with-gdb">Stepping through shellcode with GDB</h3>
<h4 id="decoder-scheme">Decoder scheme</h4>
<p>The shellcode starts by moving into a loop where the shellcode is decoded in full dword segments (4 bytes at a time).  When this process is complete the it will move on to the actual shellcode to perform the ‚Äúpwd‚Äù command.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>[sengen@manjaro-x86 assignment5]$ gdb ./pwd_payload

gdb$ disassembdisassemble &amp;code
Dump of assembler code for function code:
=&gt; 0x00402040 &lt;+0&gt;:	fcmovb st,st(3)
   0x00402042 &lt;+2&gt;:	mov    edx,0xe398b735
   0x00402047 &lt;+7&gt;:	fnstenv [esp-0xc]
   0x0040204b &lt;+11&gt;:	pop    eax
   0x0040204c &lt;+12&gt;:	sub    ecx,ecx
   0x0040204e &lt;+14&gt;:	mov    cl,0xa
   0x00402050 &lt;+16&gt;:	add    eax,0x4                    ; decoder loop
   0x00402053 &lt;+19&gt;:	xor    DWORD PTR [eax+0x16],edx   ; decoder loop
   0x00402056 &lt;+22&gt;:	add    edx,DWORD PTR [eax+0x16]   ; decoder loop
   0x00402059 &lt;+25&gt;:	loop   0x40201b                   ; decoder loop
   ...
   instructions below here will be XOR'ed
End of assembler dump.
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="setting-up-the-call">Setting up the call</h4>
<p>We start to push onto the stack the first two pieces of the command.  The ‚Äú-c‚Äù is pushed to the stack and the stack location and stored into EDI. The ‚Äú/bin/sh‚Äù is pushed onto the stack and the stack location is stored into EBX.</p>

<p>A CALL at 0x00402078 is performed.  The purpose of this is so that the stack contains the next address which is 0x00402078 which happens to contain a pointer to the text ‚Äúpwd‚Äù.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre>=&gt; 0x0040205b &lt;+27&gt;:	push   0xb                        ; 0xb = execve
   0x0040205d &lt;+29&gt;:	pop    eax                        ; 0xb = execve
   0x0040205e &lt;+30&gt;:	cdq                               ; EDX=0x0 (EAX extend)
   0x0040205f &lt;+31&gt;:	push   edx                        ; push 0x0 to stack
   0x00402060 &lt;+32&gt;:	pushw  0x632d                     ; "-c"
   0x00402064 &lt;+36&gt;:	mov    edi,esp                    ; edi = pointer to stack
   0x00402066 &lt;+38&gt;:	push   0x68732f                   ; "/sh"
   0x0040206b &lt;+43&gt;:	push   0x6e69622f                 ; "/bin"
   0x00402070 &lt;+48&gt;:	mov    ebx,esp                    ; ebx = pointer to stack
   0x00402072 &lt;+50&gt;:	push   edx                        ; push 0x0 to stack
   0x00402073 &lt;+51&gt;:	call   0x40207c &lt;code+60&gt;         ; 0x00402078 =&gt; "pwd"
   0x00402078 &lt;+56&gt;:	jo     0x4020f1
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now that the stack contains [0x00402078	0x00000000] which is effectively ‚Äúpwd\0‚Äù we perform two more pushes to setup the full command that we‚Äôll send to the execve system call.</p>

<p>After these instructions ECX will point to [0xbffff012, 0xbffff01a, 0x00402078, 0x00000000] on the stack.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre>   0x40207c &lt;code+60&gt;:	push   edi                        ; pushes "-c" address
   0x40207d &lt;code+61&gt;:	push   ebx                        ; pushes "/bin/sh" address
   0x40207e &lt;code+62&gt;:	mov    ecx,esp                    ; moves pointer to stack to ecx
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We finally make our call to execve which prints the current working directory.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>   0x402080 &lt;code+64&gt;:	int    0x80                       ; calls execve
</pre></td></tr></tbody></table></code></pre></div></div>

<p><a name="sample2"></a></p>
<h2 id="sample2-linuxx86read_file">Sample2: linux/x86/read_file</h2>
<p>To generate a payload with the linux/x86/read_file payload I executed the following command to generate shellcode that could be placed into my test C program.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> --><td class="rouge-code"><pre>[sengen@manjaro-x86 sample2]$ msfvenom -p linux/x86/read_file fd=1 path=/etc/passwd -b '\x00' -f c
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 100 (iteration=0)
x86/shikata_ga_nai chosen with final size 100
Payload size: 100 bytes
Final size of c file: 445 bytes
unsigned char buf[] =
"\xba\xb0\xf6\x73\xfc\xda\xc6\xd9\x74\x24\xf4\x5e\x2b\xc9\xb1"
"\x13\x83\xc6\x04\x31\x56\x0f\x03\x56\xbf\x14\x86\x17\x89\x60"
"\x6c\xe8\xf5\x90\x34\xd9\x3c\x5d\x4a\x90\x7d\xe6\x48\xa3\x81"
"\x17\xc6\x44\x08\xee\x62\x8a\x1a\x11\x93\x46\x9a\x98\x51\xe0"
"\x9e\x9a\x55\x11\x25\x9b\x55\x11\x59\x51\xd5\xa9\x58\x69\xd6"
"\xc9\xe1\x69\xd6\xc9\x15\xa7\x56\x21\xd0\xc8\xa8\x4d\xf5\x53"
"\x23\xd1\x26\xec\xaa\x66\x4b\x7b\x49\x89";
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="copied-the-shellcode-to-a-test-program-and-made-sure-it-worked">Copied the shellcode to a test program and made sure it worked</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample2]<span class="nv">$ </span>gcc readfile_payload.c <span class="nt">-o</span> readfile_payload
<span class="o">[</span>sengen@manjaro-x86 sample2]<span class="nv">$ </span>./readfile_payload
Shellcode Length:  100
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/usr/bin/nologin
daemon:x:2:2:daemon:/:/usr/bin/nologin
mail:x:8:12:mail:/var/spool/mail:/usr/bin/nologin
ftp:x:14:11:ftp:/srv/ftp:/usr/bin/nologin
http:x:33:33:http:/srv/http:/usr/bin/nologin
dbus:x:81:81:dbus:/:/usr/bin/nologin
nobody:x:99:99:nobody:/:/usr/bin/nologin
systemd-journal-gateway:x:191:191:systemd-journal-gateway:/:/usr/bin/nologin
systemd-timesync:x:192:192:systemd-timesync:/:/usr/bin/nologin
systemd-network:x:193:193:systemd-network:/:/usr/bin/nologin
systemd-bus-proxy:x:194:194:systemd-bus-proxy:/:/usr/bin/nologin
systemd-resolve:x:195:195:systemd-resolve:/:/usr/bin/nologin
systemd-coredump:x:998:998:systemd Core Dumper:/:/sbin/nologin
systemd-journal-upload:x:997:997:systemd Journal Upload:/:/sbin/nologin
systemd-journal-remote:x:999:999:systemd Journal Remote:/:/sbin/nologin
uuidd:x:68:68::/:/sbin/nologin
rpc:x:32:32:Rpcbind Daemon:/dev/null:/bin/false
dnsmasq:x:996:996:dnsmasq daemon:/:/sbin/nologin
avahi:x:84:84:avahi:/:/bin/nologin
polkitd:x:102:102:Policy Kit Daemon:/:/usr/bin/nologin
rtkit:x:133:133:RealtimeKit:/proc:/bin/false
usbmux:x:140:140:usbmux user:/:/sbin/nologin
colord:x:124:124::/var/lib/colord:/bin/false
gdm:x:120:120:Gnome Display Manager:/var/lib/gdm:/sbin/nologin
ntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/false
nm-openconnect:x:995:995:NetworkManager OpenConnect:/:/usr/bin/nologin
nm-openvpn:x:994:994:NetworkManager OpenVPN:/:/usr/bin/nologin
sengen:x:1000:1000:sengen:/home/sengen:/bin/bash
git:x:993:993:git daemon user:/:/bin/bash
postgres:x:88:88:PostgreSQL user:/var/lib/postgres:/bin/bash
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="analyzing-program-with-gdb">Analyzing program with GDB</h3>
<p>Similar to the first sample, some encoding is happening on the shellcode so when we dump the assembly before running anything it will show the decoder routine followed by nonsensical instructions that have yet to be XOR‚Äôed back to something useful.</p>

<h4 id="decoding">Decoding</h4>
<p>Our decode loop looks like the following</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>0x00402050 &lt;+16&gt;:	add    esi,0x4
0x00402053 &lt;+19&gt;:	xor    DWORD PTR [esi+0xf],edx
0x00402056 &lt;+22&gt;:	add    edx,DWORD PTR [esi+0xf]
0x00402059 &lt;+25&gt;:	loop   0x402050 &lt;code+16&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="getting-memory-location-to-the-file-path">Getting memory location to the file path</h4>
<p>To acquire the string ‚Äú/etc/passwd‚Äù the msfvenom payload is using a jump/call trick.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>0x0040205b &lt;+27&gt;:	jmp    0x402093 &lt;code+83&gt;   ; jump ahead near our string
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We land on the following instruction where we just turn around and make a call back to where we came from. By making a call like this the next memory address is pushed on the stack which happens to be where our string ‚Äú/etc/passed‚Äù is stored.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>0x402093 &lt;code+83&gt;:	call   0x40205d &lt;code+29&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>There is no intent to return from the above call as we‚Äôll now pop the address into EBX for use in our ‚Äúopen‚Äù system call. The system call is defined as:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>EBX contains the pathname<br />
ECX contains the flags</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>0x0040205d &lt;+29&gt;:	mov    eax,0x5              ; value of "open" system call
0x00402062 &lt;+34&gt;:	pop    ebx                  ; get the address to "/etc/passwd"
0x00402063 &lt;+35&gt;:	xor    ecx,ecx              ; zero out ecx
0x00402065 &lt;+37&gt;:	int    0x80                 ; #define __NR_open 5
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now that the file has been opened we can perform a read of the contents into a 4096 byte buffer.  The ‚Äúopen‚Äù system call returned to us a file descriptor (3) that we can now use for reading. The ‚Äúread‚Äù system call is defined as:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The resulting content that was read will be pointed to by ECX.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre>0x00402067 &lt;+39&gt;:	mov    ebx,eax              ; ebx = 3
0x00402069 &lt;+41&gt;:	mov    eax,0x3              ; eax = 3 (already was)
0x0040206e &lt;+46&gt;:	mov    edi,esp              ; edi = pointer to stack
0x00402070 &lt;+48&gt;:	mov    ecx,edi              ; ecx = pointer to stack
0x00402072 &lt;+50&gt;:	mov    edx,0x1000           ; edx = 4096
0x00402077 &lt;+55&gt;:	int    0x80                 ; #define __NR_read 3
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now that the content is stored in our buffer it will be written to the stdcout pre-defined file descriptor (1). The ‚Äúwrite‚Äù system call is defined as:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At this point it is a matter of writing the buffer pointed to by ECX to STDOUT which will show the content on the console.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>0x00402079 &lt;+57&gt;:	mov    edx,eax              ; edx = read return value
0x0040207b &lt;+59&gt;:	mov    eax,0x4              ; eax = 4 // write
0x00402080 &lt;+64&gt;:	mov    ebx,0x1              ; ebx = 1 // STDOUT
0x00402085 &lt;+69&gt;:	int    0x80	                ; #define __NR_write 4
</pre></td></tr></tbody></table></code></pre></div></div>

<p><a name="sample3"></a></p>
<h2 id="sample3-linuxx86chmod">Sample3: linux/x86/chmod</h2>
<p>To generate a payload with the linux/x86/chmod payload I executed the following command to generate shellcode that could be placed into my test C program.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre>[sengen@manjaro-x86 sample3]$ msfvenom -p linux/x86/chmod file=/tmp/test.txt mode=0755 -b '\x00' -f c
No platform was selected, choosing Msf::Module::Platform::Linux from the payload
No Arch selected, selecting Arch: x86 from the payload
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 65 (iteration=0)
x86/shikata_ga_nai chosen with final size 65
Payload size: 65 bytes
Final size of c file: 299 bytes
unsigned char buf[] =
"\xbd\x58\xd7\xe5\xe6\xd9\xed\xd9\x74\x24\xf4\x58\x33\xc9\xb1"
"\x0a\x31\x68\x14\x83\xe8\xfc\x03\x68\x10\xba\x22\x7c\x8c\x35"
"\x95\x2d\xb9\x47\x25\xd2\x39\x78\x51\xbf\x49\xa9\xed\x5a\xd9"
"\xc1\x23\xd1\x65\x5d\x3c\x42\xfe\x70\x3d\x74\xfe\xd3\xf3\xf4"
"\x94\xe2\x53\x38\xe8";
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="copied-the-shellcode-to-a-test-program-and-made-sure-it-worked-1">Copied the shellcode to a test program and made sure it worked</h3>
<p>Once compiled with GCC I created a temp file and that defaulted to 644 and ran the shellcode against it to change it to 755.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>gcc chmod_payload.c <span class="nt">-o</span> chmod_payload
<span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span><span class="nb">touch</span> /tmp/test.txt
<span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>ll /tmp/test.txt
<span class="nt">-rw-r--r--</span> 1 sengen sengen 0 Jan 20 19:06 /tmp/test.txt
<span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>./chmod_payload
Shellcode Length:  65
<span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>ll /tmp/test.txt
<span class="nt">-rwxr-xr-x</span> 1 sengen sengen 0 Jan 20 19:06 /tmp/test.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="creating-a-graph-with-libemu">Creating a graph with LibEmu</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre><span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>msfvenom <span class="nt">-p</span> linux/x86/chmod <span class="nv">file</span><span class="o">=</span>/tmp/test.txt <span class="nv">mode</span><span class="o">=</span>0755 <span class="nt">-b</span> <span class="s1">'\x00'</span> <span class="nt">-f</span> raw | sctest <span class="nt">-v</span> <span class="nt">-Ss</span> 10000 <span class="nt">-G</span> chmod_payload.dot
<span class="o">[</span>sengen@manjaro-x86 sample3]<span class="nv">$ </span>dot chmod_payload.dot <span class="nt">-Tpng</span> <span class="nt">-o</span> chmod_payload.png
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The graph of program flow shows the shakita_ga_nai decoder followed by the setup for the chmod system call and finally an exit system call.</p>

<p><img src="http://localhost:4000/images/slae32/05-02.png" /></p>

<h3 id="viewing-the-assembly-in-gdb">Viewing the assembly in GDB</h3>
<p>As we saw in the program flow graph above there is a loop where we decode our bytes.  The decoding loop was identified as the instructions below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>0x00402050 &lt;+16&gt;:	xor    DWORD PTR [eax+0x14],ebp
0x00402053 &lt;+19&gt;:	sub    eax,0xfffffffc
0x00402056 &lt;+22&gt;:	add    ebp,DWORD PTR [eax+0x10]
0x00402059 &lt;+25&gt;:	loop   0x402050 &lt;code+16&gt;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We set EAX to 15 which is the chmod system call number and push a null byte to the stack.  The CALL statement will push the address of the next instruction onto the stack.  This address happens to be a pointer to our string ‚Äú/tmp/test.txt‚Äù.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre>0x0040205b &lt;+27&gt;:	cdq                         ; edx = 0 (eax extend)
0x0040205c &lt;+28&gt;:	push   0xf                  ; push 15 to stack
0x0040205e &lt;+30&gt;:	pop    eax                  ; eax = 15
0x0040205f &lt;+31&gt;:	push   edx                  ; push null byte to stack
0x00402060 &lt;+32&gt;:	call   0x402073 &lt;code+51&gt;   ; jump to +51
</pre></td></tr></tbody></table></code></pre></div></div>

<p>We immediately pop the address to our path string from the stack into EBX.  We set our mode of 755 (octal) in hex which is 0x1ED and finally interrupt.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>0x00402073 &lt;+51&gt;:	pop    ebx                  ; ebx = "/tmp/test.txt"
0x00402074 &lt;+52&gt;:	push   0x1ed                ; 755 in octal (mode)
0x00402079 &lt;+57&gt;:	pop    ecx                  ; ecx = mode
0x0040207a &lt;+58&gt;:	int    0x80                 ; #define __NR_chmod 15
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Lastly, we set EAX to 1 in order to perform an exit system call.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre>0x0040207c &lt;+60&gt;:	push   0x1                  ; push 1 to stack
0x0040207e &lt;+62&gt;:	pop    eax                  ; eax = 1
0x0040207f &lt;+63&gt;:	int    0x80                 ; #define __NR_exit 1
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="source-code">Source code</h3>
<p>All source code for this assignment can be found at<br />
 <a href="https://github.com/tdmathison/SLAE32/tree/master/assignment5">https://github.com/tdmathison/SLAE32/tree/master/assignment5</a>.</p>
:ET